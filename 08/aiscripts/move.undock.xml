<?xml version="1.0" encoding="utf-8" ?>
<aiscript name="move.undock" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="8">
  <!--

this script handles undocking from the current dock
Initial Author: Owen

Important: 
  Undock script will redirect to 'move.unpark' if necessary
  Do NOT use 'move.unpark' directly, instead use 'move.undock'

-->
  <order id="Undock" name="{1041, 531}" description="{1041, 532}" category="internal" allowinloop="false">
    <params>
      <param name="uselaunchtubes" type="bool" default="false" text="{1041, 10140}" advanced="true" comment="Use launch tubes. Ships in internal storage that undock from a ship with launch tubes are launched from launch tubes. Will be set to false below if container has no launch tubes or ship does not, in fact, launch from a launch tube. Note that this does not assure that ships use launch tubes, but will request their use and involves handling in the script for ships that are launched from launch tubes."/>
      <param name="releasesignal" type="internal" default="null" comment="Release signal. List: [param, param2]. Wait will be cancelled if a signal with $releasesignal.{1} as event.param and $releasesignal.{2} as event.param2 is sent to this.object. While event.param MUST be non-null, event.param2 may be null."/>
      <param name="skipwait" type="internal" default="false" text="{1041, 10116}" comment="Skip wait. Do not wait for the player"/>
      <param name="debugchance" type="bool" default="0" advanced="true" text="{1041, 10086}" comment="Print debug output">
        <input_param name="truevalue" value="100"/>
      </param>
    </params>
  </order>
  <interrupts>
    <handler ref="TargetInvalidHandler"/>
    <handler ref="LostReservationHandler"/>
  </interrupts>
  <init>
    <set_command_action commandaction="commandaction.undocking" />

    <set_value name="$thisship" exact="this.assignedcontrolled"/>
    <do_if value="this == player.computer" comment="this is sometimes Betty but Betty is not assigned to control this.ship">
      <set_value name="$thisship" exact="this.ship"/>
    </do_if>

    <do_if value="@$thisship.dock.islaunchtube">
      <set_value name="$uselaunchtubes" exact="true"/>
    </do_if>
    <do_elseif value="$uselaunchtubes and $thisship.dock">
      <!-- we know we're not docked at a launchtube, otherwise the do_if above would have caught it -->
      <set_value name="$uselaunchtubes" exact="false"/>
      <do_if value="not $thisship.iscapitalship">
        <find_dockingbay name="$docks" object="$thisship.container" checkoperational="1" multiple="1">
          <match_dock size="$thisship.docksize" storage="false"/>
        </find_dockingbay>
        <do_for_each name="$dock" in="$docks">
          <do_if value="$dock.islaunchtube">
            <set_value name="$uselaunchtubes" exact="true"/>
            <break/>
          </do_if>
        </do_for_each>
      </do_if>
      <remove_value name="$docks"/>
    </do_elseif>

    <!-- orders that either require no movement or that require thinking before movement. -->
    <set_value name="$blockingorders" exact="['Wait', 'Escort', 'TradeRoutine', 'TradeRoutine_Basic', 'TradeRoutine_Advanced', 'Middleman', 'MiningRoutine', 'MiningRoutine_Basic', 'MiningRoutine_Advanced', 'MiningRoutine_Expert']"/>
  </init>
  <patch sinceversion="1">
    <do_if value="@$releasesignal.{1} and not player.occupiedship and $thisship.isplayerowned and $thisship.dock and not $thisship.isunit and not $thisship.iscapitalship and not $thisship.islasertower and not $thisship.dock.isventureronly">
      <do_if value="@$thisship.commander.exists and ($thisship.commander == @player.entity.$PlayerTaxi)">
        <signal_objects object="$thisship" param="$releasesignal.{1}" delay="1s"/>
      </do_if>
    </do_if>
  </patch>
  <patch sinceversion="2">
    <set_value name="$dockmodule" exact="null"/>
    <do_if value="$thisship.dock and @$thisship.dock.walkablemodule.isoperational">
      <set_value name="$dockmodule" exact="$thisship.dock.walkablemodule"/>
    </do_if>
  </patch>
  <patch sinceversion="3">
    <!-- NB: possible that $dockmodule has not been initialized yet, in which case, flightbehaviour.undock is consistent with pre-patch behaviour. -->
    <do_if value="$thisship.assigneddock and @$dockmodule.haswaypointpath.{$thisship.assigneddock.grouptag}.[tag.dockpath, tag.start]">
      <set_value name="$flightbehaviour" exact="flightbehaviour.undockpath"/>
    </do_if>
    <do_else>
      <set_value name="$flightbehaviour" exact="flightbehaviour.undock"/>
    </do_else>
  </patch>
  <patch sinceversion="5">
    <set_value name="$blockingorders" exact="['Wait', 'Escort', 'TradeRoutine', 'TradeRoutine_Basic', 'TradeRoutine_Advanced', 'Middleman', 'MiningRoutine', 'MiningRoutine_Basic', 'MiningRoutine_Advanced', 'MiningRoutine_Expert']"/>
  </patch>
  <attention min="unknown">
    <actions>

      <!-- redirect to unparking script -->
      <do_if value="$thisship.parkedat">
        <set_value name="$parkedatcontrollable" exact="$thisship.parkedat"/>
        <do_if value="$parkedatcontrollable.controllable">
          <set_value name="$parkedatcontrollable" exact="$parkedatcontrollable.controllable"/>
        </do_if>
        <run_script name="'move.unpark'">
          <param name="quick" value="@$parkedatcontrollable.order.id == 'Undock'"/>
        </run_script>
        <remove_value name="$parkedatcontrollable"/>
        <resume label="cleanup"/>
      </do_if>

      <label name="start" />

      <do_if value="$thisship.isunit and @$thisship.order.id == 'Undock'">
        <!-- once a unit starts undocking, it must finish, otherwise it could get stuck in a state where it won't be recovered. -->
        <set_order_state order="$thisship.order" state="orderstate.critical"/>
      </do_if>

      <do_if value="not player.occupiedship and $thisship.dock and not $thisship.isunit and not $thisship.islasertower and not $thisship.dock.isventureronly">
        <do_if value="@$releasesignal.{1} and ($thisship != player.container) and not $skipwait and $thisship.isplayerowned and not $thisship.iscapitalship and not $thisship.commander">
          <set_value name="$playertoplvlcontainer" exact="player.entity.container"/>
          <do_while value="$playertoplvlcontainer.container">
            <set_value name="$playertoplvlcontainer" exact="$playertoplvlcontainer.container"/>
          </do_while>
          <debug_text text="'playertoplvlcontainer is %s %s.'.[$playertoplvlcontainer.knownname, $playertoplvlcontainer]" chance="$debugchance"/>

          <debug_text text="'$thisship == @player.entity.$PlayerTaxi: ' + ($thisship == @player.entity.$PlayerTaxi) + ', not @player.entity.$PlayerTaxi.isoperational: ' + (not @player.entity.$PlayerTaxi.isoperational) + ', not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer}: ' + (not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer}) + ', player.entity.$PlayerTaxi != $playertoplvlcontainer: ' + (player.entity.$PlayerTaxi != $playertoplvlcontainer)" chance="$debugchance"/>
          <do_if value="($playertoplvlcontainer == $thisship.container) and ( (player.shouldplayertaxiwaitforplayer and $thisship == @player.entity.$PlayerTaxi) or (player.shouldplayershipswaitforplayer and (not @player.entity.$PlayerTaxi.isoperational or not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer}) and @player.entity.$PlayerTaxi != $playertoplvlcontainer) )">
            <debug_text text="'waiting for the player.\n ($thisship != player.container): %s\n not $skipwait: %s\n (not $thisship.commander or ($thisship.commander == @player.entity.$PlayerTaxi)): %s\n (($thisship == @player.entity.$PlayerTaxi) or not @player.entity.$PlayerTaxi.isoperational or not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer}): %s'.[($thisship != player.container), not $skipwait, (not $thisship.commander or ($thisship.commander == @player.entity.$PlayerTaxi)), (($thisship == @player.entity.$PlayerTaxi) or not @player.entity.$PlayerTaxi.isoperational or not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer})]" chance="0"/>
            <debug_text text="'player taxi docked on %s %s and the player is not on board. waiting. time started: %s'.[$playertoplvlcontainer.knownname, $playertoplvlcontainer, player.age]" chance="$debugchance"/>
            <run_script name="'player.interaction'">
              <param name="Line" value="10802" comment="(Informing player ship will not undock before they return)I'll wait for you to tell me to take off."/>
              <param name="MaxQueueDelay" value="10s"/>
              <param name="caption" value="{1016,6}.[$thisship.knownname, $thisship.idcode]"/>
              <param name="interactive" value="false"/>
              <param name="debugchance" value="$debugchance"/>
            </run_script>
            <wait>
              <interrupt>
                <conditions>
                  <check_any>
                    <check_all>
                      <event_ui_triggered control="'playertaxiwait'"/>
                      <check_value value="not player.shouldplayertaxiwaitforplayer"/>
                      <check_value value="$thisship == @player.entity.$PlayerTaxi"/>
                    </check_all>
                    <check_all>
                      <event_ui_triggered control="'playershipswait'"/>
                      <check_value value="not player.shouldplayershipswaitforplayer"/>
                      <check_value value="$thisship != @player.entity.$PlayerTaxi" comment="$PlayerTaxi may be null"/>
                    </check_all>
                    <event_object_signalled object="$thisship" param="$releasesignal.{1}"/>
                    <check_all>
                      <event_player_teleport_successful/>
                      <check_value value="not player.entity.hascontext.{$playertoplvlcontainer}"/>
                    </check_all>
                    <check_all>
                      <event_object_undocked_from container="$playertoplvlcontainer"/>
                      <check_value value="player.entity.hascontext.{event.param}"/>
                    </check_all>
                    <check_all>
                      <!-- proceed when the player issues a new order. -->
                      <event_object_order_ready object="this.assignedcontrolled"/>
                      <check_value value="@$releasesignal.{1} == 'playerownedship_proceed'"/>
                      <check_value value="(event.param != this.assignedcontrolled.order) and (event.param != this.assignedcontrolled.defaultorder)"/>
                      <debug_text text="'Undock proceed: new order: ' + @event.param.id" debugchance="$debugchance"/>
                    </check_all>
                  </check_any>
                </conditions>
                <actions>
                  <debug_text text="'player ship %s %s wait interrupted by %s. undocking.'.[$thisship.knownname, $thisship, event.name]" chance="$debugchance"/>
                  <set_value name="$skipwait"/>
                </actions>
              </interrupt>
            </wait>
            <remove_value name="$currentorders"/>
          </do_if>
          <do_else>
            <debug_text text="'%s %s %s skipped wait.\n $playertoplvlcontainer == $thisship.container: %s\n player.shouldplayertaxiwaitforplayer and $thisship == @player.entity.$PlayerTaxi: %s\n player.shouldplayershipswaitforplayer and (not @player.entity.$PlayerTaxi.isoperational or not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer}): %s'.[$thisship.idcode, $thisship.knownname, $thisship, $playertoplvlcontainer == $thisship.container, player.shouldplayertaxiwaitforplayer and $thisship == @player.entity.$PlayerTaxi, player.shouldplayershipswaitforplayer and (not @player.entity.$PlayerTaxi.isoperational or not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer})]" chance="0"/>
          </do_else>
          <remove_value name="$playertoplvlcontainer"/>
        </do_if>
        <do_else>
          <debug_text text="'%s %s %s skipped wait.\n releasesignal: %s\n ($thisship != player.container): %s\n not $skipwait: %s\n isplayerowned: %s\n not capship: %s\n not $thisship.commander: %s'.[$thisship.idcode, $thisship.knownname, $thisship, @$releasesignal.{1}, ($thisship != player.container), not $skipwait, $thisship.isplayerowned, not $thisship.iscapitalship, not $thisship.commander]" chance="0"/>
        </do_else>

        <do_if value="not $skipwait and $thisship == player.ship">
          <!-- if it's otherwise ok to undock, but player is on board, wait a few seconds to allow the player to leave or stay as they would like. -->
          <debug_text text="'player is on board. waiting 30 seconds.'" chance="$debugchance"/>
          <run_script name="'player.interaction'">
            <param name="Line" value="10801" comment="(Informing player ship will soon undock)The ship will be undocking soon."/>
            <param name="MaxQueueDelay" value="10s"/>
            <param name="caption" value="{1016,6}.[$thisship.knownname, $thisship.idcode]"/>
            <param name="interactive" value="false"/>
            <param name="debugchance" value="$debugchance"/>
          </run_script>
          <wait exact="30s">
            <interrupt>
              <conditions>
                <check_any>
                  <event_object_signalled object="$thisship" param="@$releasesignal.{1}" check="false"/>
                  <check_all>
                    <event_object_changed_room object="player.entity"/>
                    <check_value value="event.param2.container == $thisship"/>
                    <check_value value="event.param.container != $thisship"/>
                    <check_value value="not $skipwait"/>
                  </check_all>
                </check_any>
              </conditions>
              <actions>
                <do_if value="event.name == 'event_object_changed_room'">
                  <resume label="start"/>
                </do_if>
              </actions>
            </interrupt>
          </wait>
        </do_if>
      </do_if>

      <debug_text text="'undock start ' + $thisship.knownname + ' (%1) in %2'.[$thisship, this.zone.knownname]" chance="$debugchance"/>
      <do_if value="this.attention ge attention.visible and not $thisship.isclass.ship_xs">
        <signal_objects object="player.entity" param="'npc_management'" param2="table[$Usecase = 'undocking', $Priority = 50, $Objects = table[$UndockingObject = $thisship]]" />
      </do_if>

      <!-- check if we are currently docked -->
      <do_if value="$thisship.dock">
        <do_if value="this.zone.isclass.highway">
          <debug_text text="'undocking. container is in a highway.'" chance="$debugchance"/>
        </do_if>
        <debug_text text="$thisship.knownname + ' is docked, so undock'" chance="$debugchance" />

        <disable_collisions_between object="$thisship" target="$thisship.container"/>

        <set_command_action commandaction="commandaction.undocking" />

        <do_if value="not this.assignedcontrolled and (this != player.computer)" comment="this is sometimes Betty undocking">
          <debug_text text="'this trying to undock this ship but this.assignedcontrolled is null.\n this: %s %s %s. this.ship.pilot: %s %s. this ship: %s %s %s'.[this.class, this.knownname, this, @this.ship.pilot.knownname, this.ship.pilot, this.ship.class, this.ship.knownname, this.ship]"/>
        </do_if>

        <do_if value="$thisship.iscapitalship">
          <do_if value="$thisship.dock.isbuildingallowed">
            <set_value name="$docktype" exact="'build'" comment="drydock cage. undock forward."/>
          </do_if>
          <do_elseif value="$thisship.dock.container.isclass.station">
            <set_value name="$docktype" exact="'trade'" comment="pier. undock backward."/>
          </do_elseif>

          <detach_from_masstraffic object="$thisship" wait="true" >
            <interrupt_after_time time="5min" />
          </detach_from_masstraffic>
        </do_if>

        <do_if value="@$queuedresult">
          <!-- remove existing undocking requests if we have already requested and were queued. -->
          <remove_undocking_request ship="$thisship"/>
        </do_if>
        <!--$thisship.dock at this point could be the internal storage dockingbay. Avoid using it for movement actions-->
        <set_value name="$undockcontainer" exact="$thisship.dock.container"/>
        <request_undocking ship="$thisship" queuedresult="$queuedresult" grantedresult="$grantedresult" highpriority="$uselaunchtubes"/>
        <set_value name="$time_startdocking" exact="player.age"/>
        <do_if value="$grantedresult">
          <debug_text text="'allowed to undock immediately'" chance="$debugchance"/>
          <do_if value="$thisship.dock.isstorage">
            <debug_text text="'%1 (%2) was allowed to immediately undock from internal storage. \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id]" filter="error" chance="$debugchance"/>
          </do_if>
          <resume label="undock" />
        </do_if>
      </do_if>

      <label name="wait" />

      <do_if value="$time_startdocking?">
        <do_if value="$queuedresult">
          <debug_text text="'waiting for free dock'" chance="$debugchance" />
          <!-- we WILL be allowed to undock and, if in internal storage, we cannot do anything unless given a free dock anyway. -->
          <wait exact="if $thisship.dock.container.isclass.ship then 30s else 10min">
            <interrupt>
              <conditions>
                <event_object_undocking_cleared object="$thisship" />
              </conditions>
            </interrupt>
          </wait>
          <do_if value="not $thisship.assigneddock">
            <do_if value="(player.age - $time_startdocking) ge 5min">
              <debug_text text="'after waiting %6min in queue, %1 does not have an assigned dock. \n attention: %2 \n undocking from: %3 \n present dock: %4 \n assigned dock: %5\n => restart'.[$thisship.debugname, $thisship.attention, @$thisship.container.debugname, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id, (player.age - $time_startdocking)/1min]" filter="error"/>
              <do_if value="$uselaunchtubes">
                <set_value name="$uselaunchtubes" exact="false"/>
                <debug_text text="'flipped uselaunchtubes to false for %s currently docked at %s'.[$thisship.debugname, $thisship.container.debugname]" chance="$debugchance"/>
              </do_if>
              <do_elseif value="$thisship.dock and not $thisship.dock.islaunchtube">
                <do_if value="not $thisship.iscapitalship">
                  <find_dockingbay name="$docks" object="$thisship.container" checkoperational="1" multiple="1">
                    <match_dock size="$thisship.docksize" storage="false" free="true" />
                  </find_dockingbay>
                  <do_for_each name="$dock" in="$docks">
                    <do_if value="$dock.islaunchtube">
                      <set_value name="$uselaunchtubes" exact="true"/>
                      <debug_text text="'flipped uselaunchtubes to true for %s currently docked at %s'.[$thisship.debugname, $thisship.container.debugname]" chance="$debugchance"/>
                      <break/>
                    </do_if>
                  </do_for_each>
                </do_if>
                <remove_value name="$docks"/>
              </do_elseif>
              <resume label="start"/>
            </do_if>
            <resume label="wait"/>
          </do_if>
          <do_elseif value="@$thisship.assigneddock.isstorage">
            <do_if value="(player.age - $time_startdocking) ge 5min">
              <debug_text text="'after waiting %6min in queue, %1 was assigned an internal storage dock. \n attention: %2 \n undocking from: %3 \n present dock: %4 \n assigned dock: %5\n => restart'.[$thisship.debugname, $thisship.attention, $thisship.container.debugname, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id, (player.age - $time_startdocking)/1min]" filter="error"/>
              <resume label="start"/>
            </do_if>
            <resume label="wait"/>
          </do_elseif>
        </do_if>
        <do_else>
          <assert value="not $undockcontainer? or not $undockcontainer.isoperational" text="'request_undocking did not return a queued or granted result, which should only be possible if the ship is not docked! [Matthias]\nship: %s, dock: %s, assigned dock: %s\ncontainer: %s, undockcontainer: %s'.[$thisship.debugname, @$thisship.dock, @$thisship.assigneddock, @$thisship.dock.container.debugname, @$undockcontainer.debugname]" />
          <!--if this is just a missed case the script will simply retry undocking periodically and eventually continue-->
        </do_else>
      </do_if>
      <remove_value name="$undockcontainer"/>

      <label name="undock" />

      <do_if value="$thisship.dock">
        <!--set the undocking state so that the game known not to put this ship into storage to make way for another ship that wants to dock or undock-->
        <set_ship_undocking ship="$thisship" />
        <!--wait a random amount of time to break up the synchronization of many ships undocking simultaneously-->
        <do_if value="$uselaunchtubes">
          <wait min="1333ms" max="1.8s" sinceversion="6" />
        </do_if>
        <do_else>
          <wait min="1ms" max="0.5s" />
        </do_else>
        <do_if value="not $thisship.dock">
          <!-- if we're no longer attached to a dock, don't bother doing docking requets and finish the script-->
          <debug_text text="'%s undocked from %s before performing &lt;undock /&gt; action'.[$thisship.debugname, @$undockcontainer.debugname]" filter="error" chance="if @$undockcontainer.isoperational then 100 else 0"/>
          <resume label="undock"/>
        </do_if>
        <!--perform another undock request to catch state changes like the container having entered a highway since having been granted undocking clearance-->
        <request_undocking ship="$thisship" queuedresult="$queuedresult" grantedresult="$grantedresult" highpriority="$uselaunchtubes"/>
        <do_if value="not $grantedresult">
          <debug_text text="'not granted docking clearance. waiting.'" chance="$debugchance"/>
          <clear_ship_undocking ship="$thisship" />
          <resume label="wait" />
        </do_if>

        <debug_text text="'%1 (%2) waited for %3 seconds to undock'.[$thisship.knownname, $thisship, player.age - $time_startdocking]" chance="$debugchance"/>
        <remove_value name="$time_startdocking"/>
        <do_if value="not @$olddock">
          <set_value name="$olddock" exact="$thisship.dock" />
          <do_if value="$olddock.walkablemodule.isoperational">
            <set_value name="$dockmodule" exact="$olddock.walkablemodule" />
          </do_if>
        </do_if>
        <set_value name="$isship" exact="$olddock.container.isclass.ship" />

        <do_if value="$olddock.isstorage and (not $thisship.assigneddock or $thisship.assigneddock.isstorage)">
          <debug_text text="player.age + ': %1 (%2) tried to undock directly from internal storage. waiting. \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id]" filter="error" chance="$debugchance"/>
          <wait>
            <interrupt>
              <conditions>
                <event_object_dock_assigned object="$thisship"/>
                <check_value value="$thisship.assigneddock and not $thisship.assigneddock.isstorage"/>
                <!--<check_value value="not $thisship.dock.isstorage or ($thisship.assigneddock and not $thisship.assigneddock.isstorage)"/>-->
              </conditions>
              <actions>
                <debug_text text="player.age + ': Recovery: %1 (%2) was assigned a non-storage docking bay. undocking. \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6 \n'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id]" chance="$debugchance"/>
              </actions>
            </interrupt>
          </wait>
          <set_value name="$olddock" exact="$thisship.assigneddock"/>
          <do_if value="not $thisship.assigneddock">
            <debug_text text="'After recovery, %1 (%2) was not assigned a dock. \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6 \n'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id]" filter="error"/>
          </do_if>
          <do_elseif value="$thisship.dock.isstorage">
            <debug_text text="'After recovery, %1 (%2) is STILL in storage. wait longer? \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6 \n'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id]" filter="error"/>
          </do_elseif>
          <resume label="undock"/>
        </do_if>

        <!-- things like mining drones do not have orders. -->
        <do_if value="$thisship.order and ($thisship.order.state != orderstate.critical)">
          <!-- if the player is controlling this ship, they could decide to undock bypassing the need for any undock order, suppress error output as this is a valid scenario which is handled by md\Orders.xml, cue DockAndWait_PlayerUndocked -->
          <do_if value="$thisship != player.controlled">
            <do_if value="$thisship.order.id == 'Undock'">
              <set_order_state order="$thisship.order" state="orderstate.critical"/>
            </do_if>
          </do_if>
        </do_if>

        <do_if value="$uselaunchtubes and (not $thisship.dock or not $thisship.dock.islaunchtube)">
          <set_value name="$uselaunchtubes" exact="false"/>
        </do_if>

        <do_if value="$uselaunchtubes">
          <disable_collision_response object="$thisship"/>
          <disable_collisions_between object="$thisship" target="$olddock.container"/>
        </do_if>
        <undock ship="$thisship" />

        <do_if value="$thisship.isunit and $olddock.container.defencenpc.$launchedunitcount?">
          <set_value name="$olddock.container.defencenpc.$launchedunitcount.{1}" exact="$olddock.container.defencenpc.$launchedunitcount.{1} + 1"/>
          <debug_text text="'incrementing unit count. present count: ' + $olddock.container.defencenpc.$launchedunitcount.{1}" chance="$debugchance"/>
          <do_if value="$olddock.container.defencenpc.$launchedunitcount.{1} ge $olddock.container.defencenpc.$launchedunitcount.{2}">
            <debug_text text="'all units out. cleaning up counter and sending release signal.'" chance="$debugchance"/>
            <remove_value name="$olddock.container.defencenpc.$launchedunitcount"/>
            <signal_objects object="$olddock.container" param="'units_go'"/>
          </do_if>
        </do_if>

        <wait min="1s" max="3s" />
        <do_if value="$uselaunchtubes">
          <enable_collisions_between object="$thisship" target="$olddock.container"/>
          <enable_collision_response object="$thisship"/>
        </do_if>

        <do_if value="@$thisship.dock">
          <set_value name="$olddock" exact="$thisship.dock" />
          <debug_text text="player.age + ': undocking is delayed, wait for event'" chance="$debugchance"/>
          <wait min="1min" max="2min">
            <interrupt>
              <conditions>
                <check_any>
                  <event_object_undocked object="$thisship" />
                  <event_object_destroyed object="$olddock" />
                </check_any>
              </conditions>
            </interrupt>
          </wait>
          <do_if value="@$thisship.dock or not @$olddock.exists">
            <resume label="undock"/>
          </do_if>
        </do_if>
        <debug_text text="player.age + ': ship has undocked'" chance="$debugchance"/>

        <!-- consider enforcing this for general use. at the moment, only urgent for drones since the player can tell undocking drones to immediately dock while undocking and, if the ship is moving, the drones fly over the cockpit after undocking. -->
        <do_if value="$thisship.isunit">
          <debug_text text="'not docked: %s, container is ship: %s, not capship: %s, not in highway: %s'.[not $thisship.dock, $olddock.container.isclass.ship, not $thisship.iscapitalship, not this.zone.isclass.highway]" chance="$debugchance"/>
          <do_if value="not $thisship.dock and $olddock.container.isclass.ship and not $thisship.iscapitalship and not this.zone.isclass.highway">
            <debug_text text="'%s %s %s just undocked. keeping station with %s %s %s'.[@$thisship.idcode, @$thisship.knownname, $thisship, @$olddock.container.idcode, @$olddock.container.knownname, $olddock.container]" chance="$debugchance"/>
            <!-- very short movement to stabilize the drone until whiskers can go up. -->
            <move_to destination="$olddock.container" object="$thisship" relativemovement="true" sinceversion="4">
              <position z="1m" object="$thisship"/>
              <interrupt_after_time time="1s"/>
            </move_to>
          </do_if>
        </do_if>

        <do_if value="$thisship.isdeployable or $thisship.isclass.ship_xs">
          <!-- NB: deployables and XS ships should be pushed clear of their old dock upon launch. -->
          <set_value name="$alreadyclear"/>
        </do_if>

        <!-- For the player do the same move_docking, but interrupt it earlier. Movement to 'launchpos' -->
        <do_if value="not $alreadyclear? and $olddock.isoperational and not this.zone.isclass.highway">
          <!-- TODO: problem: if the ship we are docking with is docking or undocking, setting their flight control model to spline will break things.
                ideally, we would set_avoid_collisions smallobjects="false" on the ship we're docking with.
                problem is if that ship is itself docking or undocking and has non-normal collision settings. -->
          <!-- workaroundy - forcing fcm here to spline because spline does not try to maintain separation with small ships found via gravidar. -->
          <!--<do_if value="$olddock.container.isclass.ship_m">
            <set_flight_control_model object="$olddock.container" flightcontrolmodel="flightcontrolmodel.spline"/>
          </do_if>-->

          <do_if value="$thisship != player.occupiedship or $uselaunchtubes">
            <do_if value="$olddock.islaunchtube">
              <debug_text text="player.age + ': launching from a launchtube, skipping move_undocking'" chance="$debugchance" />
              <move_undocking object="$thisship" dock="$olddock" chance="0"/>
              <set_value name="$alreadyclear" comment="will skip all further undocking movement"/>
            </do_if>
            <do_else>
              <debug_text text="player.age + ': starting move_undocking'" chance="$debugchance" />
              <set_value name="$forcesteering" exact="$isship" />
              <do_if value="@$dockmodule.haswaypointpath.{$olddock.grouptag}.[tag.dockpath, tag.start]">
                <set_value name="$flightbehaviour" exact="flightbehaviour.undockpath" />
                <set_value name="$forcesteering" exact="true" />
              </do_if>
              <do_else>
                <set_value name="$flightbehaviour" exact="flightbehaviour.undock" />
              </do_else>
              <stop_moving object="$thisship"/>
              <move_undocking object="$thisship" dock="$olddock" finishonapproach="false" forceposition="false" forcerotation="false" forcesteering="$forcesteering" flightbehaviour="$flightbehaviour" commandaction="false">
                <interrupt>
                  <conditions>
                    <check_any>
                      <event_object_destroyed object="$olddock.container"/>
                      <event_object_changed_cluster object="$olddock.container"/>
                      <check_all>
                        <event_object_changed_zone object="$olddock.container"/>
                        <check_any>
                          <check_value value="$olddock.zone.isclass.highway"/>
                          <check_value value="$olddock.zone != this.zone and this.bboxdistanceto.{$olddock.container} gt 3000m"/>
                        </check_any>
                      </check_all>
                    </check_any>
                  </conditions>
                  <actions>
                    <set_value name="$alreadyclear"/>
                  </actions>
                </interrupt>
              </move_undocking>

              <!-- steer clear behaviour-->
              <!-- (expected to only run in high attention and if $olddock.container is a ship with undockpaths) -->
              <do_if value="this.attention ge attention.visible and $isship and $flightbehaviour == flightbehaviour.undockpath and $olddock.isoperational and not this.zone.isclass.highway">
                <debug_text text="'%1 (%2) will first steer clear of %3'.[$thisship.knownname, $thisship.idcode, $olddock.container.macro.id]" chance="$debugchance"/>
                <move_to object="$thisship" relativemovement='true' destination="$olddock.container" finishonapproach="false" forceposition="false" forcerotation="false" forcesteering="true" flightbehaviour="flightbehaviour.steerclear" sinceversion="7">
                  <interrupt>
                    <conditions>
                      <check_any>
                        <event_object_destroyed object="$olddock.container"/>
                        <event_object_changed_cluster object="$olddock.container"/>
                        <check_all>
                          <event_object_changed_zone object="$olddock.container"/>
                          <check_any>
                            <check_value value="$olddock.zone.isclass.highway"/>
                            <check_value value="$olddock.zone != this.zone and this.bboxdistanceto.{$olddock.container} gt 3000m"/>
                          </check_any>
                        </check_all>
                      </check_any>
                    </conditions>
                    <actions>
                      <set_value name="$alreadyclear"/>
                    </actions>
                  </interrupt>
                  <interrupt_after_time time="20s"/>
                  <!-- to bulletproof that the relative movement suspends -->
                </move_to>
                <debug_text text="'%1 (%2) finished steering clear of %3'.[$thisship.knownname, $thisship.idcode, $olddock.container.macro.id]" chance="$debugchance"/>
                <set_to_default_flight_control_model object="$thisship" clearforcedsteering="true"/>
                <set_value name="$alreadyclear"/>
              </do_if>
            </do_else>
          </do_if>
        </do_if>

        <do_if value="@$thisship.dock">
          <debug_text text="'%1 (%2) was moved to a dock AFTER undocking. external? %7 storage? %8 \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $olddock.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id, $thisship.dock.external, $thisship.dock.isstorage]" filter="error" chance="$debugchance"/>
          <resume label="start"/>
        </do_if>

        <debug_text text="player.age + ': undock!'" chance="$debugchance" />
        <do_if value="$olddock.exists and $olddock.container.isoperational">
          <remove_docking_request ship="$thisship" container="$olddock.container"/>
          <enable_collisions_between object="$thisship" target="$olddock.container"/>
          <do_if value="$olddock.container.isclass.ship_m">
            <set_to_default_flight_control_model object="$olddock.container"/>
          </do_if>
        </do_if>

        <do_if value="$thisship == player.occupiedship">
          <debug_text text="player.age + ': stopping auto pilot!'" chance="$debugchance" />
          <stop_player_autopilot />
          <!-- don't do anything else, the player takes over from now on -->
          <resume label="cleanup"/>
        </do_if>
        <do_elseif value="not $alreadyclear?">
          <!-- move to exit paths/positions, unless we're already clear of the object -->
          <do_if value="@$dockmodule.isoperational and not this.zone.isclass.highway and $olddock.container.exists and $olddock.container.bboxdistanceto.{$thisship} lt $thisship.size">
            <!-- Check if there is a valid dock area exit path, prefer it over an exit position -->
            <do_if value="$dockmodule.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start] or (not $olddock.grouptag and @$dockmodule.haswaypointpath.[tag.exitpath, tag.start])">
              <debug_text text="'moving along exit path'" chance="$debugchance" />
              <move_waypoints object="$thisship" destination="$dockmodule" tags="tag.exitpath" starttags="tag.start" finishonapproach="true" relativemovement="$isship" flightbehaviour="flightbehaviour.undock" forcesteering="$isship" commandaction="false" abortpath="false">
                <interrupt_after_time time="0s"/>
              </move_waypoints>
            </do_if>
            <!-- Now check if there is a valid exit position -->
            <do_elseif value="$dockmodule.hasexitpos">
              <debug_text text="'moving to exit position'" chance="$debugchance" />
              <move_to object="$thisship" destination="$dockmodule" finishonapproach="true" relativemovement="$isship" flightbehaviour="flightbehaviour.undock" forcesteering="$isship" forceposition="false" forcerotation="false" commandaction="false" abortpath="false">
                <position value="$dockmodule.exitpos" />
                <interrupt_after_time time="0s"/>
              </move_to>
            </do_elseif>

            <!-- Check if there is a valid object exit path -->
            <do_if value="@$olddock.container.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start] or (not $olddock.grouptag and @$olddock.container.haswaypointpath.[tag.exitpath, tag.start])">
              <debug_text text="'moving along exit path'" chance="$debugchance" />
              <move_waypoints object="$thisship" destination="$olddock.container" tags="tag.exitpath" starttags="tag.start" finishonapproach="true" relativemovement="$isship" flightbehaviour="flightbehaviour.undock" forcesteering="true" commandaction="false" abortpath="false">
                <interrupt>
                  <conditions>
                    <check_any>
                      <event_object_destroyed object="$olddock.container"/>
                      <event_object_changed_cluster object="$olddock.container"/>
                      <check_all>
                        <event_object_changed_zone object="$olddock.container"/>
                        <check_any>
                          <check_value value="$olddock.zone.isclass.highway"/>
                          <check_value value="$olddock.zone != this.zone and this.distanceto.{$olddock.container} gt this.ship.size"/>
                        </check_any>
                      </check_all>
                    </check_any>
                  </conditions>
                  <actions>
                    <set_value name="$alreadyclear"/>
                  </actions>
                </interrupt>
              </move_waypoints>
              <set_to_default_flight_control_model object="$thisship" clearforcedsteering="true"/>
            </do_if>
            <!-- Dock area does not define exit path or position, we can only assume it's trivial to fly out of the dock -->
          </do_if>
        </do_elseif>

        <do_if value="this.zone.isclass.highway">
          <set_value name="$zone" exact="this.zone.destination"/>
        </do_if>
        <do_else>
          <set_value name="$zone" exact="this.zone"/>
        </do_else>

        <!-- clear the dockingbay/dockmodule -->
        <do_if value="not $alreadyclear?">
          <do_if value="$thisship.iscapitalship">
            <create_position name="$olddockrelpos" space="$thisship" object="$olddock"/>
          </do_if>

          <do_if value="@$reservedspace.$zone">
            <cancel_space_reservation component="$thisship" zone="$reservedspace.$zone" index="$reservedspace.$index"/>
          </do_if>
          <do_else>
            <set_value name="$reservedspace" exact="table[ $duration = param.spacereservation.maxduration ]"/>
          </do_else>

          <do_if value="$thisship.iscapitalship and $docktype?">
            <create_position name="$olddockzonepos" space="$zone" object="$olddock"/>
            <set_value name="$locquadrant" exact="quadrant.back"/>
            <do_if value="$docktype == 'build'">
              <do_if value="$olddockrelpos.z lt 0">
                <set_value name="$moveforward"/>
                <set_value name="$locquadrant" exact="quadrant.front"/>
              </do_if>
            </do_if>
            <!-- at this point, already at launchpos -->
            <!-- this case assumes that we are undocking from a station which cannot be in a highway so that this.zone is $zone. if not, value="$thisship.position" would have to be looked at. -->
            <debug_text text="'WARNING: safepos assumes that we are not in a highway, but we are. re-evaluate usage of $thisship.position.\n current zone: %s %s\n $zone: %s %s'.[@this.zone.knownname, this.zone, @$zone.knownname, $zone]" chance="(this.zone != $zone) * 100"/>
            <do_if value="$moveforward?">
              <get_safe_pos result="$safepos" zone="$zone" radius="$thisship.safesize / 2.0" value="$thisship.position" directionobject="$thisship" direction="$locquadrant" allowyaxis="false">
                <spacereservation component="$thisship" duration="$reservedspace.$duration" index="$reservedspace.$index" safezone="$reservedspace.$zone">
                  <orientation orientation="look_away" refposition="$olddockzonepos"/>
                </spacereservation>
              </get_safe_pos>
            </do_if>
            <do_else>
              <get_safe_pos result="$safepos" zone="$zone" radius="$thisship.safesize / 2.0" value="$thisship.position" directionobject="$thisship" direction="$locquadrant" allowyaxis="false">
                <spacereservation component="$thisship" duration="$reservedspace.$duration" index="$reservedspace.$index" safezone="$reservedspace.$zone">
                  <orientation orientation="look_at" refposition="$olddockzonepos"/>
                </spacereservation>
              </get_safe_pos>
            </do_else>
            <remove_value name="$olddockzonepos"/>
            <remove_value name="$locquadrant"/>
          </do_if>
          <do_elseif value="not $thisship.iscapitalship and (@$flightbehaviour == flightbehaviour.undockpath)">
            <debug_text text="'exited via undockpath. we should already be in the clear but checking to be sure.'" chance="$debugchance"/>
            <get_safe_pos result="$safepos" zone="$zone" object="$thisship" radius="$thisship.safesize / 2.0" min="$thisship.safesize / 2.0" max="$thisship.safesize" ignored="$thisship" allowyaxis="true" directionobject="$thisship" direction="quadrant.front" angle="45deg">
              <spacereservation component="$thisship" duration="$reservedspace.$duration" index="$reservedspace.$index" safezone="$reservedspace.$zone">
                <orientation orientation="look_away" refobject="$thisship"/>
              </spacereservation>
            </get_safe_pos>
          </do_elseif>
          <do_else>
            <do_if value="$olddock.exists and $olddock.container.exists and $olddock.container.zone and $olddock.container.zone == $zone">
              <get_safe_pos result="$safepos" zone="$zone" object="$olddock" radius="$thisship.safesize / 2.0" min="$olddock.safesize / 2.0 + $thisship.safesize / 2.0" max="$olddock.safesize + $thisship.safesize" allowyaxis="true" directionobject="$thisship" direction="quadrant.front" angle="45deg">
                <spacereservation component="$thisship" duration="$reservedspace.$duration" index="$reservedspace.$index" safezone="$reservedspace.$zone">
                  <orientation orientation="look_away" refobject="$thisship"/>
                </spacereservation>
              </get_safe_pos>
              <!--<get_safe_pos result="$safepos" zone="$zone" object="$olddock.container" radius="$thisship.size / 2.0" min="$olddock.container.size / 2.0 + $thisship.size / 2.0" max="$olddock.container.size + $thisship.size" allowyaxis="true"/>-->
            </do_if>
            <do_elseif value="this.zone == $zone">
              <get_safe_pos result="$safepos" zone="$zone" object="$thisship" radius="$thisship.safesize / 2.0" min="$thisship.safesize / 2.0" max="$thisship.safesize" allowyaxis="true" directionobject="$thisship" direction="quadrant.front" angle="45deg">
                <spacereservation component="$thisship" duration="$reservedspace.$duration" index="$reservedspace.$index" safezone="$reservedspace.$zone">
                  <orientation orientation="look_away" refobject="$thisship"/>
                </spacereservation>
              </get_safe_pos>
            </do_elseif>
            <do_else>
              <get_safe_pos result="$safepos" zone="$zone" radius="$thisship.safesize / 2.0" min="$thisship.safesize / 2.0" max="$thisship.safesize" allowyaxis="true">
                <spacereservation component="$thisship" duration="$reservedspace.$duration" index="$reservedspace.$index" safezone="$reservedspace.$zone">
                  <orientation orientation="look_away" refobject="$thisship"/>
                </spacereservation>
              </get_safe_pos>
            </do_else>
          </do_else>
          <debug_text text="'distance to clear area: %s. this ship size: %s. already clear? %s'.[$thisship.distanceto.{$safepos}, $thisship.size, $thisship.distanceto.{$safepos} le $thisship.size/2.0]" chance="$debugchance"/>

          <!-- will not necessarily move forward. will go to move_to with reverse false. -->
          <set_value name="$direction" exact="null"/>
          <do_if value="$thisship.iscapitalship and not @$moveforward">
            <create_position name="$locsafepos" space="$thisship" value="$safepos" object="$zone"/>
            <set_value name="$locevalpos" exact="position.[$locsafepos.x - $olddockrelpos.x, $locsafepos.y - $olddockrelpos.y, $locsafepos.z - $olddockrelpos.z]"/>
            <debug_text text="'evaluating direction. all positions relative to me.\nevalpos: %s\nsafepos: %s\ndockpos: %s'.[$locevalpos, $locsafepos, $olddockrelpos]" chance="$debugchance"/>
            <remove_value name="$locsafepos"/>

            <!-- if dock is behind us and we have to move forward to undock, use default. -->
            <do_if value="($locevalpos.z lt $locevalpos.x) and ($locevalpos.z lt -$locevalpos.x)">
              <debug_text text="'we have to move backwards to undock.'" chance="$debugchance"/>
              <!-- dock is ahead of us -->
              <set_value name="$direction" exact="'reverse'"/>
            </do_if>
            <do_else>
              <debug_text text="'we have to move sideways to undock.'" chance="$debugchance"/>
              <!-- dock is to the side -->
              <set_value name="$direction" exact="'side'"/>
            </do_else>
            <remove_value name="$locevalpos"/>
          </do_if>
          <remove_value name="$olddockrelpos"/>

          <!-- If is not near the safe position -->
          <debug_text text="'should do undocking movement. distance to safepos: %sm. direction: %s'.[$thisship.distanceto.{$safepos}, @$direction]" chance="$debugchance"/>
          <do_if value="$thisship.distanceto.{$safepos} gt ($thisship.size / 2.0) and not this.zone.isclass.highway">
            <debug_text text="'passed check 1. dockmodule has waypointpath: %s, container has waypointpath: %s, no dock tag has waypointpath: %s'.[@$dockmodule.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start], @$olddock.container.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start], not $olddock.grouptag and (@$dockmodule.haswaypointpath.[tag.exitpath, tag.start] or @$olddock.container.haswaypointpath.[tag.exitpath, tag.start])]" chance="$debugchance"/>
            <do_if value="($olddock.exists 
                     and (@$dockmodule.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start] 
                       or @$olddock.container.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start] 
                       or (not $olddock.grouptag 
                         and (@$dockmodule.haswaypointpath.[tag.exitpath, tag.start] 
                           or @$olddock.container.haswaypointpath.[tag.exitpath, tag.start])))) 
                   or ($thisship.nextorder and $blockingorders.indexof.{$thisship.nextorder.id}) 
                   or (not $thisship.nextorder and $thisship.defaultorder and $blockingorders.indexof.{$thisship.defaultorder.id})">
              <set_value name="$locundockstarttime" exact="player.age"/>
              <do_if value="$direction == 'side'">
                <set_value name="$rot" exact="$thisship.rotation"/>
                <debug_text text="'big ship undocking from a pier. strafing to launchpos.'" chance="$debugchance"/>
                <move_strafe object="$thisship" destination="$zone" forcerotation="true" abortpath="false">
                  <position value="$safepos"/>
                  <rotation value="$rot"/>
                  <interrupt>
                    <conditions>
                      <check_any>
                        <!-- $olddock or $olddock.container may already be invalid -->
                        <event_object_destroyed object="@$olddock.container" check="false"/>
                        <event_object_changed_cluster object="@$olddock.container" check="false"/>
                        <check_all>
                          <event_object_changed_zone object="@$olddock.container" check="false"/>
                          <check_any>
                            <check_value value="$olddock.zone.isclass.highway"/>
                            <check_value value="$olddock.zone != this.zone and this.distanceto.{$olddock.container} gt $thisship.size"/>
                          </check_any>
                        </check_all>
                      </check_any>
                    </conditions>
                  </interrupt>
                </move_strafe>
              </do_if>
              <do_else>
                <debug_text text="'moving out of dock area.'" chance="$debugchance"/>
                <do_if value="$direction == 'reverse'">
                  <!-- a ship on spline trying to avoid collisions with a station uses octree navigation which we do not want in this case because we simply want to move backwards and the way is unobstructed due to exclusion zones. -->
                  <set_avoid_collisions object="$thisship" bigobjects="false" smallobjects="false"/>
                </do_if>

                <!-- special block to apply patched variables only if we were running the below move_to -->
                <do_all chance="0">
                  <move_to object="$thisship" destination="$zone" comment="deprecated as of version 8">
                    <interrupt_after_time time="0s"/>
                  </move_to>
                  <stop_moving object="$thisship" immediate="false"/>
                  <set_avoid_collisions object="$thisship" bigobjects="false" smallobjects="false"/>
                  <do_if value="$olddock.container.bboxdistanceto.{$thisship} gt $thisship.size">
                    <debug_text filter="savegame" text="$thisship.debugname + ' is already clear, ending final undock movement'"/>
                    <!-- we're already far enough away, change the $safepos to where we currently are so that the move_to can end right away -->
                    <set_value name="$alreadyclear"/>
                    <set_value name="$safepos" exact="$thisship.position"/>
                  </do_if>
                </do_all>

                <!-- we want to be flying relative to $olddock.container for this final movement -->
                <set_value name="$destination" exact="$zone"/>
                <do_if value="$destination.isclass.zone and @$olddock.container.exists">
                  <set_value name="$destination" exact="$olddock.container"/>
                  <!-- convert safepos from zone space to destination space -->
                  <create_position name="$safepos" space="$destination" object="$zone" value="$safepos"/>
                </do_if>
                <move_to object="$thisship" destination="$destination" reverse="(@$direction == 'reverse')" forceposition="false" forcerotation="false" abortpath="false" relativemovement="$destination.isclass.ship" sinceversion="8">
                  <position value="$safepos" />
                  <interrupt>
                    <conditions>
                      <check_any>
                        <!-- $olddock or $olddock.container may already be invalid -->
                        <event_object_destroyed object="@$olddock.container" check="false"/>
                        <event_object_changed_cluster object="@$olddock.container" check="false"/>
                        <check_all>
                          <event_object_changed_zone object="@$olddock.container" check="false"/>
                          <check_any>
                            <check_value value="$olddock.zone.isclass.highway"/>
                            <check_value value="$olddock.zone != this.zone and this.distanceto.{$olddock.container} gt $thisship.size"/>
                          </check_any>
                        </check_all>
                      </check_any>
                    </conditions>
                  </interrupt>
                  <interrupt_after_time time="30s" comment="fallback to make sure ships cannot get stuck here if they fail to reach the position"/>
                </move_to>
                <reset_avoid_collisions object="$thisship"/>
              </do_else>
              <debug_text text="'undock movement done after %ss'.[player.age - $locundockstarttime]" chance="$debugchance"/>
              <remove_value name="$locundockstarttime"/>
            </do_if>
            <do_else>
              <move_to object="$thisship" destination="$zone" forceposition="false" forcerotation="false" abortpath="false">
                <position value="$safepos" />
                <interrupt_after_time time="0s" />
              </move_to>
            </do_else>
          </do_if>
        </do_if>
      </do_if>
      <do_elseif value="$thisship.assigneddock">
        <!--Ship may have been interrupted from docking and so has a docking connection but is not docked-->
        <remove_docking_request ship="$thisship" container="$thisship.assigneddock.container" immediate="true" />
      </do_elseif>

      <set_to_default_flight_control_model object="$thisship"/>

      <label name="cleanup"/>

      <do_if value="@$reservedspace.$zone">
        <cancel_space_reservation component="$thisship" zone="$reservedspace.$zone" index="$reservedspace.$index"/>
      </do_if>

    </actions>
  </attention>
  <on_abort>
    <debug_text text="'object %1 running move.undock.on_abort'.[$thisship]" chance="$debugchance" />
    <do_if value="$thisship.isoperational">
      <set_to_default_flight_control_model object="$thisship"/>
      <do_if value="@$reservedspace.$zone">
        <cancel_space_reservation component="$thisship" zone="$reservedspace.$zone" index="$reservedspace.$index"/>
      </do_if>
    </do_if>
    <do_if value="$thisship.assigneddock or @$queuedresult">
      <remove_undocking_request ship="$thisship"/>
    </do_if>
    <do_if value="@$olddock.exists and $olddock.container.isoperational">
      <remove_docking_request ship="$thisship" container="$olddock.container"/>
      <enable_collisions_between object="$thisship" target="$olddock.container"/>
      <do_if value="$olddock.container.isclass.ship_m">
        <set_to_default_flight_control_model object="$olddock.container"/>
      </do_if>
    </do_if>
    <do_if value="$thisship.dock">
      <do_if value="$thisship == player.occupiedship">
        <undock ship="$thisship"/>
      </do_if>
      <do_else>
        <clear_ship_undocking ship="$thisship"/>
      </do_else>
    </do_if>
  </on_abort>
</aiscript>
