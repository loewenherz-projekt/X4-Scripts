<?xml version="1.0" encoding="utf-8" ?>
<aiscript name="order.mining.routine" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="25">
  <!--
  This script will try to automatically supply stations and will only work with
  a valid warebasket parameter (defined via jobs). It can do gas and mineral
  mining and works for all ship classes. 
  
  Supports:
   * Range: space class or space string 'zone', 'sector', 'cluster'
   * Buy/Sell with Min/Max gate distances from $range
  
  If there is a valid commander, it will gather resources to supply the commander (homebase)
  
  -->
  <order id="MiningRoutine" name="{1041, 341}" description="{1041, 342}" category="internal" allowinloop="false">
    <params>
      <param name="warebasket" required="true" default="this.ship.warebasket.list" type="list" text="{1041, 10146}" comment="Wares. list of wares that takes precedence over any defined warebasket">
        <input_param name="type" value="'ware'"/>
        <input_param name="cancarry" value="this.ship"/>
        <input_param name="isminable" value="true"/>
        <input_param name="canplayeroverride" value="true"/>
      </param>
      <param name="range" default="if @this.ship.commanderentity.$config_subordinate_range then @this.ship.commanderentity.$config_subordinate_range 
            else (if @this.ship.commander.jobmainsector then this.ship.commander.jobmainsector
              else (if @this.ship.commander.isclass.[class.station, class.buildstorage] then this.ship.commander.sector
                else (if this.ship.jobmainsector then this.ship.jobmainsector
                  else this.sector)))" type="internal" text="{1041, 10005}" comment="Anchor space"/>

      <param name="minbuy" default="0" type="number" advanced="true" text="{1041, 10067}" comment="Min gate distance to gather resources. Gathering range supported if $minsell and $maxsell are provided">
        <input_param name="startvalue" value="0"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="[([@this.ship.commander.tradenpc.skill.management, @this.ship.pilot.skill.piloting].max / 3) - 1, 0].max"/>
        <input_param name="step" value="1"/>
      </param>
      <param name="maxbuy" default="0" type="number" text="{1041, 10056}" comment="Max gate distance to gather resources. Gathering range supported if $minsell and $maxsell are provided">
        <input_param name="startvalue" value="0"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="[@this.ship.commander.tradenpc.skill.management, @this.ship.pilot.skill.piloting].max / 3"/>
        <input_param name="step" value="1"/>
        <patch condition="$resourcescout and this.ship.isjobship" value="5" sinceversion="15"/>
      </param>
      <param name="minsell" default="0" type="number" advanced="true" text="{1041, 10069}" comment="Min gate distance to sell resources. Sell range supported if $minsell and $maxsell are provided">
        <input_param name="startvalue" value="0"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="[([@this.ship.commander.tradenpc.skill.management, @this.ship.pilot.skill.piloting].max / 3) - 1, 0].max"/>
        <input_param name="step" value="1"/>
      </param>
      <param name="maxsell" default="0" type="number" text="{1041, 10058}" comment="Max gate distance to sell resources. Sell range supported if $minsell and $maxsell are provided">
        <input_param name="startvalue" value="0"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="[@this.ship.commander.tradenpc.skill.management, @this.ship.pilot.skill.piloting].max / 3"/>
        <input_param name="step" value="1"/>
      </param>

      <param name="deepspace" default="false" type="bool" text="{1041, 10082}" advanced="true" comment="Operate in deep space. Operate only in deep space. Currently defined as 100 +/- 50km from sector core edge"/>
      <param name="resourcescout" default="false" type="bool" text="{1041, 10109}" advanced="true" comment="Scout for resources. Visibly look for resources before mining"/>
      <param name="duration" default="0s" type="time" infinitevalue="0s" advanced="true" text="{1041, 10034}" comment="Duration. Only accounts for time spent executing this order.">
        <input_param name="startvalue" value="0s"/>
        <input_param name="min" value="0s"/>
        <input_param name="max" value="24h"/>
        <input_param name="step" value="1min"/>
        <patch value="0s" sinceversion="7"/>
      </param>
      <param name="endtime" default="0s" type="internal" comment="Absolute game time in seconds, after which order will end. Overrides duration. For internal use. Do not use with default orders."/>
      <param name="effectiveskill" default="this.ship.combinedskill" type="internal" comment="Effective skill level used for skill checks"/>
      <param name="preferownspace" default="false" type="internal" comment="Only search for resources in spaces owned by our faction. If none are found, a fallback sector will be used.">
        <patch value="false" sinceversion="20"/>
      </param>
      <param name="warebasket_override" default="[]" type="internal" comment="Wares (Manual). Only use this warebasket or a subset thereof.">
        <input_param name="type" value="'ware'"/>
        <input_param name="uitype" value="'list'"/>
        <input_param name="cancarry" value="this.ship"/>
        <input_param name="optionsource" value="'commanderwarebasket'"/>
        <patch value="[]" sinceversion="24"/>
      </param>
      <param name="debugchance" type="bool" default="0" advanced="true" text="{1041, 10086}" comment="Print debug output">
        <input_param name="truevalue" value="100"/>
      </param>
      <param name="debugchance2" type="bool" default="0" advanced="true" text="{1041, 10142}" comment="Verbose debug output">
        <input_param name="truevalue" value="100"/>
      </param>
    </params>
    <requires primarypurpose="purpose.mine"/>
    <icon name="order_miningroutine_manual" condition="this.ship.commander and $warebasket_override.count"/>
  </order>
  <interrupts>
    <handler ref="SectorChangeHandler"/>
    <handler ref="AttackHandler" />
    <handler ref="MissileLockHandler" />
    <handler ref="ScannedHandler" />
    <handler ref="InspectedHandler"/>
    <handler ref="FoundAbandonedHandler"/>
    <handler ref="FoundLockboxHandler"/>
    <handler ref="ResupplyHandler" />
    <handler ref="TargetInvalidHandler"/>
    <handler ref="TideHandler"/>
    <handler comment="handler kept local since it modifies a value local to this script">
      <conditions>
        <event_object_signalled object="this.assignedcontrolled" param="'range_setting_updated'" />
      </conditions>
      <actions>
        <set_value name="$range" exact="if @event.param2 then event.param2 else this.assignedcontrolled.commanderentity.$config_subordinate_range" />
        <debug_text text="'updated operational range for %1(%2) to %3(%4)'.[this.assignedcontrolled.knownname, this.assignedcontrolled, $range.knownname, $range]" chance="$debugchance" />
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_object_changed_sector object="this.assignedcontrolled.commander" check="false"/>
        <check_value value="event.param.exists and ($range != event.param)"/>
        <check_value value="this.assignedcontrolled.assignment != assignment.assist"/>
        <check_value value="not @this.assignedcontrolled.commanderentity.$config_subordinate_range"/>
      </conditions>
      <actions>
        <set_value name="$range" exact="event.param"/>
        <do_if value="@$thisorder.exists">
          <edit_order_param order="$thisorder" param="'range'" value="$range"/>
        </do_if>
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.freemining" />
    <!-- Mining for commander (Must to be Station) -->
    <do_if value="@this.assignedcontrolled.commander.isclass.[class.station, class.buildstorage]">
      <set_value name="$homebase" exact="this.assignedcontrolled.commander" />
    </do_if>
    <do_elseif value="this.assignedcontrolled.assignment == assignment.assist and this.assignedcontrolled.toplevelcommander.isclass.station">
      <set_value name="$homebase" exact="this.assignedcontrolled.toplevelcommander" />
    </do_elseif>

    <set_value name="$time_start" exact="player.age"/>
    <do_if value="(this.assignedcontrolled.order.id == 'MiningRoutine') or (this.assignedcontrolled.order.id == 'MiningRoutine_Basic') or (this.assignedcontrolled.order.id == 'MiningRoutine_Advanced') or (this.assignedcontrolled.order.id == 'MiningRoutine_Expert')">
      <set_value name="$thisorder" exact="this.assignedcontrolled.order"/>
    </do_if>

    <do_if value="this.isplayerowned">
      <set_value name="$maxrange" exact="[@this.assignedcontrolled.commander.tradenpc.skill.management, @this.skill.piloting].max / 3"/>
      <do_if value="$effectiveskill == 100">
        <set_value name="$maxrange" exact="$maxrange * 3"/>
      </do_if>
      <do_if value="$minbuy gt [$maxrange - 1, 0].max">
        <set_value name="$minbuy" exact="[$maxrange - 1, 0].max"/>
        <do_if value="@$thisorder.exists">
          <edit_order_param order="this.assignedcontrolled.order" param="'minbuy'" value="$minbuy"/>
        </do_if>
      </do_if>
      <do_if value="$minsell gt [$maxrange - 1, 0].max">
        <set_value name="$minsell" exact="[$maxrange - 1, 0].max"/>
        <do_if value="@$thisorder.exists">
          <edit_order_param order="this.assignedcontrolled.order" param="'minsell'" value="$minsell"/>
        </do_if>
      </do_if>
      <do_if value="$maxsell gt $maxrange">
        <set_value name="$maxsell" exact="$maxrange"/>
        <do_if value="@$thisorder.exists">
          <edit_order_param order="this.assignedcontrolled.order" param="'maxsell'" value="$maxsell"/>
        </do_if>
      </do_if>

      <do_if value="not @$homebase.isoperational">
        <do_if value="$maxbuy gt $maxrange">
          <set_value name="$maxbuy" exact="$maxrange"/>
          <do_if value="@$thisorder.exists">
            <edit_order_param order="this.assignedcontrolled.order" param="'maxbuy'" value="$maxbuy"/>
          </do_if>
        </do_if>
      </do_if>
      <do_else>
        <!-- station-based miners always harvest at their maximum range. changing maxsell won't do anything since they'll always only offload at their own station. -->
        <do_if value="$maxbuy != $maxrange">
          <set_value name="$maxbuy" exact="$maxrange"/>
          <do_if value="@$thisorder.exists">
            <edit_order_param order="this.assignedcontrolled.order" param="'maxbuy'" value="$maxbuy"/>
          </do_if>
        </do_if>
      </do_else>
      <remove_value name="$maxrange"/>
    </do_if>

    <!-- update effective skill everytime the script starts. -->
    <do_if value="($effectiveskill != 0) and ($effectiveskill != 100)">
      <set_value name="$effectiveskill" exact="this.assignedcontrolled.combinedskill"/>
    </do_if>

    <do_if value="$endtime">
      <set_value name="$duration" exact="$endtime - player.age" comment="can be negative"/>
    </do_if>
  </init>
  <patch sinceversion="2">
    <do_if value="$minbuy == -1">
      <set_value name="$minbuy" exact="0"/>
    </do_if>
    <do_if value="$maxbuy == -1">
      <set_value name="$maxbuy" exact="0"/>
    </do_if>
    <do_if value="$minsell == -1">
      <set_value name="$minsell" exact="0"/>
    </do_if>
    <do_if value="$maxsell == -1">
      <set_value name="$maxsell" exact="0"/>
    </do_if>
    <do_if value="($minbuy gt 0) and ($minbuy ge $maxbuy)">
      <debug_text text="'PATCH: minbuy is greater than maxbuy. cannot find spaces. resetting minbuy to 0.'" filter="savegame"/>
      <set_value name="$minbuy" exact="0"/>
    </do_if>
    <do_if value="($minsell gt 0) and ($minsell ge $maxsell)">
      <debug_text text="'PATCH: minsell is greater than maxsell. cannot find spaces. resetting minsell to 0.'" filter="savegame"/>
      <set_value name="$minsell" exact="0"/>
    </do_if>
  </patch>
  <patch sinceversion="3">
    <do_if value="this.isplayerowned">
      <set_value name="$maxrange" exact="[@this.assignedcontrolled.commander.tradenpc.skill.management, @this.assignedcontrolled.pilot.skill.piloting].max / 3"/>
      <do_if value="$minbuy gt [$maxrange - 1, 0].max">
        <debug_text text="'PATCH: reducing minbuy from %s to %s'.[$minbuy, $maxrange - 1]" filter="savegame"/>
        <edit_order_param order="this.assignedcontrolled.order" param="'minbuy'" value="[$maxrange - 1, 0].max"/>
      </do_if>
      <do_if value="$maxbuy gt $maxrange">
        <debug_text text="'PATCH: reducing maxbuy from %s to %s'.[$maxbuy, $maxrange]" filter="savegame"/>
        <edit_order_param order="this.assignedcontrolled.order" param="'maxbuy'" value="$maxrange"/>
      </do_if>
      <do_if value="$minsell gt [$maxrange - 1, 0].max">
        <debug_text text="'PATCH: reducing minsell from %s to %s'.[$minsell, $maxrange - 1]" filter="savegame"/>
        <edit_order_param order="this.assignedcontrolled.order" param="'minsell'" value="[$maxrange - 1, 0].max"/>
      </do_if>
      <do_if value="$maxsell gt $maxrange">
        <debug_text text="'PATCH: reducing maxsell from %s to %s'.[$maxsell, $maxrange]" filter="savegame"/>
        <edit_order_param order="this.assignedcontrolled.order" param="'maxsell'" value="$maxrange"/>
      </do_if>
      <remove_value name="$maxrange"/>
    </do_if>
  </patch>
  <patch sinceversion="4">
    <do_if value="this.assignedcontrolled.order.id == 'MiningRoutine'">
      <edit_order_param order="this.assignedcontrolled.order" param="'effectiveskill'" value="this.assignedcontrolled.combinedskill"/>
    </do_if>
  </patch>
  <patch sinceversion="7">
    <set_value name="$time_start" exact="player.age"/>
    <set_value name="$duration" exact="0s"/>

    <do_if value="(this.assignedcontrolled.order.id == 'MiningRoutine') or (this.assignedcontrolled.order.id == 'MiningRoutine_Basic') or (this.assignedcontrolled.order.id == 'MiningRoutine_Advanced') or (this.assignedcontrolled.order.id == 'MiningRoutine_Expert')">
      <!-- NB: if this is not the current order, variables will be correctly set when the script starts/restarts. -->
      <set_value name="$thisorder" exact="this.assignedcontrolled.order"/>
    </do_if>
  </patch>
  <patch sinceversion="10">
    <!-- if $gatheringspaces has not yet been defined, $range will be re-evaluated after it is defined. -->
    <do_if value="this.hasrelation.enemy.{$range.owner} and @$gatheringspaces.count and not @this.assignedcontrolled.commander.hascontext.{$range}">
      <do_all exact="$gatheringspaces.count" counter="$i">
        <do_if value="$gatheringspaces.{$i}.exists">
          <do_if value="$gatheringspaces.{$i}.owner == this.owner">
            <set_value name="$locrange" exact="$gatheringspaces.{$i}"/>
            <break/>
          </do_if>
          <do_elseif value="not this.hasrelation.enemy.{$gatheringspaces.{$i}.owner}">
            <set_value name="$locfallback" exact="$gatheringspaces.{$i}"/>
          </do_elseif>
        </do_if>
      </do_all>

      <do_if value="not $locrange? and $locfallback?">
        <set_value name="$locrange" exact="$locfallback"/>
      </do_if>
      <remove_value name="$locfallback"/>

      <do_if value="$locrange?">
        <set_value name="$range" exact="$locrange"/>
        <debug_text text="'PATCH: old anchor space was hostile. changing to %s %s.'.[$range.class, $range.knownname]" filter="savegame"/>
        <do_if value="@this.assignedcontrolled.order.$range.isclass.space">
          <edit_order_param order="this.assignedcontrolled.order" param="'range'" value="$range"/>
          <do_if value="this.assignedcontrolled.defaultorder == this.assignedcontrolled.order">
            <edit_order_param order="this.assignedcontrolled.defaultorder" param="'range'" value="$range"/>
          </do_if>
        </do_if>
      </do_if>
      <remove_value name="$locrange"/>
    </do_if>
  </patch>
  <patch sinceversion="12">
    <do_if value="$evalware?">
      <set_value name="$thissector" exact="this.sector"/>
      <do_if value="not $resourceprobe_table?">
        <set_value name="$resourceprobe_table" exact="table[]"/>
      </do_if>
    </do_if>
  </patch>
  <patch sinceversion="13">
    <set_value name="$probesectors" exact="[]"/>
    <do_if value="@$miningbasket.count and @$gatheringspaces.count">
      <do_for_each name="$locspace" in="$gatheringspaces">
        <find_object name="$_resourceprobe" class="class.resourceprobe" space="$locspace" owner="this.owner"/>
        <append_to_list name="$probesectors" exact="$locspace"/>
        <remove_value name="$_resourceprobe"/>
      </do_for_each>
      <debug_text text="'PATCH: probesectors populated with %s sectors.'.[$probesectors.count]" filter="savegame"/>
    </do_if>
  </patch>
  <patch sinceversion="14">
    <!-- $thissector just convenient since it's created when in the section where $evalware is used then cleaned up after. -->
    <do_if value="@$miningbasket.count and $thissector?">
      <!-- $evalware changed from iterator to $miningbasket.{1} -->
      <set_value name="$evalware" exact="$miningbasket.{1}"/>
      <remove_value name="$found"/>
    </do_if>
  </patch>
  <patch sinceversion="15">
    <do_if value="$resourcescout and this.assignedcontrolled.isjobship">
      <set_value name="$maxbuy" exact="5"/>
      <do_if value="@this.assignedcontrolled.order.id == 'MiningRoutine'">
        <edit_order_param order="this.assignedcontrolled.order" param="'maxbuy'" value="$maxbuy"/>
      </do_if>
    </do_if>
  </patch>
  <patch sinceversion="16">
    <do_if value="@this.assignedcontrolled.commander.jobmainsector and ($range != this.assignedcontrolled.commander.jobmainsector)">
      <set_value name="$range" exact="this.assignedcontrolled.commander.jobmainsector"/>
      <do_if value="@$thisorder.exists and $thisorder.$range? and ($thisorder.$range != $range)">
        <edit_order_param order="$thisorder" param="'range'" value="$range"/>
      </do_if>
    </do_if>
  </patch>
  <patch sinceversion="17">
    <include_interrupt_actions ref="GetBlacklistgroup"/>
  </patch>
  <patch sinceversion="19">
    <!-- patch here rather than in order.assist so we patch only those ships that are affected. -->
    <do_if value="(@this.assignedcontrolled.defaultorder.id == 'Assist') and this.assignedcontrolled.defaultorder.$baseorder.$range and (this.assignedcontrolled.defaultorder.$baseorder.$range != $range)">
      <debug_text text="'PATCH: Resetting anchor from %s %s to %s %s.'.[@$range.knownname, $range, @this.assignedcontrolled.defaultorder.$baseorder.$range.knownname, @this.assignedcontrolled.defaultorder.$baseorder.$range]" filter="savegame"/>
      <set_value name="$range" exact="this.assignedcontrolled.defaultorder.$baseorder.$range"/>
      <clear_order_failure order="this.assignedcontrolled.defaultorder"/>
      <edit_order_param order="this.assignedcontrolled.defaultorder" param="'debugchance'" value="$debugchance"/>
    </do_if>
  </patch>
  <patch sinceversion="20">
    <set_value name="$preferownspace" exact="false"/>
  </patch>
  <patch sinceversion="21">
    <do_if value="$ware? and not $warebasket.indexof.{$ware}">
      <debug_text text="'PATCH: $ware %s not in warebasket. restarting.'.[$ware]" filter="savegame"/>
      <edit_order_param order="this.assignedcontrolled.order" param="'debugchance'" value="$debugchance"/>
    </do_if>
  </patch>
  <patch sinceversion="23">
    <do_if value="$ware? and $baseminamount?">
      <set_value name="$freecargo" exact="this.assignedcontrolled.cargo.{$ware}.free"/>
    </do_if>
    <do_if value="$spacedistancefactor?">
      <remove_value name="$spacedistancefactor"/>
    </do_if>
  </patch>
  <patch sinceversion="24">
    <set_value name="$warebasket_override" exact="[]"/>
  </patch>
  <patch sinceversion="25">
    <do_if value="not $secwares?">
      <set_value name="$secwares" exact="[]"/>
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>
      <do_if value="($minbuy gt 0) and ($minbuy ge $maxbuy)">
        <debug_text text="'minbuy is greater than maxbuy. cannot find spaces. resetting minbuy to 0.'" filter="error"/>
        <set_value name="$minbuy" exact="0"/>
      </do_if>
      <do_if value="($minsell gt 0) and ($minsell ge $maxsell)">
        <debug_text text="'minsell is greater than maxsell. cannot find spaces. resetting minsell to 0.'" filter="error"/>
        <set_value name="$minsell" exact="0"/>
      </do_if>

      <do_if value="this.assignedcontrolled.isonlineobject and not this.isplayerowned">
        <debug_text text="'Venture ship %s %s %s ordered to mine. num wares in basket: %s.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, @$warebasket.count]" chance="$debugchance"/>
        <do_if value="not @$warebasket.count">
          <debug_text text="'no warebasket defined. populating ware basket with cargo in hold. adding %s wares to the warebasket.'.[this.assignedcontrolled.cargo.count]" chance="$debugchance"/>
          <set_value name="$warebasket" exact="this.assignedcontrolled.cargo.list.clone"/>
        </do_if>

        <do_if value="this.assignedcontrolled.cargo.capacity.solid or this.assignedcontrolled.cargo.capacity.universal">
          <set_value name="$canminesolid"/>
        </do_if>
        <do_if value="this.assignedcontrolled.cargo.capacity.liquid or this.assignedcontrolled.cargo.capacity.universal">
          <set_value name="$canmineliquid"/>
        </do_if>

        <set_value name="$isvalidventure" exact="false"/>
        <do_if value="@$warebasket.count and ($canminesolid? or $canmineliquid?)">
          <do_all exact="$warebasket.count" counter="$i">
            <do_if value="this.assignedcontrolled.cargo.{$warebasket.{$i}}.max">
              <do_if value="($canminesolid? and ($warebasket.{$i}.waretransport == waretransport.solid)) or ($canmineliquid? and ($warebasket.{$i}.waretransport == waretransport.liquid))">
                <set_value name="$isvalidventure" exact="true"/>
                <debug_text text="'Venture ship %s %s %s can mine ware %s.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $warebasket.{$i}]" chance="$debugchance"/>
                <break/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        <do_else>
          <debug_text text="'Venture ship %s %s %s either does not have a ware basket or cannot carry mineable wares.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
        </do_else>
        <remove_value name="$canminesolid"/>
        <remove_value name="$canmineliquid"/>

        <do_if value="not $isvalidventure">
          <debug_text text="'Venture ship %s %s %s was ordered to mine but cannot. Getting new orders.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, this.assignedcontrolled.defaultorder.id]" chance="$debugchance"/>
          <cancel_all_orders object="this.assignedcontrolled"/>
          <run_script name="'lib.request.orders'" sinceversion="1">
            <param name="object" value="this.assignedcontrolled"/>
            <param name="debugchance" value="$debugchance"/>
          </run_script>
        </do_if>
      </do_if>

      <include_interrupt_actions ref="GetBlacklistgroup"/>

      <label name="prep"/>

      <do_if value="$forceidle? or (not this.isplayerowned and this.sector and not this.hasrelation.enemy.{this.sector.owner})">
        <set_value name="$idleduration" min="20s" max="70s"/>
      </do_if>
      <remove_value name="$forceidle"/>

      <!-- Idle for a while -->
      <do_if value="$idleduration?">
        <run_script name="'move.idle'" >
          <param name="TimeOut" value="$idleduration"/>
        </run_script>
        <remove_value name="$idleduration"/>
      </do_if>

      <do_if value="$resourcescout or this.assignedcontrolled.iscapitalship">
        <remove_value name="$resupplying"/>
        <do_if value="$resourcescout">
          <do_if value="not this.assignedcontrolled.ammostorage.{deployablecategory.resourceprobe}.count">
            <debug_text text="'%s %s %s starting MiningRoutine as resource scout. trying to get resource probes.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
            <signal_objects object="this.assignedcontrolled" param="'resupply'" param2="[this.assignedcontrolled.ammostorage.{deployablecategory.resourceprobe}.count lt 1, null, deployablecategory.resourceprobe]" param3="$debugchance" comment="param2 = [urgent?, resupplystationID, $override_deployablecategory], param3 = $debugchance"/>
            <set_value name="$resupplying"/>
          </do_if>
        </do_if>
        <do_elseif value="this.assignedcontrolled.waretransport.indexof.{waretransport.solid} and not this.assignedcontrolled.units.{unitcategory.orecollector}.count">
          <debug_text text="'%s %s %s starting MiningRoutine with no ore collectors. trying to get some.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
          <signal_objects object="this.assignedcontrolled" param="'resupply'" param2="[true]" param3="$debugchance" comment="param2 = [urgent?, resupplystationID], param3 = $debugchance"/>
          <set_value name="$resupplying"/>
        </do_elseif>
        <do_elseif value="this.assignedcontrolled.waretransport.indexof.{waretransport.liquid} and not this.assignedcontrolled.units.{unitcategory.gascollector}.count">
          <debug_text text="'%s %s %s starting MiningRoutine with no gas collectors. trying to get some.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
          <signal_objects object="this.assignedcontrolled" param="'resupply'" param2="[true]" param3="$debugchance" comment="param2 = [urgent?, resupplystationID], param3 = $debugchance"/>
          <set_value name="$resupplying"/>
        </do_elseif>

        <do_if value="$resupplying?">
          <remove_value name="$resupplying"/>
          <wait exact="1s" sinceversion="9"/>

          <!-- NB: if we're still here, interrupt.restock couldn't find any places to buy ore collectors. idle and try again later. -->
          <do_if value="$resourcescout">
            <debug_text text="'unable to get resource probes. idling and trying again later.'" chance="$debugchance"/>
          </do_if>
          <do_else>
            <do_if value="@this.assignedcontrolled.order.isrunning">
              <set_order_failed order="this.assignedcontrolled.order" text="{1045,138}" comment="No available mining drones."/>
            </do_if>
            <debug_text text="'unable to get collector drones. idling and trying again later.'" chance="$debugchance"/>
          </do_else>
          <set_value name="$forceidle"/>
          <resume label="prep"/>
        </do_if>
      </do_if>

      <!-- basic checks first -->
      <label name="start" />

      <!-- check cargo capacity -->
      <do_if value="this.assignedcontrolled.cargo.capacity.all" max="0">
        <debug_text text="'%1 has cargo capacity of %2!'.[this.assignedcontrolled.knownname, this.assignedcontrolled.cargo.capacity.all]" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_CARGOSPACE'" />
        <set_value name="$failreason2" exact="'Macro: ' + this.assignedcontrolled.macro.name" />
        <resume label="finish" />
      </do_if>

      <!-- check basket -->
      <do_if value="not $warebasket.count and not @$homebase.isoperational">
        <do_if value="this.assignedcontrolled.job and this.assignedcontrolled.warebasket.count">
          <debug_text text="'job ship %s %s %s with job %s had no warebasket. recovering with job-defined basket: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, this.assignedcontrolled.job, this.assignedcontrolled.warebasket.list]" chance="$debugchance"/>
          <set_value name="$warebasket" exact="this.assignedcontrolled.warebasket.list"/>
          <do_if value="@$thisorder.exists">
            <edit_order_param order="this.assignedcontrolled.order" param="'warebasket'" value="$warebasket"/>
          </do_if>
          <wait exact="1s" sinceversion="8"/>
        </do_if>
        <do_else>
          <debug_text text="'mining without warebasket defined in jobs not supported!'" chance="$debugchance" />
          <set_value name="$failreason" exact="'ERR_NO_WAREBASKET'" />
          <set_value name="$failreason2" exact="'Job: ' + this.assignedcontrolled.job" />
          <resume label="finish" />
        </do_else>
      </do_if>

      <!-- Ranges -->
      <do_if value="not $range">
        <debug_text text="'range is null. attempting to recover.\ncommander setting: %s\ncommander sector: %s\njobmainsector: %s\ncurrent sector: %s'.[@this.assignedcontrolled.commanderentity.$config_subordinate_range, @this.assignedcontrolled.commanderentity.sector.knownname, @this.assignedcontrolled.jobmainsector.knownname, @this.assignedcontrolled.sector.knownname]" filter="error"/>
        <do_if value="@this.assignedcontrolled.jobmainsector">
          <set_value name="$range" exact="this.assignedcontrolled.jobmainsector"/>
        </do_if>
        <do_elseif value="this.assignedcontrolled.sector">
          <set_value name="$range" exact="this.assignedcontrolled.sector"/>
        </do_elseif>
        <do_elseif value="this.assignedcontrolled.zone.isclass.highway and this.assignedcontrolled.zone.destination.sector">
          <set_value name="$range" exact="this.assignedcontrolled.zone.destination.sector"/>
        </do_elseif>
        <do_else>
          <debug_text text="'failed to recover. $range is null. object is neither in a sector nor in a highway that goes to a sector.\nzone: %s %s\nzone parent: %s %s %s'.[@this.assignedcontrolled.zone.knownname, this.assignedcontrolled.zone, this.assignedcontrolled.zone.parent.class, @this.assignedcontrolled.zone.parent.knownname, this.assignedcontrolled.zone.parent]" filter="error"/>
        </do_else>
        <do_if value="$range and $thisorder.exists and $thisorder.$range?">
          <edit_order_param order="$thisorder" param="'range'" value="$range"/>
          <wait exact="1s" sinceversion="22"/>
        </do_if>
      </do_if>
      <do_elseif value="(typeof $range == datatype.keyword) and (($range == 'cluster') or ($range == 'sector') or ($range == 'zone'))">
        <!-- For jobs, get the string range 'zone', 'sector', 'cluster' -->
        <set_value name="$range" exact="this.assignedcontrolled.{$range}"/>
      </do_elseif>
      <do_elseif value="this.assignedcontrolled.commander and not this.assignedcontrolled.commander.hascontext.{$range} and this.assignedcontrolled.commander.sector.exists and (this.assignedcontrolled.order.id != 'Assist')">
        <set_value name="$range" exact="this.assignedcontrolled.commander.sector"/>
      </do_elseif>

      <do_if value="not $range">
        <debug_text text="'$range: %s still null after attempted recovery. idling before trying again later.\njobmainsector: %s %s, exists: %s\ncurrent sector: %s %s\nin highway: %s, highway destination sector: %s %s'.[@$range, @this.assignedcontrolled.jobmainsector.knownname, this.assignedcontrolled.jobmainsector, this.assignedcontrolled.jobmainsector.exists, @this.assignedcontrolled.sector.knownname, this.assignedcontrolled.sector, this.assignedcontrolled.zone.isclass.highway, @this.assignedcontrolled.zone.destination.sector.knownname, @this.assignedcontrolled.zone.destination.sector]" filter="error"/>
        <set_value name="$forceidle"/>
        <resume label="prep"/>
      </do_if>

      <set_value name="$samebuysellrange" exact="$minsell == $minbuy and $maxsell == $maxbuy"/>
      <run_script name="'lib.find.sectors.inrange'" result="$gatheringspaces" sinceversion="5">
        <param name="refobject" value="$range"/>
        <param name="mingatedistance" value="$minbuy"/>
        <param name="maxgatedistance" value="$maxbuy"/>
        <param name="debugchance" value="$debugchance"/>
      </run_script>
      <do_if value="$samebuysellrange">
        <!--The buy and sell ranges are the same, so clone the sectors.inrange results-->
        <set_value name="$sellspaces" exact="$gatheringspaces.clone"/>
      </do_if>
      <do_if value="this.isplayerowned and $maxbuy le 0 and not $gatheringspaces.indexof.{$range} and $range.isclass.sector">
        <debug_text text="'adding %s to gatheringspaces'.[$range.knownname]" chance="$debugchance"/>
        <append_to_list name="$gatheringspaces" exact="$range"/>
        <!-- if maxbuy is 0 and $range is not in $gatheringspaces, we must assume that the player wants us to go back to $range regardless of blacklist. -->
        <set_value name="$blacklist_overridebuy"/>
      </do_if>
      <debug_text text="'%s %s %s found %s gathering spaces.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $gatheringspaces.count]" chance="$debugchance"/>

      <do_if value="not $samebuysellrange">
        <run_script name="'lib.find.sectors.inrange'" result="$sellspaces" sinceversion="5">
          <param name="refobject" value="$range"/>
          <param name="mingatedistance" value="$minsell"/>
          <param name="maxgatedistance" value="$maxsell"/>
          <param name="debugchance" value="$debugchance"/>
        </run_script>
      </do_if>
      <do_if value="this.isplayerowned and $maxsell le 0 and not $sellspaces.indexof.{$range} and $range.isclass.sector">
        <debug_text text="'adding %s to sellspaces'.[$range.knownname]" chance="$debugchance"/>
        <append_to_list name="$sellspaces" exact="$range"/>
        <!-- if maxsell is 0 and $range is not in $sellspaces, we must assume that the player wants us to go back to $range regardless of blacklist. -->
        <set_value name="$blacklist_overridesell"/>
      </do_if>
      <debug_text text="'%s %s %s found %s sell spaces.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $sellspaces.count]" chance="$debugchance"/>
      <remove_value name="$samebuysellrange"/>

      <do_if value="not $gatheringspaces.count and not $sellspaces.count">
        <debug_text text="'No gatheringspaces and no sellspaces. %s %s %s in sector %s cannot operate. Idling for a while and trying again later in case conditions change.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @this.assignedcontrolled.sector.knownname]"/>
        <set_value name="$forceidle"/>
        <resume label="prep"/>
      </do_if>

      <do_if value="this.isplayerowned and $gatheringspaces.count gt 1">
        <do_for_each name="$locspace" in="$gatheringspaces">
          <do_if value="$locspace.cluster">
            <do_if value="not $loccluster?">
              <set_value name="$loccluster" exact="$locspace.cluster"/>
            </do_if>
            <do_elseif value="$loccluster != $locspace.cluster">
              <set_value name="$multicluster"/>
              <break/>
            </do_elseif>
          </do_if>
        </do_for_each>
        <do_if value="@$loccluster and not $multicluster?">
          <set_value name="$singlecluster"/>
        </do_if>
        <remove_value name="$multicluster"/>
        <remove_value name="$loccluster"/>
      </do_if>

      <do_if value="@this.hasrelation.enemy.{$range.owner} and not @this.assignedcontrolled.commander.hascontext.{$range}">
        <do_all exact="$gatheringspaces.count" counter="$i">
          <do_if value="$gatheringspaces.{$i}.owner == this.owner">
            <set_value name="$locrange" exact="$gatheringspaces.{$i}"/>
            <break/>
          </do_if>
          <do_elseif value="not this.hasrelation.enemy.{$gatheringspaces.{$i}.owner}">
            <set_value name="$locfallback" exact="$gatheringspaces.{$i}"/>
          </do_elseif>
        </do_all>

        <do_if value="not $locrange? and $locfallback?">
          <set_value name="$locrange" exact="$locfallback"/>
        </do_if>
        <remove_value name="$locfallback"/>

        <do_if value="$locrange?">
          <set_value name="$range" exact="$locrange"/>
          <debug_text text="'old anchor space was hostile. changing to %s %s.'.[$range.class, $range.knownname]" chance="$debugchance"/>
          <do_if value="@$thisorder.$range.isclass.space">
            <edit_order_param order="$thisorder" param="'range'" value="$range"/>
            <do_if value="this.assignedcontrolled.defaultorder == $thisorder">
              <edit_order_param order="this.assignedcontrolled.defaultorder" param="'range'" value="$range"/>
            </do_if>
            <!-- wait until order is restarted by param changing. -->
            <wait sinceversion="10"/>
          </do_if>
        </do_if>
        <remove_value name="$locrange"/>
      </do_if>

      <do_if value="this.sector and this.hasrelation.enemy.{this.sector.owner} and not @this.hasrelation.enemy.{$range.owner} and not @this.assignedcontrolled.commander.hascontext.{$range}">
        <debug_text text="'sector we are currently in is hostile. moving to safe space.'" chance="$debugchance"/>
        <!-- handling for nopath unnecessary -->
        <run_script name="'move.generic'" sinceversion="10">
          <param name="destination" value="$range"/>
          <param name="endintargetzone" value="true"/>
          <param name="debugchance" value="$debugchance" />
        </run_script>
        <resume label="prep"/>
      </do_if>

      <!-- primary loop start -->
      <label name="loop" />

      <do_if value="$duration and ((player.age - $time_start) gt $duration)">
        <resume label="finish"/>
      </do_if>

      <do_if value="not $resourcescout and this.assignedcontrolled.iscapitalship and ((this.assignedcontrolled.waretransport.indexof.{waretransport.solid} and not this.assignedcontrolled.units.{unitcategory.orecollector}.count) or (this.assignedcontrolled.waretransport.indexof.{waretransport.liquid} and not this.assignedcontrolled.units.{unitcategory.gascollector}.count))">
        <debug_text text="'%s %s %s has no collector drones. looping back to prep.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
        <resume label="prep"/>
      </do_if>

      <do_if value="player.age gt @$next_resupply_check" chance="30">
        <debug_text text="'%1 (%2) ready to resupply.'.[this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
        <signal_objects object="this.assignedcontrolled" param="'resupply'" param2="[false]" param3="$debugchance" comment="param2 = [urgent?, resupplystationID], param3 = $debugchance"/>
        <set_value name="$next_resupply_check" exact="player.age + 30min"/>
      </do_if>

      <!-- sell wares first if less than 50% free cargo -->
      <do_if value="not this.assignedcontrolled.cargo.free.all or (not $cannotsell? and ((this.assignedcontrolled.cargo.free.all)f / this.assignedcontrolled.cargo.capacity.all le 0.5))">
        <resume label="sellwares" />
      </do_if>
      <do_else>
        <debug_text text="player.age + ' looking good, starting new mining run'" chance="$debugchance" />
      </do_else>
      <remove_value name="$cannotsell"/>

      <!-- command action -->
      <set_command_action commandaction="commandaction.searchingresources" />

      <!-- Create the mining basket -->
      <create_list name="$miningbasket" />
      <!-- When Mining for commander -->
      <do_if value="@$homebase.isoperational">
        <!-- update the wares we deal with for a new trade run - ensure that we don't miss any wares if the list has changed due to the homebase being expanded -->
        <set_value name="$resources" exact="$homebase.resources.list" />

        <set_value name="$supplyresources" exact="$homebase.supplyresources.list" />
        <do_all exact="$supplyresources.count" counter="$i">
          <do_if value="not $resources.indexof.{$supplyresources.{$i}}">
            <append_to_list name="$resources" exact="$supplyresources.{$i}"/>
          </do_if>
        </do_all>

        <!-- support working for trade stations / warehouses as well -->
        <set_value name="$tradewares" exact="$homebase.tradewares.list" />
        <do_all exact="$tradewares.count" counter="$i">
          <do_if value="not $resources.indexof.{$tradewares.{$i}}">
            <append_to_list name="$resources" exact="$tradewares.{$i}" />
          </do_if>
        </do_all>
        <remove_value name="$tradewares" />

        <do_if value="$homebase.exists and not $homebase.iswreck and not $homebase.isrealclass.ship">
          <do_if value="not $skipshortage?">
            <set_value name="$resources_shortage" exact="[]"/>
            <set_value name="$resources_critical" exact="[]"/>
            <set_value name="$resources_to_check" exact="[]"/>
            <do_for_each name="$locresource" in="$resources">
              <do_if value="this.assignedcontrolled.cargo.{$locresource}.max gt 0">
                <append_to_list name="$resources_to_check" exact="$locresource"/>
              </do_if>
            </do_for_each>
            <debug_text text="'%s resources to check'.[$resources_to_check.count]" chance="$debugchance"/>
            <do_for_each name="$shortagetype" in="[class.production, class.buildmodule]">
              <generate_shortage_reports object="$homebase" type="$shortagetype" relevantwares="$resources_to_check"
                                         insufficient="$table_insufficient" insufficientthreshold="param.criticalwares.insufficientthreshold" insufficientthresholdcutoff="param.criticalwares.insufficientthresholdcutoff"
                                         shortage="$table_shortage" shortagethreshold="param.criticalwares.shortagethreshold"/>

              <do_for_each name="$locware" in="$table_insufficient">
                <!--Remove insufficient wares from the resources to check as they are already added to both lists-->
                <remove_from_list name="$resources_to_check" exact="$locware"/>
                <append_to_list name="$resources_shortage" exact="$locware"/>
                <append_to_list name="$resources_critical" exact="$locware"/>
              </do_for_each>
              <do_for_each name="$locware" in="$table_shortage">
                <do_if value="not $resources_shortage.indexof.{$locware}">
                  <append_to_list name="$resources_shortage" exact="$locware"/>
                </do_if>
              </do_for_each>
            </do_for_each>
            <remove_value name="$resources_to_check"/>
            <remove_value name="$table_shortage"/>
            <remove_value name="$table_insufficient"/>

            <do_if value="@$resources_shortage.count">
              <do_for_each name="$locware" in="$resources_shortage" reverse="true">
                <find_buy_offer result="$evalbuyoffer" tradepartner="this.assignedcontrolled" buyer="$homebase" wares="$locware"/>
                <do_if value="not $evalbuyoffer or not $homebase.maybuyfrom.[this.owner, $locware]">
                  <do_if value="$resources_critical.indexof.{$locware}">
                    <debug_text text="'critical ware: %s not wanted by station. ignoring shortage.'.[$locware]" chance="$debugchance"/>
                    <remove_from_list name="$resources_critical" exact="$locware"/>
                  </do_if>
                  <debug_text text="'shortage ware: %s not wanted by station. ignoring shortage.'.[$locware]" chance="$debugchance"/>
                  <remove_value name="$resources_shortage.{loop.index}"/>
                </do_if>
              </do_for_each>
              <remove_value name="$evalbuyoffer"/>

              <do_if value="$resources_shortage.count">
                <set_value name="$usedshortage"/>
                <debug_text text="'shortage detected. will try to purchase %s wares for %s %s %s. num critical wares: %s'.[$resources_shortage.count, @$homebase.idcode, @$homebase.knownname, $homebase, $resources_critical.count]" chance="$debugchance"/>
                <set_value name="$resources" exact="$resources_shortage"/>
                <do_if value="$resources_critical.count">
                  <debug_text text="'critical shortage detected of %s wares.'.[$resources_critical.count]" chance="$debugchance"/>
                  <set_value name="$resources" exact="$resources_critical"/>
                </do_if>
              </do_if>
            </do_if>

          </do_if>
        </do_if>

        <do_if value="$warebasket_override.count">
          <do_for_each name="$locware" in="$resources" reverse="true">
            <do_if value="not $warebasket_override.indexof.{$locware}">
              <remove_from_list name="$resources" exact="$locware"/>
              <debug_text text="'%s not in manual ware basket. removing.'.[$locware]" chance="$debugchance2"/>
            </do_if>
          </do_for_each>
          <do_if value="not $resources.count">
            <debug_text text="'no wares left after filtering through manual ware basket.'" chance="$debugchance2"/>
            <do_if value="$usedshortage?">
              <debug_text text="'skipping shortages and trying again.'" chance="$debugchance2"/>
              <remove_value name="$usedshortage"/>
              <set_value name="$skipshortage"/>
              <resume label="loop"/>
            </do_if>
            <set_value name="$failreason" exact="'ERR_EMPTY_WAREBASKET'"/>
            <debug_text text="'no wares left after filtering through manual ware basket.'" chance="$debugchance2"/>
            <set_value name="$failurereason" exact="{1045, 113}" comment="No matching trade offer found."/>
            <do_if value="@this.assignedcontrolled.order.isrunning">
              <set_order_failed order="this.assignedcontrolled.order" text="$failurereason"/>
            </do_if>
          </do_if>
        </do_if>

        <!-- start with an empty list in case warebasket contains outdated wares. -->
        <create_list name="$locwares"/>
        <!-- Resources + Tradewares to Warebasket -->
        <do_for_each name="$locware" in="$resources">
          <!-- Minable wares, with capacity to carry them and that are not already in the ware list -->
          <do_if value="($locware.hastag.minable) and (this.assignedcontrolled.cargo.{$locware}.max gt 0) and (not $locwares.indexof.{$locware})">
            <!-- either is not a big ship, or the ware is not mineral, or it is mineral and needs collectors -->
            <do_if value="(not this.assignedcontrolled.iscapitalship) or (not $locware.hastag.mineral) or (this.object.units.collect.{$locware}.count)">
              <append_to_list name="$locwares" exact="$locware"/>
              <do_if value="not $warebasket.indexof.{$locware}">
                <set_value name="$basketchanged"/>
              </do_if>
            </do_if>
          </do_if>
        </do_for_each>

        <!-- check to see if we either added something or removed something from our warebasket. -->
        <do_if value="$basketchanged? or ($warebasket.count != $locwares.count)">
          <debug_text text="'%s %s %s updating warebasket. wares added? %s, wares removed? %s\nnew warebasket: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $basketchanged?, $locwares.count != $warebasket.count, $warebasket]" chance="$debugchance"/>
          <set_value name="$warebasket" exact="$locwares.clone"/>
          <!-- edit_order_param deprecated here since shortage wares are now shown in the UI -->
          <wait exact="1ms" sinceversion="6" chance="0"/>
        </do_if>
        <remove_value name="$locwares"/>

        <do_if value="not $warebasket.count">
          <debug_text text="'Home base: %s %s %s does not need anything at the moment. Waiting to check again.'.[@$homebase.idcode, @$homebase.knownname, $homebase]" chance="$debugchance"/>
          <set_value name="$forceidle"/>
          <resume label="prep"/>
        </do_if>

        <!-- we build our shopping list by intersecting our warebasket and the resources of our homebase -->
        <set_value name="$shoppinglist" exact="table[]" />
        <!-- Get the buy offers with this ships as partner -->
        <find_buy_offer buyer="$homebase" multiple="true" result="$buyoffers" wares="$warebasket" tradepartner="this.assignedcontrolled"/>
        <debug_text text="player.age + ' homebase %1 [%2] has %3 offers for %4'.[$homebase.knownname, $homebase, $buyoffers.count, $warebasket]" chance="$debugchance" />
        <!-- Create the shoppinglist table -->
        <do_if value="$buyoffers.count" min="1">
          <!-- use the buyoffers on our homebase to determine resource need -->
          <do_all counter="$b" exact="$buyoffers.count">
            <set_value name="$buyoffer" exact="$buyoffers.{$b}" />
            <set_value name="$buyofferamount" exact="$buyoffer.offeramount.{this.assignedcontrolled}" />
            <get_ware_reservation object="$homebase" ware="$buyoffer.ware" type="sell" virtual="true" result="$reserved" />
            <debug_text text="player.age + ' %1 wants %5(want %2, expecting %4) units of %3'.[$homebase.knownname, $buyofferamount, $buyoffer.ware, $reserved, [$buyofferamount - $reserved, 0].max]" chance="$debugchance" />
            <!-- Table key: buyoffer, value: needed amount (buy offer amount - reserved) / target amount -->
            <set_value name="$shoppinglist.{$buyoffer}" exact="[$buyofferamount - $reserved, 0].max / ([$homebase.cargo.{$buyoffer.ware}.target, 1].max)f"/>
          </do_all>
          <remove_value name="$reserved" />
          <remove_value name="$buyoffer" />
          <remove_value name="$buyoffers" />
        </do_if>
        <!-- Minable resources that the station wants -->
        <do_if value="$shoppinglist.keys.count">
          <!-- Sorted by needed  -->
          <set_value name="$neededbuyoffers" exact="$shoppinglist.keys.sorted" />
          <create_list name="$miningbasket" comment="Ware list sorted by most needed wares" />
          <create_list name="$neededamounts" comment="Associated offer amounts for the sorted wares" />
          <create_list name="$priorities"/>
          <!-- Iterate in reverse to put the most needed (last) into the first places -->
          <do_all exact="$neededbuyoffers.count" counter="$i" reverse="true">
            <!-- key: buy offer ware, value: offer amount -->
            <append_to_list name="$miningbasket" exact="$neededbuyoffers.{$i}.ware" />
            <append_to_list name="$neededamounts" exact="$neededbuyoffers.{$i}.offeramount.{this.assignedcontrolled}"/>
            <append_to_list name="$priorities" exact="$shoppinglist.{$neededbuyoffers.{$i}}"/>
          </do_all>
          <do_all exact="$miningbasket.count" counter="$i" chance="$debugchance">
            <debug_text text="'ware: %s, amount: %s, priority: %s'.[$miningbasket.{$i}, $neededamounts.{$i}, $priorities.{$i}]"/>
          </do_all>
          <remove_value name="$shoppinglist" />
          <remove_value name="$neededbuyoffers" />
        </do_if>
        <do_else>
          <set_value name="$failurereason" exact="{1045, 113}" comment="No matching trade offer found."/>
          <debug_text text="player.age + ' unable to find an appropriate buyoffer'" chance="$debugchance" />
        </do_else>
      </do_if>
      <!-- Free miner -->
      <do_else>
        <!-- Ware Selection: two choices. Either:
                Look through everything in $sellspaces and pick the ware that sells for the biggest price. (Barring travel cost, that would be the most profitable because costs are only capital. Ideal, but more expensive since more buy offers will have to be processed.)
                Or tally three (or some arbitrary number. only important that it's consistent.) prices, get the average (or just add them if you can always relibaly get the same number of offers for everything in the ware basket) and compare those. (Cheaper, but not as smart.)
                
                Idea is to guess which ware will be in high demand AFTER we're done mining.
                So we look at what's selling well now, but we don't do a comprehensive search because we have no idea if those conditions will hold later. -->
        <do_if value="($warebasket.count gt 1) and ((this.skill.management ge 6) or ($effectiveskill == 100))">
          <set_value name="$buyoffers_evaluate" exact="[]"/>
          <set_value name="$miningtable" exact="table[]"/>

          <!-- iterate over all of the clusters in the defined range. sellspaces is sorted by distance. -->
          <do_all exact="$sellspaces.count" counter="$i">
            <!-- find all buy offers in each space. -->
            <find_buy_offer tradepartner="this.assignedcontrolled" wares="$warebasket" space="$sellspaces.{$i}" result="$buyoffers_evaluate" multiple="true"/>
            <debug_text text="player.age + ' found %1 buy offers in %2. ware basket: %3'.[$buyoffers_evaluate.count, $sellspaces.{$i}.knownname, $warebasket]" chance="0"/>
            <wait min="30ms" max="70ms"/>
            <!-- if we found any ... -->
            <do_if value="$buyoffers_evaluate.count">
              <!-- shuffle list so that offers with the same relprice are still in a random order and not in the consistent order that the stations were found in -->
              <shuffle_list list="$buyoffers_evaluate"/>
              <!-- sort buy offers by relative price. relative price is the amount of deviation from average price. -->
              <sort_trades name="$buyoffers_evaluate" tradelist="$buyoffers_evaluate" sorter="relativeprice"/>
              <do_all exact="$buyoffers_evaluate.count" counter="$j" reverse="true">
                <!-- record this trade if:
                      we have not recorded a trade for this ware yet,
                      or we found a better price for this ware. (only relevant if we ever evaluate more than one cluster) -->
                <do_if value="not $miningtable.{$buyoffers_evaluate.{$j}.ware}? or ($buyoffers_evaluate.{$j}.relativeprice gt $miningtable.{$buyoffers_evaluate.{$j}.ware})">
                  <set_value name="$miningtable.{$buyoffers_evaluate.{$j}.ware}" exact="$buyoffers_evaluate.{$j}.relativeprice"/>
                  <debug_text text="'adding %1 to mining basket. price: %2. mining table: %3.'.[$buyoffers_evaluate.{$j}.ware, $buyoffers_evaluate.{$j}.relativeprice, $miningtable]" chance="$debugchance"/>
                </do_if>
                <!-- if we have records for all wares we are interested in, we need not look any further to get an estimate.
                      update: we don't really need the whole basket because we'll end up only getting one ware. stop after finding offers for two wares to limit the number of times we have to iterate.
                        update reverted because it could introduce the problem of mining ships never going after a third ware in their basket because two wares are always in demand in their starting cluster.
                        reduces the number of clusters evaluated from around 9 on average to 1 or 2 though, so performance gain could be substantial. might prove necessary. -->
                <!--<do_if value="$miningtable.keys.count == [2, $warebasket.count].min">-->
                <do_if value="$miningtable.keys.count == $warebasket.count">
                  <debug_text text="'offers found for everything in the basket! looked through ' + $i + ' clusters.'" chance="$debugchance"/>
                  <break/>
                </do_if>
              </do_all>
              <do_if value="$miningtable.keys.count == $warebasket.count">
                <break/>
              </do_if>
            </do_if>
          </do_all>

          <do_if value="$miningtable.keys.count">
            <debug_text text="'trade offers for %1 wares found. %2 wares in the ware basket.'.[$miningtable.keys.count, $warebasket.count]" chance="$debugchance"/>
            <!-- if the miner is really good, the list will be sorted by best price over the space evaluated. again, only relevant if more than one cluster is ever evaluated. -->
            <do_if value="true" chance="$effectiveskill">
              <set_value name="$sortedbasket" exact="$miningtable.keys.sorted"/>
              <do_all exact="$sortedbasket.count" counter="$i" reverse="true">
                <append_to_list name="$miningbasket" exact="$sortedbasket.{$i}"/>
              </do_all>
              <remove_value name="$sortedbasket"/>
            </do_if>
            <do_else>
              <set_value name="$miningbasket" exact="$miningtable.keys.list"/>
              <shuffle_list list="$miningbasket"/>
            </do_else>
            <debug_text text="'mining basket assembled: ' + $miningbasket" chance="$debugchance"/>
          </do_if>
          <do_else>
            <set_value name="$failurereason" exact="{1045, 107}" comment="No buyers found in range."/>
            <debug_text text="'no offers found after going through %1 clusters. %2 wares in the warebasket.'.[$sellspaces.count, $warebasket.count]" chance="$debugchance"/>
          </do_else>
          <!--<debug_text text="'%1 selected. prices: %2, %3, %4'.[$miningbasket.{1}, $miningtable.{$miningbasket.{1}}, $miningtable.{$miningbasket.{2}}, $miningtable.{$miningbasket.{3}}]" chance="$debugchance"/>-->

          <!-- if we are ever in a situation where we do not find buy offers for everything in our ware basket, add everything in the ware basket anyway
                  because there might not be demand for these wares right now, but there might be demand for them later. they will have lower priority. -->
          <do_if value="$miningbasket.count lt $warebasket.count">
            <do_all exact="$warebasket.count" counter="$i">
              <do_if value="not $miningbasket.indexof.{$warebasket.{$i}}">
                <append_to_list name="$miningbasket" exact="$warebasket.{$i}"/>
              </do_if>
            </do_all>
          </do_if>
          <remove_value name="$miningtable"/>
          <remove_value name="$buyoffers_evaluate"/>
        </do_if>
        <do_else>
          <!-- Really bad miners just get whatever is handy. -->
          <set_value name="$miningbasket" exact="$warebasket.clone"/>
          <shuffle_list list="$miningbasket"/>
          <debug_text text="'backup mining basket: ' + $miningbasket" chance="$debugchance"/>
        </do_else>
      </do_else>

      <!-- No minable resources -->
      <do_if value="not $miningbasket.count" >
        <debug_text text="player.age + ' unable to find minable resources, waiting...'" chance="$debugchance" />
        <do_if value="@$failurereason and @this.assignedcontrolled.order.isrunning">
          <set_order_failed order="this.assignedcontrolled.order" text="$failurereason"/>
        </do_if>
        <remove_value name="$failurereason"/>
        <!-- Idle for a while -->
        <run_script name="'move.idle'" >
          <param name="Min" value="30s" />
          <param name="Max" value="90s" />
        </run_script>
        <resume label="loop"/>
      </do_if>
      <remove_value name="$failurereason"/>

      <!-- NB: method is potentially much faster, but we're wasting iterations if there are no resource probes within operating range. -->
      <set_value name="$thissector" exact="this.sector"/>
      <set_value name="$resourceprobe_table" exact="table[]"/>
      <set_value name="$probesectors" exact="[]"/>
      <!-- to do: for now, these are based on maximum logged numbers and will have to be updated when yields are updated.
                    if/when a way to directly get the yield of spaces (preferably clusters, but zones will do. regions would be ok, but only if you could get some sort of position information) is available, do that instead. -->
      <set_value name="$minamounts" exact="player.galaxy.yieldthresholds.table"/>
      <set_value name="$secwares" exact="[]"/>
      <!-- NB: miners tend to find the closest sector in their range with resource probes in them that detect yields at or better than what they need, but only drill down to the first probe they find in that sector that has yields at or better than minamount -->
      <!-- NB: for determining specific location, only evaluate probes for the highest priority ware. evaluate all others in the general logic further down. $probesectors prioritized in the later logic. -->
      <do_if value="this.isplayerowned" comment="NPCs do not necessarily place resource probes smartly so let's not get distracted by them">
        <set_value name="$evalware" exact="$miningbasket.{1}"/>
        <do_for_each name="$space" in="$gatheringspaces">
          <do_if value="not $space.isclass.sector">
            <debug_text text="'%s %s %s in gatheringspaces is not a sector. resourceprobes in it will not be evaluated.'.[$space.class, $space.knownname, $space]" filter="error"/>
            <continue/>
          </do_if>
          <!--optimisation: not @this.hasrelation.enemy.{$space.owner} will resolve to null if $space.owner is null. Suppress the error and treat as a passed condition.-->
          <do_if value="($space == $thissector) or ($space == @this.assignedcontrolled.commander.sector) or ((not $space.hashazardousregion or $space.containsthewave or not this.assignedcontrolled.takesregiondamage) and not @this.hasrelation.enemy.{$space.owner})">
            <do_if value="$space.iscontested">
              <set_value name="$loccontestingfactions" exact="$space.contestingfactions"/>
              <do_if value="not $loccontestingfactions.indexof.{this.owner}">
                <do_for_each name="$locfaction" in="$loccontestingfactions">
                  <do_if value="$locfaction.mayattack.{this.assignedcontrolled}">
                    <set_value name="$iscontested"/>
                    <break/>
                  </do_if>
                </do_for_each>
              </do_if>
              <remove_value name="$loccontestingfactions"/>
            </do_if>
            <do_if value="not $iscontested?">
              <do_if value="$resourceprobe_table.{$space}?">
                <set_value name="$resourceprobes" exact="$resourceprobe_table.{$space}"/>
              </do_if>
              <do_else>
                <find_object name="$resourceprobes" class="class.resourceprobe" space="$space" owner="this.owner" multiple="true"/>
                <set_value name="$resourceprobe_table.{$space}" exact="$resourceprobes"/>
                <debug_text text="'found %s resource probes in %s %s, %s gates away'.[$resourceprobes.count, $space.class, $space.knownname, $range.gatedistance.{$space}]" chance="($resourceprobes.count gt 0) * $debugchance"/>
              </do_else>
              <do_if value="$resourceprobes.count">
                <!-- store probesectors, prefer in second iteration -->
                <do_if value="not $probesectors.indexof.{$space}">
                  <append_to_list name="$probesectors" exact="$space"/>
                </do_if>
                <set_value name="$locaveragemaxyield" exact="$space.averagemaxyield.{$evalware}.count / (1.0f + ([$range.gatedistance.{$space}, 0].max)f * 0.2f)"/>
                <debug_text text="'evaluating sector %s\naveragemaxyield: %s\nraw averagemaxyield: %s\nyieldthreshold: %s\ngatedistance: %s'.[$space.knownname, $locaveragemaxyield, $space.averagemaxyield.{$evalware}.count, $minamounts.{$evalware}, $range.gatedistance.{$space}]" chance="$debugchance2"/>
                <do_if value="($locaveragemaxyield ge $minamounts.{$evalware}) and (not $bestaveragemaxyield? or ($locaveragemaxyield gt $bestaveragemaxyield))">
                  <set_value name="$bestsector" exact="$space"/>
                  <set_value name="$bestaveragemaxyield" exact="$locaveragemaxyield"/>
                </do_if>
                <remove_value name="$locaveragemaxyield"/>
              </do_if>
            </do_if>
            <remove_value name="$iscontested"/>
          </do_if>
          <!-- spread out load if iterating over a large number of spaces. -->
          <wait min="3ms" max="71ms" sinceversion="11"/>
        </do_for_each>
        <do_if value="@$bestsector.exists">
          <set_value name="$resourceprobes" exact="$resourceprobe_table.{$bestsector}"/>
          <debug_text text="'evaluating %s probes in %s'.[$resourceprobes.count, $bestsector.knownname]" chance="$debugchance2"/>
          <shuffle_list list="$resourceprobes"/>
          <do_for_each name="$probe" in="$resourceprobes">
            <do_if value="$probe.isoperational">
              <set_value name="$locamount" exact="$probe.currentbestyield.{$evalware}"/>
              <debug_text text="'locamount: %s, averagemaxyield: %s'.[$locamount, $bestsector.averagemaxyield.{$evalware}.count]" chance="$debugchance2"/>
              <do_if value="$locamount and ($locamount ge $bestsector.averagemaxyield.{$evalware}.count)">
                <do_if value="(not $bestyield? or ($locamount gt $bestyield))">
                  <set_value name="$bestyield" exact="$locamount"/>
                  <set_value name="$bestprobe" exact="$probe"/>
                  <debug_text text="'%s %s found close to %s %s in %s %s.\n%sm away from me.'.[$bestyield, $evalware, $bestprobe.class, $bestprobe, $bestsector.class, $bestsector.knownname, this.assignedcontrolled.distanceto.{$bestprobe}]" chance="$debugchance2"/>
                  <do_if value="$locamount ge [$minamounts.{$evalware}, this.assignedcontrolled.cargo.{$evalware}.free].max">
                    <debug_text text="'going to mine %s in %s.\namount close to probe: %s\namount needed: %s'.[$evalware, $bestsector.knownname, $locamount, this.assignedcontrolled.cargo.{$evalware}.free]" chance="$debugchance"/>
                    <!-- stop evaluating at resource probes that fulfill minamounts to mitigate multiple mining ships converging at the best probe. -->
                    <break/>
                  </do_if>
                </do_if>
              </do_if>
              <do_else>
                <debug_text text="'probe skipped due to having low yield.\nprobe yield: %s, sector average: %s'.[$locamount, $bestsector.averagemaxyield.{$evalware}.count]" chance="$debugchance2"/>
              </do_else>
              <remove_value name="$locamount"/>
            </do_if>
          </do_for_each>
        </do_if>
        <do_if value="$bestyield?">
          <set_value name="$rawbestyield" exact="$bestyield"/>
          <set_value name="$bestyield" min="$bestyield * [$effectiveskill, 1].max / 100.0f" max="$bestyield" profile="decreasing"/>
          <debug_text text="'\npreyield: %s\nbestyield: %s\nworstyield: %s\nskill: %s'.[$rawbestyield, $bestyield, $bestyield * [$effectiveskill, 1].max / 100.0f, $effectiveskill]" chance="$debugchance2"/>
          <do_if value="not $deepspace and this.isplayerowned and this.assignedcontrolled.attention ge attention.visible and this.assignedcontrolled.hascontext.{$bestsector} and $evalware.hastag.mineral">
            <find_asteroid_in_cluster name="$closestasteroid" cluster="$bestsector.cluster" refobject="this.assignedcontrolled" canpickup="false" maxdistance="120km" ware="$evalware"/>
            <do_if value="@$closestasteroid.hascontext.{$bestsector}">
              <set_value name="$sector" exact="$closestasteroid.sector"/>
              <create_position name="$pos_sector" space="$sector" object="$closestasteroid"/>
              <debug_text text="'1 found %s-bearing asteroid %sm away'.[$ware, this.assignedcontrolled.distanceto.{$closestasteroid}]" chance="$debugchance"/>
            </do_if>
            <remove_value name="$closestasteroid"/>
          </do_if>
          <do_if value="not @$sector.exists">
            <find_closest_resource sector="$sector" position="$pos_sector" wares="$secwares" distance="$distance" ware="$evalware" refobject="$bestsector" minamount="$bestyield" useundiscovered="not this.isplayerowned">
              <refposition value="$bestsector.coreposition" object="$bestsector" max="$bestsector.coresize / 4m"/>
            </find_closest_resource>
          </do_if>
          <remove_value name="$rawbestyield"/>
          <remove_value name="$bestyield"/>
          <do_if value="@$sector.exists">
            <!-- $ware used further down. -->
            <set_value name="$ware" exact="$evalware"/>
            <debug_text text="'%s %s %s going for %s close to %s %s in %s.\n%sm away from the probe.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $ware, $bestprobe.class, $bestprobe, $sector.knownname, $distance]" chance="$debugchance"/>
          </do_if>
        </do_if>
      </do_if>
      <remove_value name="$bestaveragemaxyield"/>
      <remove_value name="$bestsector"/>
      <remove_value name="$bestprobe"/>
      <remove_value name="$distance"/>
      <remove_value name="$resourceprobes"/>
      <remove_value name="$evalware"/>
      <remove_value name="$resourceprobe_table"/>
      <remove_value name="$thissector"/>

      <do_if value="not @$sector.exists">
        <do_if value="$probesectors.count">
          <!-- rearrange gatheringspaces with probesectors in front -->
          <set_value name="$newgatheringspaces" exact="$probesectors.clone"/>
          <do_for_each name="$locspace" in="$gatheringspaces">
            <do_if value="not $probesectors.indexof.{$locspace}">
              <append_to_list name="$newgatheringspaces" exact="$locspace"/>
            </do_if>
          </do_for_each>
          <set_value name="$gatheringspaces" exact="$newgatheringspaces"/>
        </do_if>
        <remove_value name="$newgatheringspaces"/>
        <!-- Iterate over the wares in the basket -->
        <do_all exact="$miningbasket.count" counter="$w" >
          <set_value name="$ware" exact="$miningbasket.{$w}" />
          <set_value name="$freecargo" exact="this.assignedcontrolled.cargo.{$ware}.free"/>
          <set_value name="$baseminamount" exact="$freecargo"/>
          <do_if value="$baseminamount lt $minamounts.{$ware}">
            <set_value name="$baseminamount" min="$baseminamount" max="$minamounts.{$ware}"/>
          </do_if>
          <!-- Find Resouces: Iterate over the gathering spaces -->
          <do_all exact="$gatheringspaces.count" counter="$i">
            <set_value name="$scaledminamount" exact="[$freecargo, $baseminamount].max"/>
            <do_if value="$probesectors.indexof.{$gatheringspaces.{$i}}">
              <set_value name="$scaledminamount" exact="$scaledminamount / 2.0f"/>
            </do_if>
            <debug_text text="'now looking for %1 in %2 %3, scaledminamount = %4, baseminamount = %5, minamount = %6, freecargo = %7'.[$ware, $gatheringspaces.{$i}.class, $gatheringspaces.{$i}.knownname, $scaledminamount, $baseminamount, $minamounts.{$ware}, $freecargo]" chance="$debugchance" />
            <!-- NB: As this was (commented out below), when the ship evaluates this.cluster, it looks in the station's cluster. If it doesn't find anything until the list iterates to the station's cluster, it looks at it again.
                  Changed so that it will look in this.cluster when it is in this.cluster.

                  Possibly desirable behavior if the ship is subordinate to a station is to always look at the station's cluster first. In that case, the below and $range above would have to be changed.
                  Same with the old method below. -->
            <!-- deepspace: find a spot within a region that will tend to be in deep space (doesn't have to be absolute) and mine there.
                  that, or be able to define a minimum offset from sector center to pass into find_resource. -->
            <do_if value="$deepspace">
              <do_if value="$gatheringspaces.{$i}.isclass.cluster">
                <find_sector name="$clustersectors" space="$gatheringspaces.{$i}" multiple="true"/>
              </do_if>
              <do_elseif value="$gatheringspaces.{$i}.isclass.sector">
                <set_value name="$clustersectors" exact="[$gatheringspaces.{$i}]"/>
              </do_elseif>
              <do_elseif value="$gatheringspaces.{$i}.sector">
                <set_value name="$clustersectors" exact="[$gatheringspaces.{$i}.sector]"/>
              </do_elseif>
              <do_else>
                <debug_text text="'ERROR: gatheringspaces.{$i}: %s %s is neither a cluster, nor a sector, nor something in a sector.'.[$gatheringspaces.{$i}.knownname, $gatheringspaces.{$i}]" filter="error"/>
              </do_else>
              <do_all exact="$clustersectors.count" counter="$j">
                <run_script name="'lib.find.point.indeepspace'" result="$deepspacepos">
                  <param name="sector" value="$clustersectors.{$j}"/>
                  <param name="allowyaxis" value="true"/>
                </run_script>
                <find_closest_resource ware="$ware" refobject="$clustersectors.{$j}" sector="$sector" position="$pos_sector" wares="$secwares" minamount="$minamounts.{$ware}">
                  <refposition value="$deepspacepos"/>
                </find_closest_resource>
                <do_if value="$sector">
                  <debug_text text="'find method 1. going to position: %s, %s, %s relative to sector %s %s\ndeepspace pos: %s, %s, %s'.[@$pos_sector.x, @$pos_sector.y, @$pos_sector.z, @$sector.knownname, $sector, $deepspacepos.x, $deepspacepos.y, $deepspacepos.z]" chance="$debugchance"/>
                  <break/>
                </do_if>
              </do_all>
              <remove_value name="$clustersectors"/>
            </do_if>
            <do_elseif value="$gatheringspaces.{$i}.isclass.sector">
              <do_if value="not $bestsector? or ($gatheringspaces.{$i}.averagemaxyield.{$ware}.count gt $bestsector.averagemaxyield.{$ware}.count)">
                <do_if value="($gatheringspaces.{$i} == @this.assignedcontrolled.commander.sector) or not $gatheringspaces.{$i}.hashazardousregion or $gatheringspaces.{$i}.containsthewave or not this.assignedcontrolled.takesregiondamage">
                  <do_if value="not $gatheringspaces.{$i}.owner or not this.hasrelation.enemy.{$gatheringspaces.{$i}.owner}">
                    <do_if value="not $gatheringspaces.{$i}.policefaction or (this.owner == $gatheringspaces.{$i}.policefaction) or not $ware.illegalto.{$gatheringspaces.{$i}.policefaction}.{this.owner}">
                      <do_if value="$gatheringspaces.{$i}.iscontested">
                        <do_if value="not $gatheringspaces.{$i}.contestingfactions.indexof.{this.owner}">
                          <do_for_each name="$locfaction" in="$gatheringspaces.{$i}.contestingfactions">
                            <do_if value="$locfaction.mayattack.{this.assignedcontrolled}">
                              <set_value name="$iscontested"/>
                              <break/>
                            </do_if>
                          </do_for_each>
                        </do_if>
                      </do_if>
                      <do_if value="not $iscontested?">
                        <!-- failsafe. in case nothing is found that meets $scaledminamount. -->
                        <set_value name="$bestsector" exact="$gatheringspaces.{$i}"/>
                        <debug_text text="'recording sector %s for fallback in case needed.'.[$bestsector.knownname]" chance="$debugchance2"/>
                      </do_if>
                      <remove_value name="$iscontested"/>
                    </do_if>
                  </do_if>
                </do_if>
              </do_if>

              <do_if value="(not $preferownspace or $gatheringspaces.{$i}.owner == this.trueowner) and $gatheringspaces.{$i}.resources.{$ware}.exists">
                <do_if value="this.assignedcontrolled.hascontext.{$gatheringspaces.{$i}}">
                  <do_if value="this.isplayerowned and this.assignedcontrolled.attention ge attention.visible and $ware.hastag.mineral">
                    <find_asteroid_in_cluster name="$closestasteroid" cluster="this.assignedcontrolled.cluster" refobject="this.assignedcontrolled" canpickup="false" maxdistance="120km" ware="$ware"/>
                    <do_if value="@$closestasteroid.hascontext.{$gatheringspaces.{$i}}">
                      <set_value name="$sector" exact="$closestasteroid.sector"/>
                      <create_position name="$pos_sector" space="$sector" object="$closestasteroid"/>
                      <debug_text text="'2 found %s-bearing asteroid %sm away'.[$ware, this.assignedcontrolled.distanceto.{$closestasteroid}]" chance="$debugchance"/>
                    </do_if>
                    <remove_value name="$closestasteroid"/>
                  </do_if>
                  <do_if value="not @$sector.exists">
                    <find_closest_resource sector="$sector" position="$pos_sector" wares="$secwares" ware="$ware" refobject="this.assignedcontrolled" minamount="$scaledminamount" useundiscovered="not this.isplayerowned"/>
                    <!--<find_closest_resource ware="$ware" refobject="if $homebase? then $homebase else this.assignedcontrolled" zone="$zone" wares="$secwares" minamount="$minamounts.{$ware}"/>-->
                  </do_if>
                </do_if>
                <do_else>
                  <find_closest_resource sector="$sector" position="$pos_sector" wares="$secwares" ware="$ware" refobject="$gatheringspaces.{$i}" minamount="$scaledminamount" useundiscovered="not this.isplayerowned">
                    <refposition value="$gatheringspaces.{$i}.coreposition" object="$gatheringspaces.{$i}" max="$gatheringspaces.{$i}.coresize / 4m"/>
                  </find_closest_resource>
                </do_else>
              </do_if>
            </do_elseif>
            <do_else>
              <do_if value="this.assignedcontrolled.hascontext.{$gatheringspaces.{$i}}">
                <do_if value="this.isplayerowned and this.assignedcontrolled.attention ge attention.visible and $ware.hastag.mineral">
                  <find_asteroid_in_cluster name="$closestasteroid" cluster="this.assignedcontrolled.cluster" refobject="this.assignedcontrolled" canpickup="false" maxdistance="120km" ware="$ware"/>
                  <do_if value="@$closestasteroid.hascontext.{$gatheringspaces.{$i}}">
                    <set_value name="$sector" exact="$closestasteroid.sector"/>
                    <create_position name="$pos_sector" space="$sector" object="$closestasteroid"/>
                    <debug_text text="'3 found %s-bearing asteroid %sm away'.[$ware, this.assignedcontrolled.distanceto.{$closestasteroid}]" chance="$debugchance"/>
                  </do_if>
                  <remove_value name="$closestasteroid"/>
                </do_if>
                <do_if value="not @$sector.exists">
                  <find_closest_resource sector="$sector" position="$pos_sector" wares="$secwares" ware="$ware" refobject="this.assignedcontrolled" minamount="$scaledminamount" useundiscovered="not this.isplayerowned"/>
                </do_if>
              </do_if>
              <do_else>
                <find_resource sector="$sector" position="$pos_sector" wares="$secwares" ware="$ware" refobject="$gatheringspaces.{$i}" minamount="$scaledminamount" useundiscovered="not this.isplayerowned"/>
              </do_else>
            </do_else>

            <!-- Zone found -->
            <do_if value="@$sector.exists">
              <debug_text text="'Resource %1 found in %2, %3. minamount: %4'.[$ware, $sector.knownname, $sector.cluster.knownname, $scaledminamount]" chance="$debugchance"/>
              <do_if value="$gatheringspaces.indexof.{$sector}">
                <do_if value="this.isplayerowned and $gatheringspaces.count == 1">
                  <break/>
                </do_if>
                <do_if value="(not $sector.hashazardousregion or $sector.containsthewave or not this.assignedcontrolled.takesregiondamage) and (not $sector.owner or not this.hasrelation.enemy.{$sector.owner}) and (not $sector.policefaction or (this.owner == $sector.policefaction) or not $ware.illegalto.{$sector.policefaction}.{this.owner})">
                  <do_if value="$sector.iscontested">
                    <do_if value="not $sector.contestingfactions.indexof.{this.owner}">
                      <do_for_each name="$locfaction" in="$sector.contestingfactions">
                        <do_if value="$locfaction.mayattack.{this.assignedcontrolled}">
                          <set_value name="$iscontested"/>
                          <break/>
                        </do_if>
                      </do_for_each>
                    </do_if>
                  </do_if>
                  <do_if value="not $iscontested?">
                    <debug_text text="'%s %s %s mining in sector %s belonging to %s. enemy? %s, effective skill: %s, combinedskill: %s'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $sector.knownname, $sector.owner, this.hasrelation.enemy.{$sector.owner}, $effectiveskill, this.assignedcontrolled.combinedskill]" chance="$debugchance"/>
                    <break/>
                  </do_if>
                  <remove_value name="$iscontested"/>
                </do_if>
              </do_if>

              <debug_text text="'%s %s %s refuses to mine in sector %s belonging to %s. has hazardous region: %s. not in gatheringspaces: %s'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $sector.knownname, $sector.owner, $sector.hashazardousregion, not $gatheringspaces.indexof.{$sector}]" chance="$debugchance"/>
              <do_if value="not this.isplayerowned or $singlecluster? or (this.assignedcontrolled.hasblacklist.{blacklisttype.sectoractivity}.{$blacklistgroup} and not $sector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled})">
                <!-- NPC ships will try to mine in a hostile or hazardous region if they have no other choice. player-owned ships will not under any circumstances. -->
                <set_value name="$hostilesector" exact="$sector"/>
                <set_value name="$hostilepos" exact="$pos_sector"/>
              </do_if>
              <remove_value name="$sector"/>
            </do_if>
            <wait min="1ms" max="100ms" comment="Avoid performance peaks with find functions" />
          </do_all>
          <remove_value name="$scaledminamount"/>

          <do_if value="not @$sector.exists and @$hostilesector.exists">
            <debug_text text="'%s %s %s found no safe sector but hostile sector %s owned by %s found. has hazardous region? %s. mining in hostile sector.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $hostilesector.knownname, $hostilesector.owner, $hostilesector.hashazardousregion]" chance="$debugchance"/>
            <set_value name="$sector" exact="$hostilesector"/>
            <set_value name="$pos_sector" exact="$hostilepos"/>
          </do_if>

          <!-- if all else fails, do the old method. this is much more reliable. -->
          <do_if value="@$sector.exists" negate="true">
            <do_if value="@$bestsector.exists">
              <!-- if we have $bestsector from a prior iteration, check that sector first. -->
              <remove_from_list name="$gatheringspaces" exact="$bestsector" multiple="true"/>
              <set_value name="$gatheringspaces.{1}" exact="$bestsector" operation="insert"/>
            </do_if>
            <debug_text text="'Cannot find resource %1 Trying old method. minamount: %2'.[$ware, $minamounts.{$ware}]" chance="$debugchance"/>
            <!-- Find Resouces: Iterate over the gathering spaces -->
            <do_all exact="$gatheringspaces.count" counter="$i">
              <set_value name="$ware" exact="$miningbasket.{$w}" />
              <debug_text text="'now looking for %1 in %2 %3'.[$ware, $gatheringspaces.{$i}.class, $gatheringspaces.{$i}.knownname]" chance="$debugchance" />
              <!-- Find resources -->
              <do_if value="$deepspace">
                <do_if value="$gatheringspaces.{$i}.isclass.cluster">
                  <find_sector name="$clustersectors" space="$gatheringspaces.{$i}" multiple="true"/>
                </do_if>
                <do_elseif value="$gatheringspaces.{$i}.isclass.sector">
                  <set_value name="$clustersectors" exact="[$gatheringspaces.{$i}]"/>
                </do_elseif>
                <do_elseif value="$gatheringspaces.{$i}.sector">
                  <set_value name="$clustersectors" exact="[$gatheringspaces.{$i}.sector]"/>
                </do_elseif>
                <do_else>
                  <debug_text text="'ERROR: gatheringspaces.{$i}: %s %s is neither a cluster, nor a sector, nor something in a sector.'.[$gatheringspaces.{$i}.knownname, $gatheringspaces.{$i}]" filter="error"/>
                </do_else>
                <do_all exact="$clustersectors.count" counter="$j">
                  <run_script name="'lib.find.point.indeepspace'" result="$deepspacepos">
                    <param name="sector" value="$clustersectors.{$j}"/>
                    <param name="allowyaxis" value="true"/>
                  </run_script>
                  <find_closest_resource ware="$ware" refobject="$clustersectors.{$j}" sector="$sector" position="$pos_sector" wares="$secwares">
                    <refposition value="$deepspacepos"/>
                  </find_closest_resource>
                  <do_if value="$sector">
                    <debug_text text="'find method 2. going to position: %s, %s, %s relative to sector %s %s\ndeepspace pos: %s, %s, %s'.[@$pos_sector.x, @$pos_sector.y, @$pos_sector.z, @$sector.knownname, $sector, $deepspacepos.x, $deepspacepos.y, $deepspacepos.z]" chance="$debugchance"/>
                    <break/>
                  </do_if>
                </do_all>
                <remove_value name="$clustersectors"/>
              </do_if>
              <do_elseif value="this.assignedcontrolled.hascontext.{$gatheringspaces.{$i}}">
                <do_if value="this.isplayerowned and this.assignedcontrolled.attention ge attention.visible and $ware.hastag.mineral">
                  <find_asteroid_in_cluster name="$closestasteroid" cluster="this.assignedcontrolled.cluster" refobject="this.assignedcontrolled" canpickup="false" maxdistance="120km" ware="$ware"/>
                  <do_if value="@$closestasteroid.hascontext.{$gatheringspaces.{$i}}">
                    <set_value name="$sector" exact="$closestasteroid.sector"/>
                    <create_position name="$pos_sector" space="$sector" object="$closestasteroid"/>
                    <debug_text text="'4 found %s-bearing asteroid %sm away'.[$ware, this.assignedcontrolled.distanceto.{$closestasteroid}]" chance="$debugchance"/>
                  </do_if>
                  <remove_value name="$closestasteroid"/>
                </do_if>
                <do_if value="not @$sector.exists">
                  <find_closest_resource sector="$sector" position="$pos_sector" ware="$ware" refobject="this.assignedcontrolled" wares="$secwares" useundiscovered="not this.isplayerowned"/>
                  <!--<find_closest_resource ware="$ware" refobject="if $homebase? then $homebase else this.assignedcontrolled" zone="$zone" wares="$secwares"/>-->
                </do_if>
              </do_elseif>
              <do_else>
                <find_closest_resource sector="$sector" position="$pos_sector" wares="$secwares" ware="$ware" refobject="$gatheringspaces.{$i}" useundiscovered="not this.isplayerowned">
                  <refposition value="$gatheringspaces.{$i}.coreposition" object="$gatheringspaces.{$i}" max="$gatheringspaces.{$i}.coresize / 4m"/>
                </find_closest_resource>
              </do_else>
              <!-- Zone found -->
              <do_if value="$sector.exists">
                <do_if value="this.isplayerowned and $gatheringspaces.count == 1">
                  <break/>
                </do_if>
                <debug_text text="'Resource %1 found in %2, %3. old reliable'.[$ware, $sector.knownname, $sector.cluster.knownname]" chance="$debugchance"/>
                <do_if value="$gatheringspaces.indexof.{$sector} and (not $sector.hashazardousregion or $sector.containsthewave or not this.assignedcontrolled.takesregiondamage) and (not $sector.owner or not this.hasrelation.enemy.{$sector.owner}) and (not $sector.policefaction or (this.owner == $sector.policefaction) or not $ware.illegalto.{$sector.policefaction}.{this.owner})">
                  <do_if value="$sector.iscontested">
                    <do_if value="not $sector.contestingfactions.indexof.{this.owner}">
                      <do_for_each name="$locfaction" in="$sector.contestingfactions">
                        <do_if value="$locfaction.mayattack.{this.assignedcontrolled}">
                          <set_value name="$iscontested"/>
                          <break/>
                        </do_if>
                      </do_for_each>
                    </do_if>
                  </do_if>
                  <do_if value="not $iscontested?">
                    <debug_text text="'%s %s %s mining in sector %s belonging to %s. enemy? %s, effective skill: %s, combinedskill: %s'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $sector.knownname, $sector.owner, this.hasrelation.enemy.{$sector.owner}, $effectiveskill, this.assignedcontrolled.combinedskill]" chance="$debugchance"/>
                    <break/>
                  </do_if>
                  <remove_value name="$iscontested"/>
                </do_if>

                <debug_text text="'%s %s %s refuses to mine in sector %s belonging to %s. has hazardous region: %s. not in gatheringspaces: %s'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $sector.knownname, $sector.owner, $sector.hashazardousregion, not $gatheringspaces.indexof.{$sector}]" chance="$debugchance"/>
                <do_if value="not this.isplayerowned or $singlecluster? or (this.assignedcontrolled.hasblacklist.{blacklisttype.sectoractivity}.{$blacklistgroup} and not $sector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled})">
                  <!-- NPC ships will try to mine in a hostile or hazardous region if they have no other choice. player-owned ships will not under any circumstances. -->
                  <set_value name="$hostilesector" exact="$sector"/>
                  <set_value name="$hostilepos" exact="$pos_sector"/>
                </do_if>
                <remove_value name="$sector"/>
              </do_if>
              <wait min="1ms" max="100ms" comment="Avoid performance peaks with find functions" />
            </do_all>

            <do_if value="not @$sector.exists and @$hostilesector.exists">
              <debug_text text="'%s %s %s found no safe sector but hostile sector %s owned by %s found. has hazardous region? %s. mining in hostile sector.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $hostilesector.knownname, $hostilesector.owner, $hostilesector.hashazardousregion]" chance="$debugchance"/>
              <set_value name="$sector" exact="$hostilesector"/>
              <set_value name="$pos_sector" exact="$hostilepos"/>
            </do_if>
          </do_if>

          <!-- Zone found -->
          <do_if value="@$sector.exists">
            <break />
          </do_if>
        </do_all>
        <remove_value name="$baseminamount"/>
        <remove_value name="$freecargo"/>
      </do_if>
      <remove_value name="$bestsector"/>

      <!-- Check the result zone -->
      <do_if value="@$sector.exists">
        <debug_text text="player.age + ' there is %1 in sector %2'.[$ware, $sector.knownname]" chance="$debugchance" />
        <!-- Check the secondary wares vs the warebasket -->
        <do_all exact="$secwares.count" counter="$i" reverse="true">
          <do_if value="(not $miningbasket.indexof.{$secwares.{$i}}) or ($secwares.{$i} == $ware)">
            <remove_value name="$secwares.{$i}" />
          </do_if>
        </do_all>
        <!-- When Mining for commander, make a virtual reservation (to coordinate other miners) -->
        <do_if value="@$homebase.isoperational">
          <!-- min amount of ware. Default: max free space in cargo ship or amount homebase wants, whichever is the smaller value -->
          <set_value name="$minamount" exact="$neededamounts.{$miningbasket.indexof.{$ware}}" />
          <do_if value="$minamount gt this.assignedcontrolled.cargo.{$ware}.free">
            <set_value name="$minamount" exact="this.assignedcontrolled.cargo.{$ware}.free" />
          </do_if>
          <debug_text text="'reserving storage for %s %s'.[$minamount, $ware]" chance="$debugchance"/>
          <!-- virtual reservation -->
          <add_ware_reservation amount="$minamount" type="sell" reserver="this.assignedcontrolled" object="$homebase" duration="5h" virtual="true" ware="$ware" replace="true" />
          <!-- Clear values that are not needed anymore -->
          <remove_value name="$minamount" />
          <remove_value name="$neededamounts" />
        </do_if>
      </do_if>
      <do_else>
        <do_if value="@this.assignedcontrolled.order.isrunning">
          <set_value name="$failurereason" exact="{1045, 105}" comment="No resources found in range."/>
          <do_if value="this.assignedcontrolled.hasblacklist.{blacklisttype.sectoractivity}.{$blacklistgroup} or this.assignedcontrolled.hasblacklist.{blacklisttype.sectortravel}.{$blacklistgroup} or this.assignedcontrolled.hasblacklist.{blacklisttype.objectactivity}.{$blacklistgroup}">
            <set_value name="$failurereason" exact="{1045, 106}" comment="No resources found in allowed sectors."/>
          </do_if>
          <set_order_failed order="this.assignedcontrolled.order" text="$failurereason"/>
          <remove_value name="$failurereason"/>
        </do_if>
        <!-- Debug info: Enable to see the mining ships unable to gather resources on the defined spaces -->
        <do_if value="$debugchance">
          <debug_text text="'%1 %5 %3 %4 Could not find any ware, waiting. Mining basket: %2'.[player.age, $miningbasket, this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled.class]"/>
          <do_all exact="$gatheringspaces.count" counter="$i">
            <debug_text text="'Gathering space #%1: %2 %3 (%4)'.[$i, $gatheringspaces.{$i}.class, $gatheringspaces.{$i}.knownname, $gatheringspaces.{$i}]" />
          </do_all>
        </do_if>
        <!-- Nothing found, idle a while -->
        <run_script name="'move.idle'" >
          <param name="Min" value="50s" />
          <param name="Max" value="70s" />
        </run_script>
        <resume label="loop"/>
      </do_else>

      <debug_text text="'decided to mine %1 in %2, %3. secwares: %4'.[$ware, $sector.knownname, $sector.cluster.knownname, $secwares]" chance="$debugchance"/>

      <label name="movetocollect" />

      <!-- debug_eco - start -->
      <do_if value="this.assignedcontrolled.isclass.ship_m and $ware.hastag.mineral">
        <set_value name="$debug_eco" exact="0"/>
        <set_value name="$time_started" exact="player.age"/>
        <do_if value="this.$time_donemining?">
          <debug_to_file name="'eco_report.csv'" directory="'mining'" text="'%1;travel_from_location;%2;%3;%4;%5'.[player.age, this.assignedcontrolled.knownname, this.assignedcontrolled, this.assignedcontrolled.owner, player.age - this.$time_donemining]" output="$debugchance" chance="$debug_eco"/>
          <remove_value name="this.$time_donemining"/>
        </do_if>
      </do_if>
      <do_else>
        <set_value name="$debug_eco" exact="0"/>
        <set_value name="$time_started" exact="null"/>
      </do_else>

      <!-- move.generic was here. moved to MiningCollect order and call to MiningCollect made an immediate order because SectorChangeHandler was causing this script to reinitialize and potentially change destinations every time the ship changes sectors. -->

      <wait min="1s" max="3s" />

      <label name="collect"/>

      <do_if value="$resourcescout">
        <do_if value="this.sector != $sector or this.assignedcontrolled.distanceto.[$sector, $pos_sector] gt 10km">
          <debug_text text="'going long-distance to %1 relative to %2 %3.'.[$pos_sector, $sector.class, $sector]" chance="$debugchance"/>
          <run_script name="'move.generic'" result="$movesuccess">
            <param name="destination" value="$sector"/>
            <param name="position" value="$pos_sector"/>
            <param name="endintargetzone" value="true"/>
            <param name="debugchance" value="$debugchance" />
          </run_script>
          <do_if value="not $movesuccess">
            <do_if value="@this.assignedcontrolled.order.isrunning">
              <set_order_failed order="this.assignedcontrolled.order" text="{1045, 101}" comment="Unable to reach destination."/>
            </do_if>
            <debug_text text="'Unable to reach destination. Aborting.'" chance="$debugchance"/>
            <resume label="finish"/>
          </do_if>
        </do_if>
        <run_script name="'order.move.recon'">
          <param name="targetspace" value="this.sector"/>
          <param name="targetclasses" value="[class.collectable, class.lockbox]"/>
          <param name="resourcescout" value="true"/>
          <param name="debugchance" value="$debugchance"/>
        </run_script>
        <resume label="loop"/>
      </do_if>

      <do_if value="@this.assignedcontrolled.order.isrunning">
        <clear_order_failure order="this.assignedcontrolled.order"/>
      </do_if>

      <debug_text text="'%s %s %s moving to mine %s in %s %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $ware, $sector.class, $sector.knownname]" chance="$debugchance"/>
      <!-- collecting is done in an external script -->
      <create_order object="this.assignedcontrolled" id="'MiningCollect'" immediate="true">
        <param name="destination" value="[$sector, $pos_sector]"/>
        <param name="ware" value="$ware"/>
        <param name="secwares" value="if $effectiveskill then $secwares else []"/>
        <param name="internalorder" value="not $blacklist_overridebuy?"/>
        <param name="debugchance" value="$debugchance"/>

        <!-- debug_eco -->
        <param name="time_started" value="$time_started"/>
        <param name="debug_eco" value="$debug_eco"/>
      </create_order>
      <!-- very short wait to allow the newly-created order to start and prevent the following logic from needlessly being processed. -->
      <wait exact="1ms" sinceversion="4"/>

      <label name="sellwares" />

      <!-- Initializate the results -->
      <set_value name="$buyoffers" exact="[]" />
      <set_value name="$failurereason" exact="null"/>
      <!-- Mining for commander -->
      <do_if value="@$homebase.isoperational">

        <do_if value="this.assignedcontrolled.cargo.count">
          <!-- NB: we are always allowed to operate in our commander's sector regardless of blacklist. -->
          <debug_text text="player.age + ' checking if we can sell our current cargo to our homebase'" chance="$debugchance" />
          <find_buy_offer result="$buyoffers" tradepartner="this.assignedcontrolled" buyer="$homebase" wares="this.assignedcontrolled.cargo.list" multiple="true"/>
          <do_if value="$homebase.sector.isblacklisted.{blacklisttype.sectoractivity}.{$blacklistgroup}.{this.assignedcontrolled} or $homebase.sector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled}">
            <set_value name="$blacklist_overridesell"/>
          </do_if>
          <do_if value="true" chance="$debugchance">
            <debug_text text="'%s %s %s, working for %s %s %s found %s buyoffers'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $homebase.idcode, $homebase.knownname, $homebase, $buyoffers.count]"/>
            <do_all exact="$buyoffers.count" counter="$i">
              <debug_text text="'ware: %s, desired amount: %s, offer amount: %s, amount: %s'.[$buyoffers.{$i}.ware, $buyoffers.{$i}.desiredamount, $buyoffers.{$i}.offeramount.{this.assignedcontrolled}, $buyoffers.{$i}.amount]"/>
            </do_all>
          </do_if>
        </do_if>
      </do_if>
      <!-- Free miner -->
      <do_else>
        <!-- Find normal trade -->
        <run_script name="'trade.find.free'">
          <param name="warebasket" value="$warebasket" />
          <param name="range" value="$range" />
          <param name="sellspaces" value="$sellspaces.clone" comment="pass a copy so it can be modified on the find script"/>
          <param name="sellcurrentcargo" value="true"/>
          <param name="debugchance" value="$debugchance"/>
          <param name="debugchance2" value="$debugchance2"/>
          <save_retval name="buyoffer" variable="$buyoffer" />
          <save_retval name="failurereason" variable="$failurereason"/>
        </run_script>
        <set_value name="$buyoffers" exact="[$buyoffer]"/>
      </do_else>

      <do_if value="(this.assignedcontrolled.order.id == 'MiningRoutine') or (this.assignedcontrolled.order.id == 'MiningRoutine_Basic') or (this.assignedcontrolled.order.id == 'MiningRoutine_Advanced') or (this.assignedcontrolled.order.id == 'MiningRoutine_Expert')">
        <!-- NB: order will not be interrupted until after a blocking action is hit so, if a trade order is to be added and this order is to be interrupted, the trade order will be added first. -->
        <set_order_syncpoint_reached order="this.assignedcontrolled.order"/>
      </do_if>

      <do_if value="@this.assignedcontrolled.order.isrunning">
        <do_if value="$buyoffers.count">
          <clear_order_failure order="this.assignedcontrolled.order"/>
        </do_if>
        <do_else>
          <do_if value="not @$failurereason">
            <set_value name="$failurereason" exact="{1045, 107}" comment="No buyers found in range."/>
            <do_if value="this.assignedcontrolled.hasblacklist.{blacklisttype.sectoractivity}.{$blacklistgroup} or this.assignedcontrolled.hasblacklist.{blacklisttype.sectortravel}.{$blacklistgroup} or this.assignedcontrolled.hasblacklist.{blacklisttype.objectactivity}.{$blacklistgroup}">
              <set_value name="$failurereason" exact="{1045, 108}" comment="No buyers found in allowed sectors."/>
            </do_if>
          </do_if>
          <!-- NB: this used to depend on @this.assignedcontrolled.order.isrunning no longer being true if $tradeorder is successfully created. -->
          <set_order_failed order="this.assignedcontrolled.order" text="$failurereason"/>
        </do_else>
      </do_if>
      <remove_value name="$failurereason"/>

      <do_for_each name="$buyoffer" in="$buyoffers">
        <!-- For the buyoffer (I sell) -->
        <set_value name="$buyofferamount" exact="if $buyoffer.available then $buyoffer.offeramount.{this.assignedcontrolled} else 0"/>
        <do_if value="$buyofferamount">
          <!-- I want to sell after gathering resources, I limit what I want to sell to what I gathered (selloffer-offer amount of this) -->
          <clamp_trade_amount trade="$buyoffer" seller="this.assignedcontrolled" amount="$buyofferamount" buyer="$buyoffer.buyer" result="$amount"/>

          <debug_text text="'clamped amount: %s, buyoffer amount: %s, buyoffer desiredamount: %s, amount in hold: %s\ntrade price: %s, station cash: %s'.[$amount, $buyofferamount, $buyoffer.desiredamount, this.assignedcontrolled.cargo.{$buyoffer.ware}.count, ($amount * $buyoffer.unitprice).formatted.default, $buyoffer.buyer.money.formatted.default]" chance="$debugchance"/>
          <!-- Add sell trade perform (if available) => This object sells (create_trade_order adds the reservation automatically) -->
          <do_if value="$amount">
            <!-- cache values as $buyoffer may no longer be an offer after a trade order has been created from it, make sure we still know the relevant bits for removing any virtual reservations for that ware -->
            <set_value name="$resource_buyer" exact="$buyoffer.buyer"/>
            <set_value name="$resource_ware" exact="$buyoffer.ware"/>
            <debug_text text="'creating trade order to sell %1 %2 to %3 (%4, %5) for %6Cr'.[$amount, $resource_ware, $resource_buyer.knownname, $resource_buyer, $resource_buyer.idcode, ($amount * $buyoffer.unitprice).formatted.default]" chance="$debugchance" />
            <create_trade_order name="$tradeorder" object="this.object" tradeoffer="$buyoffer" amount="$amount" internal="not $blacklist_overridesell?" immediate="true"/>
            <!-- if we are now actually selling, remove any virtual reservation for this ware as we have a real one as part of the trade order -->
            <remove_ware_reservation object="$resource_buyer" reserver="this.assignedcontrolled" type="sell" virtual="true" ware="$resource_ware"/>
            <remove_value name="$resource_buyer" />
            <remove_value name="$resource_ware" />
          </do_if>
          <!-- if a trade order has been made, move.idle should be interrupted as soon as it hits a blocking action. -->
          <set_value name="$idle"/>
        </do_if>
      </do_for_each>

      <!-- if we have wares that cannot be sold, just dump them -->
      <do_if value="not @$tradeorder.exists">
        <do_if value="this.assignedcontrolled.cargo.count">
          <do_if value="not this.isplayerowned">
            <do_all exact="$warebasket.count" counter="$i">
              <set_value name="$possibleware" exact="$warebasket.{$i}"/>
              <set_value name="$maxamount" exact="this.assignedcontrolled.cargo.{$possibleware}.max"/>
              <!-- Drop cargo -->
              <do_if value="$maxamount">
                <drop_cargo object="this.assignedcontrolled" ware="$possibleware" min="($maxamount * 0.1f)i" max="($maxamount * 0.2f)i" amounts="$droppedamounts" wares="$droppedwares"/>
                <do_all exact="$droppedwares.count" counter="$d" chance="$debugchance">
                  <debug_text text="'%1 (%2) dropped %3 %4 because that ware is unsellable in %5'.[this.assignedcontrolled.knownname, this.assignedcontrolled, $droppedamounts.{$d}, $droppedwares.{$d}, this.cluster.knownname]"/>
                </do_all>
              </do_if>
            </do_all>
            <remove_value name="$possibleware" />
            <remove_value name="$maxamount" />
            <remove_value name="$droppedwares" />
          </do_if>
          <do_elseif value="this.assignedcontrolled.cargo.free.all">
            <set_value name="$cannotsell"/>
          </do_elseif>
          <set_value name="$idle"/>
        </do_if>
      </do_if>
      <remove_value name="$buyofferamount" />

      <do_if value="$idle?">
        <remove_value name="$idle"/>
        <!-- command action -->
        <set_command_action commandaction="commandaction.calculating" />

        <run_script name="'move.idle'" >
          <param name="Min" value="10s" />
          <param name="Max" value="40s" />
        </run_script>
      </do_if>

      <!-- No offer found, restart -->
      <do_if value="not @this.assignedcontrolled.isjobship or not this.assignedcontrolled.jobexpired">
        <resume label="loop" />
      </do_if>

      <label name="finish" />

      <do_if value="@$homebase.isoperational">
        <!-- clean up any virtual reservation we may have made if this script ends (as opposed to going into a subscript) -->
        <remove_ware_reservation object="$homebase" reserver="this.assignedcontrolled" type="sell" virtual="true"/>
      </do_if>

      <do_if value="$failreason?">
        <do_if value="@$sector and @$pos_sector">
          <debug_text text="'script ends with reason %1. Looking to gather %4 for job \'%5\'. This ship %2 m away from destination, destination %3'.[$failreason, this.assignedcontrolled.distanceto.[$sector, $pos_sector], $sector.knownname, @$warebasket, this.assignedcontrolled.job]"/>
        </do_if>
        <do_else>
          <debug_text text="'script ends with reason %s. Looking to gather %s for job \'%s\'.'.[$failreason, @$warebasket, this.assignedcontrolled.job]"/>
        </do_else>
      </do_if>
      <do_if value="$failreason2?">
        <debug_text text="$failreason2" />
      </do_if>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.assignedcontrolled.jobexpired">
        <debug_text text="'%1 doing job %2 has expired, die!'.[this.assignedcontrolled.knownname, this.assignedcontrolled.job]" chance="$debugchance" />
        <create_order object="this.assignedcontrolled" id="'MoveDie'" immediate="true">
          <param name="byhighway" value="not this.assignedcontrolled.isclass.[class.ship_l, class.ship_xl]" />
        </create_order>
      </do_if>

    </actions>
  </attention>
  <on_abort>
    <do_if value="@$homebase.isoperational and this.assignedcontrolled.isoperational and $thisorder? and not @$thisorder.exists">
      <debug_text text="'on_abort: removing ware reservation. current order: %s, this order exists: %s'.[@this.assignedcontrolled.order.id, $thisorder.exists]" chance="$debugchance"/>
      <!-- clean up any virtual reservation we may have made if this script is aborted -->
      <remove_ware_reservation object="$homebase" reserver="this.assignedcontrolled" type="sell" virtual="true"/>
    </do_if>
    <do_if value="$duration and @$tradeorder.exists and @$thisorder.exists">
      <!-- do not reduce duration to 0s since that would make the order infinite. -->
      <debug_text text="'on_abort: updating duration from %s to %s'.[$duration, $duration - [(player.age - $time_start), $duration - 1s].min]" chance="$debugchance"/>
      <edit_order_param order="$thisorder" param="'duration'" value="[$duration - (player.age - $time_start), 1s].max"/>
    </do_if>
  </on_abort>
</aiscript>
