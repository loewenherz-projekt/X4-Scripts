<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="fight.attack.object.capital" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="34">
  <!--
  Fight attack object capital
  by Adrian
  Defense/Attack mode of a capital ship (made by defense npc), to attack enemys/targets in weapon range.
  This ship reacts to attacks and attempt to defend itself.
    - Defense Mode
      - Hold Fire Mode (Withdraw from Battle)
    - Attack Mode
  -->
  <params>
    <param name="debugchance" default="0"/>
  </params>
  <interrupts>
    <library>
      <actions name="CapitalLaunchFighters">
        <do_if value="$iscarrier">
          <do_if value="@$closestthreat.exists and (not $closestthreat.canbeattacked or not this.assignedcontrolled.mayattack.{$closestthreat})">
            <debug_text text="'closest threat %s is no longer a valid threat. cleaning up.'.[@$closestthreat.debugname]" chance="$debugchance"/>
            <remove_value name="$closestthreat"/>
          </do_if>

          <do_if value="not this.ship.subordinates.count">
            <debug_text text="'%s has no more subordinates. skipping carrier calculations.'.[this.ship.debugname]" chance="$debugchance"/>
            <set_value name="$iscarrier" exact="false"/>
          </do_if>
          <do_elseif value="@this.ship.pilot.$escortgroup.count">
            <!-- scramble sends everything we have. so if we scramble, no point doing carrier attack. prohibit if we are actively attacking a target. -->
            <do_if value="@$closestthreat.canbeattacked and (this.assignedcontrolled.distanceto.{$closestthreat} lt $criticalrange) and not @$primarytarget.canbeattacked">
              <debug_text text="player.age + ': %s scrambling all fighters to attack %s.'.[this.ship.debugname, @$closestthreat.debugname]" chance="$debugchance"/>
              <signal_objects object="this.ship" param="$closestthreat" param2="'carrier scramble'"/>
              <add_to_group groupname="$dronetargets" object="$closestthreat"/>
              <remove_value name="$closestthreat"/>
            </do_if>
            <do_else>
              <debug_text text="player.age + ': %s signalling carrier attack.'.[this.ship.debugname]" chance="$debugchance"/>
              <!-- target list here is different from the initial one we went over. this one includes the surface elements of the primary target, if one is designated. -->
              <do_if value="@this.ship.pilot.$escortgroup.count">
                <!-- try to deploy all direct subordinates against everything in our target list. -->
                <set_value name="$availableships" exact="this.ship.pilot.$escortgroup.list"/>
                <shuffle_list list="$availableships"/>

                <!-- reorder the targetlist. primarytarget, if defined, at the front of the list; subcomponents of primarytarget, if acquired, next, then everything else. -->
                <set_value name="$loctargetlist" exact="[]"/>
                <set_value name="$templist" exact="$targets.list"/>
                <do_if value="@$primarytarget.canbeattacked">
                  <set_value name="$evaltarget" exact="$primarytarget"/>
                  <include_interrupt_actions ref="ValidateTableTargets"/>
                  <remove_value name="$evaltarget"/>
                  <do_if value="@$table_targets.{$primarytarget}.count">
                    <append_list_elements name="$loctargetlist" other="$table_targets.{$primarytarget}"/>
                  </do_if>
                  <do_else>
                    <do_if value="@$primarytarget.ismodular">
                      <append_to_list name="$loctargetlist" exact="$primarytarget"/>
                    </do_if>
                    <set_value name="$evaltarget" exact="$primarytarget"/>
                    <include_interrupt_actions ref="SelectTargets_High"/>
                    <do_if value="@$resulttargets.count">
                      <append_list_elements name="$loctargetlist" other="$resulttargets"/>
                    </do_if>
                    <remove_value name="$resulttargets"/>
                    <remove_value name="$evaltarget"/>
                  </do_else>
                  <remove_from_list name="$templist" list="$loctargetlist" multiple="true"/>
                </do_if>
                <append_list_elements name="$loctargetlist" other="$templist"/>
                <remove_value name="$templist"/>

                <debug_text text="'%s sending %s ships against %s targets.'.[@this.assignedcontrolled.debugname, $availableships.count, $loctargetlist.count]" chance="$debugchance"/>
                <!-- send fighters to attack acquired targets. -->
                <do_all exact="$loctargetlist.count" counter="$interruptcounter">
                  <set_value name="$loctarget" exact="$loctargetlist.{$interruptcounter}"/>
                  <do_if value="$availableships.count">
                    <do_if value="$loctarget.canbeattacked and (not @$engagedcarriertargets.indexof.{$loctarget} or ($loctarget == @$primarytarget) or (@$primarytarget.canbeattacked and @$loctarget.hascontext.{$primarytarget}))">
                      <do_if value="@$loctarget.iscapitalship or @$loctarget.ismodular or @$loctarget.canhaveattackablemodules">
                        <set_value name="$interceptorclass" exact="[class.ship_m, class.ship_l, class.ship_xl]"/>
                        <!-- NB: numsend is the number of ships to send against $loctarget. -->
                        <set_value name="$numsend" exact="1"/>
                      </do_if>
                      <!-- this should include surface elements. -->
                      <do_else>
                        <set_value name="$interceptorclass" exact="[class.ship_s, class.ship_m]"/>
                        <set_value name="$numsend" min="1" max="[this.ship.pilot.$escortgroup.count * 0.2, 1].max"/>
                      </do_else>
                      <do_if value="@$primarytarget.canbeattacked and (($loctarget == $primarytarget) or ($loctarget.hascontext.{$primarytarget}))">
                        <set_value name="$prenumsend" chance="$debugchance"/>
                        <set_value name="$numsend" exact="$numsend * [this.assignedcontrolled.combinedskill / 20, 1].max"/>
                        <debug_text text="'target %s is the primary target or is connected to the primary target. increasing force from %s to %s.'.[@$loctarget.debugname, $prenumsend, $numsend]" chance="$debugchance"/>
                        <remove_value name="$prenumsend"/>
                      </do_if>
                      <debug_text text="'trying to send %s ships against %s.'.[[$availableships.count, $numsend].min, @$loctarget.debugname]" chance="$debugchance"/>

                      <!-- we will still launch fighters against surface elements, just not against entire big targets. -->
                      <do_all exact="$availableships.count" counter="$interruptcounter2" reverse="true">
                        <set_value name="$locsub" exact="$availableships.{$interruptcounter2}"/>
                        <do_if value="$numsend gt 0">
                          <do_if value="not $locsub.subordinategroupdockoverride and $locsub.isclass.{$interceptorclass} and ($locsub.assignment != assignment.interception or ($loctarget.isclass.ship and not $loctarget.iscapitalship))">
                            <do_if value="$debugchance">
                              <set_value name="$debug_interceptor" exact="$locsub"/>
                              <debug_text text="player.age + ': %s sending %s after %s.'.[this.ship.debugname, $debug_interceptor.debugname, @$loctarget.debugname]"/>
                              <remove_value name="$debug_interceptor"/>
                            </do_if>
                            <signal_objects object="$locsub" param="$loctarget" param2="'carrier attack'"/>
                            <add_to_group groupname="$engagedcarriertargets" object="$loctarget"/>
                            <remove_value name="$locsub"/>
                            <set_value name="$numsend" exact="$numsend - 1"/>
                          </do_if>
                        </do_if>
                        <do_else>
                          <break/>
                        </do_else>
                      </do_all>
                      <remove_value name="$locsub"/>
                      <remove_value name="$numsend"/>
                      <remove_value name="$interceptorclass"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'target %s is either no longer operational or already being engaged.'.[@$loctarget.debugname]" chance="$debugchance"/>
                    </do_else>
                  </do_if>
                  <do_else>
                    <break/>
                  </do_else>
                </do_all>
                <remove_value name="$loctarget"/>
                <remove_value name="$loctargetlist"/>
                <remove_value name="$availableships"/>
              </do_if>
            </do_else>
          </do_elseif>
        </do_if>
      </actions>
      <actions name="CanLaunchDrones">
        <!-- caller must clean this up -->
        <set_value name="$canlaunchdrones" exact="not this.zone.isclass.highway and not this.assignedcontrolled.travel.active"/>
      </actions>
      <actions name="LaunchDrone_OreCollector">
        <!-- requires list $pickuptargets_solid -->
        <include_interrupt_actions ref="CanLaunchDrones"/>
        <do_if value="@$pickuptargets_solid.count and $canlaunchdrones and this.assignedcontrolled.hasarmedminingdrones">
          <do_all exact="$pickuptargets_solid.count" counter="$interruptcounter" reverse="true">
            <do_if value="$pickuptargets_solid.{$interruptcounter}.isclass.asteroid and $pickuptargets_solid.{$interruptcounter}.canbepickedup and not $pickuptargets_solid.{$interruptcounter}.container and not $pickuptargets_solid.{$interruptcounter}.owner and this.assignedcontrolled.availableunits.{unitcategory.orecollector}.count">
              <set_owner object="$pickuptargets_solid.{$interruptcounter}" faction="this.assignedcontrolled.owner"/>
              <launch_drone name="$locdrone" object="this.assignedcontrolled" category="unitcategory.orecollector" exact="1"/>
              <do_if value="$locdrone.isoperational">
                <add_to_group groupname="$group_launchedminingdrones" object="$locdrone"/>
                <start_script name="'mining.collect.drone'" object="$locdrone.pilot">
                  <param name="homebase" value="this.assignedcontrolled"/>
                  <param name="target" value="$pickuptargets_solid.{$interruptcounter}"/>
                  <param name="debugchance" value="$debugchance"/>
                </start_script>
              </do_if>
              <debug_text text="'%s sending %s to pick up %s %s. already picked up? %s'.[@this.assignedcontrolled.debugname, @$locdrone.debugname, @$pickuptargets_solid.{$interruptcounter}.knownname, $pickuptargets_solid.{$interruptcounter}, $pickuptargets_solid.{$interruptcounter}.ship]" chance="$debugchance"/>
              <remove_value name="$locdrone"/>
            </do_if>
          </do_all>
        </do_if>
        <remove_value name="$pickuptargets_solid"/>
        <remove_value name="$canlaunchdrones"/>
      </actions>
      <actions name="LaunchDrone_GasCollector">
        <!-- requires list $locwares -->
        <include_interrupt_actions ref="CanLaunchDrones"/>
        <do_if value="@$locwares and $canlaunchdrones and this.assignedcontrolled.hasarmedminingdrones">
          <find_closest_resource wares="$locresultwares" zone="$loczone" position="$loczonepos" ware="$locwares" refobject="this.assignedcontrolled"/>
          <do_if value="$loczone == this.zone">
            <do_all exact="this.assignedcontrolled.availableunits.{unitcategory.gascollector}.count">
              <shuffle_list list="$locwares"/>
              <do_all exact="$locwares.count" counter="$interruptcounter">
                <do_if value="$locresultwares.indexof.{$locwares.{$interruptcounter}}">
                  <set_value name="$locware" exact="$locwares.{$interruptcounter}"/>
                  <break/>
                </do_if>
              </do_all>
              <do_if value="@$locware">
                <launch_drone name="$locdrone" object="this.assignedcontrolled" category="unitcategory.gascollector" exact="1"/>
                <do_if value="$locdrone.isoperational">
                  <add_to_group groupname="$group_launchedminingdrones" object="$locdrone"/>
                  <start_script name="'mining.collect.drone'" object="$locdrone.pilot">
                    <param name="homebase" value="this.assignedcontrolled"/>
                    <param name="ware" value="$locware"/>
                  </start_script>
                  <debug_text text="'%s sending %s to harvest %s.'.[@this.assignedcontrolled.debugname, @$locdrone.debugname, $locware]" chance="$debugchance"/>
                </do_if>
              </do_if>
              <remove_value name="$locdrone"/>
              <remove_value name="$locware"/>
            </do_all>
          </do_if>
          <remove_value name="$locresultwares"/>
          <remove_value name="$loczonepos"/>
          <remove_value name="$loczone"/>
        </do_if>
        <remove_value name="$locwares"/>
        <remove_value name="$canlaunchdrones"/>
      </actions>
      <actions name="LaunchDrone_Transport">
        <!-- requires list $pickuptargets_container -->
        <include_interrupt_actions ref="CanLaunchDrones"/>
        <do_if value="@$pickuptargets_container.count and $canlaunchdrones and this.assignedcontrolled.hasarmedtransportdrones">
          <do_all exact="$pickuptargets_container.count" counter="$interruptcounter" reverse="true">
            <do_if value="$pickuptargets_container.{$interruptcounter}.isclass.collectable and $pickuptargets_container.{$interruptcounter}.canbepickedup and not $pickuptargets_container.{$interruptcounter}.container and not $pickuptargets_container.{$interruptcounter}.owner and this.assignedcontrolled.availableunits.{unitcategory.transport}.count">
              <set_owner object="$pickuptargets_container.{$interruptcounter}" faction="this.assignedcontrolled.owner"/>
              <launch_masstraffic_drone name="$locdrone" object="this.assignedcontrolled" category="unitcategory.transport" pickup="true" target="$pickuptargets_container.{$interruptcounter}"/>
              <do_if value="$locdrone.isoperational">
                <add_to_group groupname="$group_launchedtransportdrones" object="$locdrone"/>
                <start_script name="'move.collect.drone'" object="$locdrone.pilot">
                  <param name="homebase" value="this.assignedcontrolled"/>
                  <param name="target" value="$pickuptargets_container.{$interruptcounter}"/>
                  <param name="masstraffic" value="true"/>
                  <param name="stayactive" value="false" comment="deactivate animation after picked up"/>
                  <param name="debugchance" value="$debugchance"/>
                </start_script>
                <debug_text text="'%s sending %s to pick up %s %s.'.[@this.assignedcontrolled.debugname, @$locdrone.debugname, @$pickuptargets_container.{$interruptcounter}.knownname, $pickuptargets_container.{$interruptcounter}]" chance="$debugchance"/>
                <remove_value name="$locdrone"/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        <remove_value name="$pickuptargets_container"/>
        <remove_value name="$canlaunchdrones"/>
      </actions>
    </library>
    <handler comment="Self defense" consume="false">
      <conditions>
        <check_any>
          <event_object_attacked object="this.ship"/>
          <check_all>
            <event_contained_object_relation_range_changed group="$sectorgrp" faction="faction.player"/>
            <check_value value="this.isplayerowned"/>
            <check_value value="not faction.player.mayattack.{event.param.owner}"/>
            <check_value value="this.assignedcontrolled.cansee.{event.param}"/>
            <debug_text text="'target acquired.\was already hostile: %s\nfaction match: %s\n%s\nengaging %s'.[this.assignedcontrolled.trueowner.mayattack.{event.param.owner}, event.param2 == this.assignedcontrolled.trueowner, this.assignedcontrolled.debugname, event.param.debugname]" debugchance="0"/>
          </check_all>
        </check_any>
        <check_value value="event.param.isoperational"/>
        <check_value value="not @this.assignedcontrolled.order.$noattackresponse"/>
        <check_value value="this.ship.mayattack.{event.param}" comment="check relation of ship (not defense NPC)" />
        <check_value value="not $disabletargets.indexof.{event.param}" comment="do not reacquire targets set to be disabled"/>
        <check_any>
          <!-- stations are never in $attackers since $station cannot be shot in high attention. -->
          <check_value value="not @$attackers.indexof.{event.param}" comment="Is not in the attackers group"/>
          <!-- best to check $targets_defensibles since that implicitly removes entries that have been destroyed. -->
          <check_value value="@event.param.ismodular and not $targets_defensibles.indexof.{event.param}"/>
        </check_any>
      </conditions>
      <actions>
        <set_value name="$evaltarget" exact="event.param"/>
        <include_interrupt_actions ref="AcquireTarget"/>
        <do_if value="@$resulttargets_high.count">
          <add_to_group groupname="$attackers" group="$resulttargets_high"/>
          <do_if value="($defencedronemode == dronemode.defend) or ($defencedronemode == dronemode.attackenemies)">
            <add_to_group groupname="$dronetargets" group="$resulttargets_high"/>
          </do_if>
        </do_if>
        <remove_value name="$resulttargets_high"/>
        <remove_value name="$resulttarget_low"/>
        <remove_value name="$evaltarget"/>
        <debug_text text="'Self defense. Attacker: %1. attackers %2'.[event.param, $attackers]" chance="$debugchance" />
        <abort_called_scripts resume="Attack" />
      </actions>
    </handler>
    <handler comment="Boarding pods launched nearby" consume="false">
      <conditions>
        <event_gravidar_has_scanned object="this.ship"/>
        <check_value value="this.sector"/>
        <count_gravidar_contacts result="$boardingpods_nearby" object="this.ship" excluded="$attackers" macro="param.boarding.boardingpodmacro" maybeattackedby="this.ship" functional="true" multiple="true">
          <!-- do not detect pods that are attached to objects -->
          <match_parent class="class.zone">
            <match_parent macro="this.sector.macro"/>
          </match_parent>
        </count_gravidar_contacts>
      </conditions>
      <actions>
        <debug_text text="'%s detected %s hostile boarding pods.'.[this.ship.debugname, $boardingpods_nearby.count]" chance="$debugchance"/>
        <do_for_each name="$evaltarget" in="$boardingpods_nearby">
          <include_interrupt_actions ref="AcquireTarget"/>
          <do_if value="@$resulttargets_high.count">
            <add_to_group groupname="$attackers" group="$resulttargets_high"/>
            <do_if value="($defencedronemode == dronemode.defend) or ($defencedronemode == dronemode.attackenemies)">
              <add_to_group groupname="$dronetargets" group="$resulttargets_high"/>
            </do_if>
          </do_if>
          <remove_value name="$resulttargets_high"/>
          <remove_value name="$resulttarget_low"/>
        </do_for_each>
        <debug_text text="'We are being boarded. %s boarding pods detected. Attackers %s'.[$boardingpods_nearby.count, $attackers]" chance="$debugchance"/>
        <abort_called_scripts resume="Attack" />
      </actions>
    </handler>
    <handler comment="Missile defense" consume="false">
      <conditions>
        <event_object_incoming_missile object="this.ship" />
        <check_value value="this.ship.mayattack.{event.param3}" comment="check relation of ship (not defense NPC)" />
        <check_value value="not @$incomingmissiles.indexof.{event.param2}" comment="Is not in the incomingmissiles group" />
        <check_value value="event.param2.isoperational"/>
      </conditions>
      <actions>
        <do_if value="event.param2.isoperational">
          <add_to_group groupname="$incomingmissiles" object="event.param2" comment="missile"/>
          <do_if value="event.param2.isformationleader">
            <do_for_each name="$locmissile" in ="event.param2.currentformationwingmen">
              <add_to_group groupname="$incomingmissiles" object="$locmissile" comment="missile"/>
            </do_for_each>
          </do_if>
          <do_if value="$defencedronemode == dronemode.missiledefence">
            <add_to_group groupname="$dronetargets" group="$incomingmissiles"/>
          </do_if>

          <do_if value="event.param3.canbeattacked and not $disabletargets.indexof.{event.param3}">
            <set_value name="$evaltarget" exact="event.param3" comment="missile source"/>
            <include_interrupt_actions ref="AcquireTarget"/>
            <do_if value="@$resulttargets_high.count">
              <add_to_group groupname="$attackers" group="$resulttargets_high"/>
              <do_if value="($defencedronemode == dronemode.defend) or ($defencedronemode == dronemode.attackenemies)">
                <add_to_group groupname="$dronetargets" group="$resulttargets_high"/>
              </do_if>
            </do_if>
            <remove_value name="$resulttargets_high"/>
            <remove_value name="$resulttarget_low"/>
            <remove_value name="$evaltarget"/>
          </do_if>
          <debug_text text="'Missile defense. new incoming missile: %s. attacker %s %s'.[@event.param2.debugname, @event.param3.class, @event.param3.debugname]" chance="$debugchance" />
          <abort_called_scripts resume="Attack" />
        </do_if>
      </actions>
    </handler>
    <!-- NB: do not forget to clear $disabletargets by sending this signal with param2 null. otherwise, if this ship later meets a target in the disabletarget list, it will still only try to disable that target. -->
    <handler comment="attack signals. if param3.{4} is provided, these targets will be disabled. clears the group of targets to disable and repopulates with with the contents of param3.{4}. event.param3.{9} simply redirects the script to label Start without changing anything." consume="false">
      <conditions>
        <event_object_signalled object="this" param="'attack'" comment="param2 is target, param3 is [$secondarytargets, $allowothertargets, $checkrelation, $disabletargets, $disablehullpercentagethreshold, $behaviortargetclasses, $aimtarget, $shootindestructible, forcereset(bool)]"/>
        <check_any>
          <check_value value="not event.param2 or @$primarytarget != event.param2 or @$secondarytargets != @event.param3.{1}"/>
          <check_value value="@event.param3.{9}"/>
        </check_any>
      </conditions>
      <actions>
        <debug_text text="'event %1, param %2, param2 %3, param3 %4'.[@event.name, @event.param, @event.param2, @event.param3]" chance="$debugchance" />

        <do_if value="not @event.param3.{9}">
          <!-- Attack -->
          <do_if value="event.param2">
            <do_if value="@event.param3.{4}.count">
              <set_value name="$disablehullpercentagethreshold" exact="if @event.param3.{5} then event.param3.{5} else 20"/>
              <clear_group group="$disabletargets"/>
              <do_for_each name="$loctarget" in="event.param3.{4}">
                <do_if value="$loctarget.exists">
                  <do_if value="not $loctarget.isclass.defensible and $loctarget.defensible and not $disabletargets.indexof.{$loctarget.defensible} and $loctarget.defensible.canbeattacked">
                    <debug_text text="'registering target.defensible %s %s in disabletargets.'.[@$loctarget.defensible.debugname, $loctarget.defensible]" chance="$debugchance"/>
                    <add_to_group groupname="$disabletargets" object="$loctarget.defensible"/>
                  </do_if>
                  <do_if value="$loctarget.canbeattacked and not $disabletargets.indexof.{$loctarget}">
                    <add_to_group groupname="$disabletargets" object="$loctarget"/>
                    <debug_text text="'disabling target %s'.[@$loctarget.debugname]" chance="$debugchance"/>
                  </do_if>
                  <do_else>
                    <debug_text text="'unable to attack disabletarget %s'.[@$loctarget.debugname]" chance="$debugchance"/>
                  </do_else>
                </do_if>
              </do_for_each>
              <set_value name="$behaviortargetclasses" exact="if @event.param3.{6} then event.param3.{6} else []"/>
            </do_if>

            <!-- main target -->
            <do_if value="event.param2 != -1">
              <set_value name="$primarytarget" exact="event.param2" comment="if main target is null, means to stop fire"/>
            </do_if>
            <do_if value="event.param3.{1} != -1">
              <set_value name="$secondarytargets" exact="event.param3.{1}"/>
            </do_if>
            <!-- Additional parameters -->
            <do_if value="event.param3.{2} != -1">
              <set_value name="$allowothertargets" exact="event.param3.{2}"/>
            </do_if>
            <do_if value="event.param3.{3} != -1">
              <set_value name="$checkrelation" exact="event.param3.{3}"/>
            </do_if>
            <!-- $aimtarget is whatever the pilot says they're aiming at. only used if $primarytarget is a station. -->
            <do_if value="@event.param3.{7} != -1">
              <set_value name="$aimtarget" exact="@event.param3.{7}"/>
            </do_if>
            <do_elseif value="not @$aimtarget">
              <set_value name="$aimtarget" exact="$primarytarget"/>
            </do_elseif>
            <do_if value="@event.param3.{8} != -1">
              <set_value name="$shootindestructible" exact="@event.param3.{8}"/>
            </do_if>
          </do_if>
          <!-- Stop Attack -->
          <do_else>
            <clear_group group="$disabletargets"/>

            <!-- Clear attack variables -->
            <clear_group group="$targets" />
            <clear_group group="$targets_defensibles"/>
            <clear_group group="$targets_capital"/>
            <clear_group group="$targets_fighters"/>
            <clear_group group="$attackers" />
            <clear_group group="$miningtargets"/>
            <clear_table table="$table_targets"/>
            <remove_value name="$primarytarget" />
            <remove_value name="$secondarytargets" />
            <remove_value name="$allowothertargets" />
            <remove_value name="$closestthreat"/>
            <remove_value name="$behaviortargetclasses"/>
            <remove_value name="this.$combat_obstructiondelay"/>
            <set_value name="$checkrelation" exact="$default_checkrelation"/>
            <remove_value name="$aimtarget"/>
            <remove_value name="$shootindestructible"/>
          </do_else>

          <!-- Tell to subordinates to attack -->
          <set_value name="$subordinates" exact="this.ship.subordinates" />
          <do_all exact="$subordinates.count" counter="$interruptcounter" >
            <do_if value="$subordinates.{$interruptcounter}.defencenpc.exists">
              <debug_text text="'attack to %1. allowothertargets %2'.[$subordinates.{$interruptcounter}.defencenpc, @$allowothertargets]" chance="$debugchance" />
              <signal_objects object="$subordinates.{$interruptcounter}.defencenpc" param="event.param" param2="event.param2" param3="event.param3" />
            </do_if>
          </do_all>
          <remove_value name="$subordinates" />
        </do_if>

        <abort_called_scripts resume="Start" />
      </actions>
    </handler>
    <handler comment="weaponmode changed" consume="false">
      <conditions>
        <event_object_weaponmode_changed object="this.ship" />
      </conditions>
      <actions>
        <debug_text text="'event_object_weaponmode_changed %1, %2'.[@event.param, @event.param2]" chance="$debugchance" />
        <!-- Update turret modes again -->
        <set_value name="$weapons_all" exact="this.ship.turrets.operational.list" />
        <create_list name="$turretmodes" />
        <do_all exact="$weapons_all.count" counter="$interruptcounter">
          <do_if value="not $turretmodes.indexof.{$weapons_all.{$interruptcounter}.mode}">
            <append_to_list name="$turretmodes" exact="$weapons_all.{$interruptcounter}.mode"/>
          </do_if>
        </do_all>
        <remove_value name="$weapons_all" />

        <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
          <do_if value="player.target and this.assignedcontrolled.mayattack.{player.target}">
            <do_if value="player.target.canbeattacked and player.target.sector and (player.target.sector == this.sector)">
              <debug_text text="'setting autoassist turrets to fire upon target: %s %s %s'.[@player.target.idcode, @player.target.knownname, player.target]" chance="$debugchance"/>
              <set_turret_targets object="this.assignedcontrolled" target="[player.target]" weaponmode="weaponmode.autoassist"/>
              <set_value name="$autoassist_active"/>
            </do_if>
            <!-- important to skip label Wait since that does cease_fire -->
            <abort_called_scripts resume="FindEnemies"/>
          </do_if>
        </do_if>
        <do_elseif value="$autoassist_active?">
          <debug_text text="'autoassist mode deactivated. autoassist turrets ceasing fire.'" chance="$debugchance"/>
          <!-- player just deselected a target and there is no target. autoassist turrets simply cease firing and we resume waiting. -->
          <cease_fire object="this.assignedcontrolled" weaponmode="weaponmode.autoassist"/>
          <remove_value name="$autoassist_active"/>
        </do_elseif>
        <abort_called_scripts resume="Start" />
      </actions>
    </handler>
    <handler comment="defencedronemode changed or defence drones armed" consume="false">
      <conditions>
        <check_any>
          <check_all>
            <event_object_defencedronemode_changed object="this.assignedcontrolled"/>
            <check_value value="event.param != $defencedronemode"/>
            <check_value value="this.assignedcontrolled.hasarmeddefencedrones"/>
            <debug_text text="'defence drone mode changed from %s to %s'.[$defencedronemode, event.param]" debugchance="$debugchance"/>
          </check_all>
          <event_object_defencedrones_armed object="this.assignedcontrolled"/>
        </check_any>
      </conditions>
      <actions>
        <set_value name="$newdefencedronemode" exact="$defencedronemode"/>
        <do_if value="event.name == 'event_object_defencedronemode_changed'">
          <set_value name="$newdefencedronemode" exact="event.param"/>
        </do_if>
        <do_elseif value="event.name == 'event_object_defencedrones_armed'">
          <set_value name="$defencedronemode" exact="this.assignedcontrolled.defencedronemode"/>
          <set_value name="$newdefencedronemode" exact="$defencedronemode"/>
        </do_elseif>
        <set_value name="$newtargets" exact="[]"/>

        <!-- switching from dronemode.escort to something else. dock if no targets. -->
        <do_if value="($newdefencedronemode != dronemode.escort) and ($defencedronemode == dronemode.escort)">
          <debug_text text="'switching defencedronemode from %s. setting default orders for all defence drones to DockAndWait at me.'.[$defencedronemode]" chance="$debugchance"/>
          <!-- for all defence drones currently in the air, do not disengage current targets, but dock when able. -->
          <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
            <create_order id="'DockAndWait'" object="$group_launcheddefencedrones.{$interruptcounter}" default="true">
              <param name="destination" value="this.assignedcontrolled"/>
              <param name="dockfollowers" value="true"/>
              <param name="debugchance" value="$debugchance"/>
            </create_order>
          </do_all>
        </do_if>
        <!-- switching from something else to dronemode.escort. escort me if no targets. target acquisition done via escort script. -->
        <do_elseif value="$newdefencedronemode == dronemode.escort">
          <debug_text text="'switching defencedronemode to %s. setting default orders for all defence drones to Escort me.'.[$newdefencedronemode]" chance="$debugchance"/>
          <do_if value="(this.assignedcontrolled.attention ge attention.visible) and not this.zone.isclass.highway and not this.assignedcontrolled.travel.active">
            <do_all exact="this.assignedcontrolled.availableunits.{unitcategory.defence}.count">
              <launch_drone name="$locdrone" object="this.assignedcontrolled" category="unitcategory.defence"/>
              <add_to_group groupname="$group_launcheddefencedrones" object="$locdrone"/>
              <remove_value name="$locdrone"/>
            </do_all>
          </do_if>
          <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
            <!-- for all defence drones currently in the air, do not disengage current targets, but fall in to formation when able. -->
            <create_order id="'Escort'" object="$group_launcheddefencedrones.{$interruptcounter}" default="true"/>
          </do_all>
        </do_elseif>

        <do_if value="($newdefencedronemode == dronemode.defend) or ($newdefencedronemode == dronemode.autoassist) or ($newdefencedronemode == dronemode.missiledefence)">
          <set_value name="$resettargets"/>
        </do_if>

        <do_if value="this.sector">
          <!-- immediate new target acquisition.
                target acquisition for dronemode.attackenemies done in FindEnemies.
                target acquisition for dronemode.defend is in response to event_object_attacked; but if turrets are already tracking attackers, attack those directly.
                target acquisition for dronemode.escort done in Escort. -->
          <do_if value="$newdefencedronemode == dronemode.autoassist">
            <do_if value="player.target and this.assignedcontrolled.mayattack.{player.target} and this.assignedcontrolled.cansee.{player.target}">
              <set_value name="$evaltarget" exact="player.target"/>
              <include_interrupt_actions ref="ValidateTableTargets"/>
              <do_if value="@$table_targets.{$evaltarget}.count">
                <append_list_elements name="$newtargets" other="$table_targets.{$evaltarget}"/>
              </do_if>
              <do_else>
                <include_interrupt_actions ref="SelectTargets_High"/>
                <do_if value="@$resulttargets.count">
                  <append_list_elements name="$newtargets" other="$resulttargets.list"/>
                </do_if>
                <remove_value name="$resulttargets"/>
              </do_else>
              <remove_value name="$evaltarget"/>
            </do_if>
          </do_if>
          <do_elseif value="$newdefencedronemode == dronemode.defend">
            <do_if value="$attackers.count">
              <append_list_elements name="$newtargets" other="$attackers.list"/>
            </do_if>
          </do_elseif>
          <do_elseif value="$newdefencedronemode == dronemode.missiledefence">
            <find_object name="$newtargets" space="this.sector" class="class.missile" multiple="true">
              <match_distance object="this.assignedcontrolled" max="this.assignedcontrolled.currentradarrange"/>
            </find_object>
            <do_all exact="$newtargets.count" counter="$interruptcounter" reverse="true">
              <do_if value="$newtargets.{$interruptcounter}.target != this.assignedcontrolled">
                <remove_value name="$newtargets.{$interruptcounter}"/>
              </do_if>
            </do_all>
          </do_elseif>
          <debug_text text="'switching defencedronemode to %s. setting drones to engage %s targets.'.[$newdefencedronemode, @$newtargets.count]" chance="$debugchance"/>
        </do_if>

        <do_if value="$resettargets?">
          <!-- for drone modes: attackenemies, autoassist, and missiledefence; stop engaging current targets and engage new targets. logic for target acquisition after this point should be handled separately. -->
          <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
            <cancel_all_orders object="$group_launcheddefencedrones.{$interruptcounter}"/>
          </do_all>
          <clear_group group="$dronetargets"/>

          <remove_value name="$resettargets"/>
        </do_if>

        <do_if value="@$newtargets.count">
          <debug_text text="'switching defencedronemode to %s. setting drones to engage %s targets.'.[$newdefencedronemode, $newtargets.count]" chance="$debugchance"/>
          <add_to_group groupname="$dronetargets" list="$newtargets"/>
        </do_if>

        <set_value name="$defencedronemode" exact="$newdefencedronemode"/>

        <remove_value name="$newtargets"/>
        <remove_value name="$newdefencedronemode"/>

        <do_if value="$defencedronemode == dronemode.attackenemies">
          <abort_called_scripts resume="FindEnemies"/>
        </do_if>
        <do_elseif value="$dronetargets.count">
          <abort_called_scripts resume="Attack"/>
        </do_elseif>
        <abort_called_scripts resume="Start"/>
      </actions>
    </handler>
    <handler comment="drones disarmed or player gets up" consume="false">
      <conditions>
        <check_any>
          <check_all>
            <check_any>
              <event_object_defencedrones_disarmed object="this.assignedcontrolled"/>
              <event_object_signalled object="this" param="'recall_defencedrones'"/>
            </check_any>
            <check_value value="$group_launcheddefencedrones.count"/>
          </check_all>
          <check_all>
            <check_any>
              <event_control_entity_removed object="this.ship" entity="player.entity"/>
              <event_object_miningdrones_disarmed object="this.assignedcontrolled"/>
            </check_any>
            <check_value value="@$group_launchedminingdrones.count"/>
          </check_all>
          <check_all>
            <check_any>
              <event_control_entity_removed object="this.ship" entity="player.entity"/>
              <event_object_transportdrones_disarmed object="this.assignedcontrolled"/>
            </check_any>
            <check_value value="$group_launchedtransportdrones.count"/>
          </check_all>
        </check_any>
      </conditions>
      <actions>
        <do_if value="event.name == 'event_object_defencedrones_disarmed' or (event.name == 'event_object_signalled' and event.param == 'recall_defencedrones')">
          <do_if value="(event.name == 'event_object_defencedrones_disarmed') or ($defencedronemode != dronemode.escort)">
            <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
              <create_order id="'DockAndWait'" object="$group_launcheddefencedrones.{$interruptcounter}" default="true">
                <param name="destination" value="this.assignedcontrolled"/>
                <param name="dockfollowers" value="true"/>
                <param name="debugchance" value="$debugchance"/>
              </create_order>
              <cancel_all_orders object="$group_launcheddefencedrones.{$interruptcounter}"/>
              <debug_text text="'%s %s %s recalling defence drone %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launcheddefencedrones.{$interruptcounter}.idcode, @$group_launcheddefencedrones.{$interruptcounter}.knownname, $group_launcheddefencedrones.{$interruptcounter}]" chance="$debugchance"/>
            </do_all>
          </do_if>
          <do_else>
            <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
              <cancel_all_orders object="$group_launcheddefencedrones.{$interruptcounter}"/>
              <debug_text text="'%s %s %s recalling %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launcheddefencedrones.{$interruptcounter}.idcode, @$group_launcheddefencedrones.{$interruptcounter}.knownname, $group_launcheddefencedrones.{$interruptcounter}]" chance="$debugchance"/>
            </do_all>
          </do_else>
        </do_if>
        <do_elseif value="event.name == 'event_control_entity_removed'">
          <do_all exact="@$group_launchedminingdrones.count" counter="$interruptcounter">
            <start_script name="'order.dock'" object="$group_launchedminingdrones.{$interruptcounter}.pilot">
              <param name="destination" value="this.assignedcontrolled"/>
              <param name="abouttofinish" value="true"/>
              <param name="debugchance" value="$debugchance"/>
            </start_script>
            <debug_text text="'%s %s %s recalling mining drone %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launchedminingdrones.{$interruptcounter}.idcode, @$group_launchedminingdrones.{$interruptcounter}.knownname, $group_launchedminingdrones.{$interruptcounter}]" chance="$debugchance"/>
          </do_all>
          <do_all exact="$group_launchedtransportdrones.count" counter="$interruptcounter">
            <start_script name="'move.collect.drone'" object="$group_launchedtransportdrones.{$interruptcounter}.pilot">
              <param name="homebase" value="this.assignedcontrolled"/>
              <param name="masstraffic" value="true"/>
              <param name="launching" value="false"/>
              <param name="debugchance" value="$debugchance"/>
            </start_script>
            <debug_text text="'%s %s %s recalling transport drone %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launchedtransportdrones.{$interruptcounter}.idcode, @$group_launchedtransportdrones.{$interruptcounter}.knownname, $group_launchedtransportdrones.{$interruptcounter}]" chance="$debugchance"/>
          </do_all>
        </do_elseif>
        <do_elseif value="event.name == 'event_object_miningdrones_disarmed'">
          <do_all exact="@$group_launchedminingdrones.count" counter="$interruptcounter">
            <start_script name="'order.dock'" object="$group_launchedminingdrones.{$interruptcounter}.pilot">
              <param name="destination" value="this.assignedcontrolled"/>
              <param name="abouttofinish" value="true"/>
              <param name="debugchance" value="$debugchance"/>
            </start_script>
            <debug_text text="'%s %s %s recalling mining drone %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launchedminingdrones.{$interruptcounter}.idcode, @$group_launchedminingdrones.{$interruptcounter}.knownname, $group_launchedminingdrones.{$interruptcounter}]" chance="$debugchance"/>
          </do_all>
        </do_elseif>
        <do_elseif value="event.name == 'event_object_transportdrones_disarmed'">
          <do_all exact="$group_launchedtransportdrones.count" counter="$interruptcounter">
            <start_script name="'move.collect.drone'" object="$group_launchedtransportdrones.{$interruptcounter}.pilot">
              <param name="homebase" value="this.assignedcontrolled"/>
              <param name="masstraffic" value="true"/>
              <param name="launching" value="false"/>
              <param name="debugchance" value="$debugchance"/>
            </start_script>
            <debug_text text="'%s %s %s recalling transport drone %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launchedtransportdrones.{$interruptcounter}.idcode, @$group_launchedtransportdrones.{$interruptcounter}.knownname, $group_launchedtransportdrones.{$interruptcounter}]" chance="$debugchance"/>
          </do_all>
        </do_elseif>
      </actions>
    </handler>
    <handler comment="condition preventing drone launch has changed and defencedronemode == dronemode.escort" consume="false">
      <conditions>
        <check_any>
          <check_all>
            <event_object_changed_attention object="this.assignedcontrolled"/>
            <check_value value="(event.param ge attention.visible) and (event.param2 lt attention.visible)"/>
          </check_all>
          <check_all>
            <event_object_changed_zone object="this.assignedcontrolled"/>
            <check_value value="not event.param.isclass.highway and event.param2.isclass.highway"/>
          </check_all>
          <event_object_destroyed group="$group_launcheddefencedrones" method="killmethod.collected"/>
        </check_any>
        <check_value value="this.assignedcontrolled.hasarmeddefencedrones"/>
        <check_value value="$defencedronemode == dronemode.escort"/>
        <check_value value="this.assignedcontrolled.availableunits.{unitcategory.defence}.count"/>
        <check_value value="not this.zone.isclass.highway and not this.assignedcontrolled.travel.active and (this.assignedcontrolled.attention ge attention.visible)"/>
      </conditions>
      <actions>
        <debug_text text="'launching defence drones to escort. event: %s'.[event.name]" chance="$debugchance"/>
        <do_all exact="this.assignedcontrolled.availableunits.{unitcategory.defence}.count">
          <launch_drone name="$locdrone" object="this.assignedcontrolled" category="unitcategory.defence"/>
          <add_to_group groupname="$group_launcheddefencedrones" object="$locdrone"/>
          <remove_value name="$locdrone"/>
        </do_all>
        <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
          <!-- for all defence drones currently in the air, do not disengage current targets, but fall in to formation when able. -->
          <create_order id="'Escort'" object="$group_launcheddefencedrones.{$interruptcounter}" default="true"/>
        </do_all>
      </actions>
    </handler>
    <handler comment="dronemode collectable found" consume="false">
      <conditions>
        <event_gravidar_has_scanned object="this.assignedcontrolled"/>
        <check_value value="this.assignedcontrolled == player.occupiedship"/>
        <check_value value="not this.zone.isclass.highway and not this.assignedcontrolled.travel.active"/>
        <check_value value="this.sector"/>
        <count_gravidar_contacts result="$collectables" object="this.assignedcontrolled" class="[class.collectable, class.asteroid]" canbepickedup="true" multiple="true">
          <match_context macro="this.sector.macro"/>
        </count_gravidar_contacts>
      </conditions>
      <actions>
        <set_value name="$pickuptargets_solid" exact="[]"/>
        <set_value name="$pickuptargets_container" exact="[]"/>

        <do_all exact="$collectables.count" counter="$interruptcounter">
          <do_if value="$collectables.{$interruptcounter}.canbepickedup and @$collectables.{$interruptcounter}.wares.count">
            <do_if value="$collectables.{$interruptcounter}.isclass.asteroid">
              <do_if value="$miningdronemode? and this.assignedcontrolled.hasarmedminingdrones and this.assignedcontrolled.cargo.free.solid and (this.assignedcontrolled.primarypurpose == purpose.mine)">
                <do_if value="$miningdronemode == dronemode.collectanymineable">
                  <append_to_list name="$pickuptargets_solid" exact="$collectables.{$interruptcounter}"/>
                </do_if>
                <do_elseif value="($miningdronemode == dronemode.collectice) and $collectables.{$interruptcounter}.wares.{ware.ice}.count">
                  <append_to_list name="$pickuptargets_solid" exact="$collectables.{$interruptcounter}"/>
                </do_elseif>
                <do_elseif value="($miningdronemode == dronemode.collectore) and $collectables.{$interruptcounter}.wares.{ware.ore}.count">
                  <append_to_list name="$pickuptargets_solid" exact="$collectables.{$interruptcounter}"/>
                </do_elseif>
                <do_elseif value="($miningdronemode == dronemode.collectsilicon) and $collectables.{$interruptcounter}.wares.{ware.silicon}.count">
                  <append_to_list name="$pickuptargets_solid" exact="$collectables.{$interruptcounter}"/>
                </do_elseif>
                <do_elseif value="($miningdronemode == dronemode.collectnividium) and $collectables.{$interruptcounter}.wares.{ware.nividium}.count">
                  <append_to_list name="$pickuptargets_solid" exact="$collectables.{$interruptcounter}"/>
                </do_elseif>
              </do_if>
            </do_if>
            <do_elseif value="this.assignedcontrolled.hasarmedtransportdrones">
              <do_if value="$transportdronemode == dronemode.collectanycrate">
                <do_for_each name="$locware" in="$collectables.{$interruptcounter}.wares.list">
                  <do_if value="$locware.isinventory or this.assignedcontrolled.waretransport.indexof.{$locware.waretransport}">
                    <append_to_list name="$pickuptargets_container" exact="$collectables.{$interruptcounter}"/>
                    <break/>
                  </do_if>
                </do_for_each>
              </do_if>
              <do_elseif value="($transportdronemode == dronemode.collectillegal)">
                <do_for_each name="$locware" in="$collectables.{$interruptcounter}.wares.list">
                  <do_if value="$locware.isinventory or this.assignedcontrolled.waretransport.indexof.{$locware.waretransport}">
                    <do_if value="this.zone.policefaction and $locware.illegal">
                      <append_to_list name="$pickuptargets_container" exact="$collectables.{$interruptcounter}"/>
                      <break/>
                    </do_if>
                  </do_if>
                </do_for_each>
              </do_elseif>
              <do_elseif value="($transportdronemode == dronemode.collectlegal)">
                <do_for_each name="$locware" in="$collectables.{$interruptcounter}.wares.list">
                  <do_if value="$locware.isinventory or this.assignedcontrolled.waretransport.indexof.{$locware.waretransport}">
                    <do_if value="not this.zone.policefaction or not $locware.illegal">
                      <append_to_list name="$pickuptargets_container" exact="$collectables.{$interruptcounter}"/>
                      <break/>
                    </do_if>
                  </do_if>
                </do_for_each>
              </do_elseif>
            </do_elseif>
          </do_if>
        </do_all>

        <do_if value="$pickuptargets_solid.count">
          <include_interrupt_actions ref="LaunchDrone_OreCollector"/>
        </do_if>

        <do_if value="$pickuptargets_container.count">
          <include_interrupt_actions ref="LaunchDrone_Transport"/>
        </do_if>

        <remove_value name="$pickuptargets_container"/>
        <remove_value name="$pickuptargets_solid"/>
        <remove_value name="$collectables"/>
      </actions>
    </handler>
    <handler comment="miningdronemode gas resource found" consume="false">
      <conditions>
        <event_object_changed_zone object="this.assignedcontrolled"/>
        <check_value value="$miningdronemode?"/>
        <check_value value="this.assignedcontrolled == player.occupiedship"/>
        <check_value value="this.assignedcontrolled.primarypurpose == purpose.mine"/>
        <check_value value="this.assignedcontrolled.hasarmedminingdrones"/>
        <check_value value="this.assignedcontrolled.availableunits.{unitcategory.gascollector}.count and this.assignedcontrolled.cargo.free.liquid"/>
        <check_value value="not this.zone.isclass.highway and not this.assignedcontrolled.travel.active"/>
      </conditions>
      <actions>
        <set_value name="$locware" exact="[ware.helium, ware.hydrogen, ware.methane]"/>
        <do_if value="$miningdronemode == dronemode.collecthelium">
          <set_value name="$locware" exact="ware.helium"/>
        </do_if>
        <do_elseif value="$miningdronemode == dronemode.collecthydrogen">
          <set_value name="$locware" exact="ware.hydrogen"/>
        </do_elseif>
        <do_elseif value="$miningdronemode == dronemode.collectmethane">
          <set_value name="$locware" exact="ware.methane"/>
        </do_elseif>

        <set_value name="$locwares" exact="[$locware]"/>
        <include_interrupt_actions ref="LaunchDrone_GasCollector"/>

        <remove_value name="$locware"/>
      </actions>
    </handler>
    <handler comment="miningdronemode gas mining drones dock" consume="false">
      <conditions>
        <event_object_docked group="$group_launchedminingdrones" dock="this.assignedcontrolled"/>
        <check_value value="this.sector"/>
      </conditions>
      <actions>
        <do_if value="$miningdronemode == dronemode.collectanymineable">
          <find_closest_resource wares="$locfoundwares" zone="$loczone" position="$loczonepos" ware="[ware.helium, ware.hydrogen, ware.methane]" refobject="this.assignedcontrolled"/>
          <do_if value="$locfoundwares.count">
            <shuffle_list list="$locfoundwares"/>
            <set_value name="$locware" exact="$locfoundwares.random"/>
          </do_if>

          <remove_value name="$locfoundwares"/>
          <remove_value name="$loczonepos"/>
          <remove_value name="$loczone"/>
        </do_if>
        <do_elseif value="$miningdronemode == dronemode.collecthelium">
          <set_value name="$locware" exact="ware.helium"/>
        </do_elseif>
        <do_elseif value="$miningdronemode == dronemode.collecthydrogen">
          <set_value name="$locware" exact="ware.hydrogen"/>
        </do_elseif>
        <do_elseif value="$miningdronemode == dronemode.collectmethane">
          <set_value name="$locware" exact="ware.methane"/>
        </do_elseif>

        <do_if value="@$locware">
          <create_position name="$locsectorpos" space="this.sector" object="this.assignedcontrolled"/>
          <get_resource_gatherrate name="$locgatherrate" refobject="this.assignedcontrolled" sector="this.sector" ware="$locware">
            <position value="$locsectorpos"/>
          </get_resource_gatherrate>
          <!-- "15" below to stay consistent with mining.collect.ship.liquid -->
          <set_value name="$locgathered" min="$locgatherrate * 15 * 0.75" max="$locgatherrate * 15 * 1.25"/>
          <deplete_yield sector="this.sector" container="this.assignedcontrolled" ware="$locware" amount="$locgathered">
            <position value="$locsectorpos"/>
          </deplete_yield>
          <debug_text text="'%s %s %s gathered %s %s from %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $locgathered, $locware, this.sector.knownname, this.sector]" chance="$debugchance"/>

          <remove_value name="$locsectorpos"/>
          <remove_value name="$locgathered"/>
          <remove_value name="$locgatherrate"/>
        </do_if>

        <remove_value name="$locware"/>
      </actions>
    </handler>
    <handler comment="miningdronemode changed or mining drones armed or player takes over or conditions changed such that drones can now launch" consume="false">
      <conditions>
        <check_any>
          <check_all>
            <event_object_miningdronemode_changed object="this.assignedcontrolled"/>
            <check_value value="event.param != @$miningdronemode"/>
          </check_all>
          <event_object_miningdrones_armed object="this.assignedcontrolled"/>
          <event_control_entity_added object="this.assignedcontrolled" entity="player.entity"/>
          <check_all>
            <event_object_changed_attention object="this.assignedcontrolled"/>
            <check_value value="(event.param ge attention.visible) and (event.param2 lt attention.visible)"/>
          </check_all>
          <check_all>
            <event_object_changed_zone object="this.assignedcontrolled"/>
            <check_value value="not event.param.isclass.highway and event.param2.isclass.highway"/>
          </check_all>
        </check_any>
        <debug_text text="'mining drone handler. event: %s. miningdronemode: %s. check 1: %s, check 2: %s, check 3: %s'.[event.name, $miningdronemode?, this.assignedcontrolled.primarypurpose == purpose.mine, this.assignedcontrolled == player.occupiedship, this.assignedcontrolled.hasarmedminingdrones]" debugchance="$debugchance"/>
        <check_value value="$miningdronemode?"/>
        <check_value value="this.assignedcontrolled.primarypurpose == purpose.mine"/>
        <check_value value="this.assignedcontrolled == player.occupiedship"/>
        <check_value value="this.assignedcontrolled.hasarmedminingdrones"/>
      </conditions>
      <actions>
        <set_value name="$newminingdronemode" exact="this.assignedcontrolled.miningdronemode"/>
        <do_if value="event.name == 'event_object_miningdronemode_changed'">
          <set_value name="$newminingdronemode" exact="event.param"/>
        </do_if>

        <set_value name="$locwares" exact="[]"/>
        <do_if value="$newminingdronemode == dronemode.collectanymineable">
          <do_if value="this.assignedcontrolled.units.{unitcategory.orecollector}.count and this.assignedcontrolled.cargo.capacity.solid">
            <append_to_list name="$locwares" exact="ware.ore"/>
            <append_to_list name="$locwares" exact="ware.silicon"/>
            <append_to_list name="$locwares" exact="ware.ice"/>
            <append_to_list name="$locwares" exact="ware.nividium"/>
            <set_value name="$locfindsolid"/>
          </do_if>

          <do_if value="this.assignedcontrolled.units.{unitcategory.gascollector}.count and this.assignedcontrolled.cargo.capacity.liquid">
            <append_to_list name="$locwares" exact="ware.helium"/>
            <append_to_list name="$locwares" exact="ware.hydrogen"/>
            <append_to_list name="$locwares" exact="ware.methane"/>
            <set_value name="$locfindliquid"/>
          </do_if>
        </do_if>
        <do_elseif value="$newminingdronemode == dronemode.collectice">
          <append_to_list name="$locwares" exact="ware.ice"/>
          <set_value name="$locfindsolid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collectore">
          <append_to_list name="$locwares" exact="ware.ore"/>
          <set_value name="$locfindsolid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collectsilicon">
          <append_to_list name="$locwares" exact="ware.silicon"/>
          <set_value name="$locfindsolid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collectnividium">
          <append_to_list name="$locwares" exact="ware.nividium"/>
          <set_value name="$locfindsolid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collecthelium">
          <append_to_list name="$locwares" exact="ware.helium"/>
          <set_value name="$locfindliquid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collecthydrogen">
          <append_to_list name="$locwares" exact="ware.hydrogen"/>
          <set_value name="$locfindliquid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collectmethane">
          <append_to_list name="$locwares" exact="ware.methane"/>
          <set_value name="$locfindliquid"/>
        </do_elseif>

        <do_if value="$locwares.count">
          <do_if value="$locfindsolid?">
            <find_object name="$pickuptargets_solid" space="this.zone" class="class.asteroid" multiple="true">
              <match_distance object="this.assignedcontrolled" max="this.assignedcontrolled.currentradarrange"/>
              <match_wares>
                <ware ware="$locwares"/>
              </match_wares>
            </find_object>
            <include_interrupt_actions ref="LaunchDrone_OreCollector"/>
            <remove_value name="$locfindsolid"/>
          </do_if>

          <do_if value="$locfindliquid?">
            <include_interrupt_actions ref="LaunchDrone_GasCollector"/>
            <remove_value name="$locfindliquid"/>
          </do_if>
        </do_if>

        <set_value name="$miningdronemode" exact="$newminingdronemode"/>

        <remove_value name="$locwares"/>
        <remove_value name="$newtargets"/>
        <remove_value name="$newminingdronemode"/>
      </actions>
    </handler>
    <handler comment="transportdronemode changed or transport drones armed or player takes over or conditions changed such that drones can now launch" consume="false">
      <conditions>
        <check_any>
          <check_all>
            <event_object_transportdronemode_changed object="this.assignedcontrolled"/>
            <check_value value="event.param != $transportdronemode"/>
          </check_all>
          <event_object_transportdrones_armed object="this.assignedcontrolled"/>
          <event_control_entity_added object="this.assignedcontrolled" entity="player.entity"/>
          <check_all>
            <event_object_changed_attention object="this.assignedcontrolled"/>
            <check_value value="(event.param ge attention.visible) and (event.param2 lt attention.visible)"/>
          </check_all>
          <check_all>
            <event_object_changed_zone object="this.assignedcontrolled"/>
            <check_value value="not event.param.isclass.highway and event.param2.isclass.highway"/>
          </check_all>
        </check_any>
        <check_value value="this.assignedcontrolled == player.occupiedship"/>
        <check_value value="this.assignedcontrolled.hasarmedtransportdrones"/>
      </conditions>
      <actions>
        <set_value name="$newtransportdronemode" exact="this.assignedcontrolled.transportdronemode"/>
        <do_if value="event.name == 'event_object_transportdronemode_changed'">
          <set_value name="$newtransportdronemode" exact="event.param"/>
        </do_if>

        <find_object name="$pickuptargets_container" space="this.zone" class="class.collectable" multiple="true">
          <match_distance object="this.assignedcontrolled" max="this.assignedcontrolled.currentradarrange"/>
        </find_object>
        <do_if value="$newtransportdronemode == dronemode.collectanycrate">
          <do_all exact="$pickuptargets_container.count" counter="$interruptcounter" reverse="true">
            <do_if value="$pickuptargets_container.{$interruptcounter}.isclass.asteroid">
              <remove_value name="$pickuptargets_container.{$interruptcounter}"/>
            </do_if>
          </do_all>
        </do_if>
        <do_elseif value="$newtransportdronemode == dronemode.collectillegal">
          <do_all exact="$pickuptargets_container.count" counter="$interruptcounter" reverse="true">
            <do_if value="$pickuptargets_container.{$interruptcounter}.isclass.asteroid">
              <remove_value name="$pickuptargets_container.{$interruptcounter}"/>
            </do_if>
            <do_else>
              <do_all exact="$pickuptargets_container.{$interruptcounter}.wares.count" counter="$interruptcounter2">
                <do_if value="not this.zone.policefaction or not $pickuptargets_container.{$interruptcounter}.wares.{$interruptcounter2}.illegal">
                  <remove_value name="$pickuptargets_container.{$interruptcounter}"/>
                  <break/>
                </do_if>
              </do_all>
            </do_else>
          </do_all>
        </do_elseif>
        <do_elseif value="$newtransportdronemode == dronemode.collectlegal">
          <do_all exact="$pickuptargets_container.count" counter="$interruptcounter" reverse="true">
            <do_if value="$pickuptargets_container.{$interruptcounter}.isclass.asteroid">
              <remove_value name="$pickuptargets_container.{$interruptcounter}"/>
            </do_if>
            <do_else>
              <do_all exact="$pickuptargets_container.{$interruptcounter}.wares.count" counter="$interruptcounter2">
                <do_if value="this.zone.policefaction and $pickuptargets_container.{$interruptcounter}.wares.{$interruptcounter2}.illegal">
                  <remove_value name="$pickuptargets_container.{$interruptcounter}"/>
                  <break/>
                </do_if>
              </do_all>
            </do_else>
          </do_all>
        </do_elseif>

        <do_if value="$pickuptargets_container.count">
          <include_interrupt_actions ref="LaunchDrone_Transport"/>
        </do_if>

        <set_value name="$transportdronemode" exact="$newtransportdronemode"/>

        <remove_value name="$newtransportdronemode"/>
      </actions>
    </handler>
    <handler comment="stop firing if a target changes ownership to less than hostile" consume="false">
      <conditions>
        <check_any>
          <event_object_relation_range_changed group="$targets_defensibles" faction="this.owner"/>
          <event_object_changed_owner group="$targets_defensibles"/>
          <event_object_changed_owner group="$attackers"/>
          <event_object_changed_owner group="$disabletargets"/>
          <event_object_changed_owner object="this.assignedcontrolled"/>
          <event_object_changed_owner group="$pilotgroup"/>
          <event_object_docked group="$targets_defensibles"/>
          <event_object_docked group="$attackers"/>
          <event_object_docked group="$disabletargets"/>
        </check_any>
        <check_value value="not this.assignedcontrolled.mayattack.{event.object}"/>
      </conditions>
      <actions>
        <do_if value="(event.name == 'event_object_changed_owner') and ((event.object == this.assignedcontrolled) or (event.object == @this.assignedcontrolled.pilot))">
          <debug_text text="'my ownership changed resulting in a relation change. ceasing fire.'" chance="$debugchance"/>
          <clear_group group="$targets"/>
          <clear_group group="$targets_defensibles"/>
          <clear_group group="$targets_capital"/>
          <clear_group group="$targets_fighters"/>
          <clear_group group="$attackers"/>
          <clear_group group="$disabletargets"/>
          <remove_value name="this.$combat_obstructiondelay"/>
          <clear_table table="$table_targets"/>
        </do_if>
        <do_else>
          <set_value name="$evaltarget" exact="event.object"/>
          <debug_text text="'target ownership changed. ceasing fire against %s %s %s.'.[@$evaltarget.idcode, @$evaltarget.knownname, $evaltarget]" chance="$debugchance"/>
          <include_interrupt_actions ref="ClearTarget"/>
          <do_if value="$autoassist_active? and player.target and not this.assignedcontrolled.mayattack.{player.target}">
            <debug_text text="'autoassist target changed owner. autoassist turrets ceasing fire.'" chance="$debugchance"/>
            <cease_fire object="this.assignedcontrolled" weaponmode="weaponmode.autoassist"/>
            <remove_value name="$autoassist_active"/>
          </do_if>
          <remove_value name="$evaltarget"/>
        </do_else>
        <abort_called_scripts resume="Start" />
      </actions>
    </handler>
    <handler comment="start firing if the player takes over a ship that has turrets set to weaponmode.mining" consume="false">
      <conditions>
        <event_control_entity_added object="this.ship"/>
      </conditions>
      <actions>
        <add_to_group groupname="$pilotgroup" object="event.param" replace="true"/>
        <debug_text text="'registering pilot: %s %s'.[event.param.knownname, event.param]" chance="$debugchance"/>
        <do_if value="(event.param == player.entity) and @$turretmodes.indexof.{weaponmode.mining}">
          <debug_text text="'%s %s %s %s is now flown by the player and has turrets set to mining.'.[this.ship.class, this.ship.idcode, this.ship.knownname, this.ship]" chance="$debugchance"/>
          <abort_called_scripts resume="Start" />
        </do_if>
      </actions>
    </handler>
    <handler comment="stop firing if the player is no longer flying the ship and we were mining. AI mining turret handling in the mining scripts." consume="false">
      <conditions>
        <event_control_entity_removed object="this.ship"/>
      </conditions>
      <actions>
        <clear_group group="$pilotgroup"/>
        <do_if value="event.param == player.entity">
          <do_if value="this.assignedcontrolled.assignedaipilot">
            <add_to_group groupname="$pilotgroup" object="this.assignedcontrolled.assignedaipilot"/>
            <debug_text text="'registering pilot: %s %s'.[this.assignedcontrolled.assignedaipilot.knownname, this.assignedcontrolled.assignedaipilot]" chance="$debugchance"/>
          </do_if>
          <do_if value="@$turretmodes.indexof.{weaponmode.mining}">
            <debug_text text="'%s %s %s %s is no longer flown by the player and has turrets set to mining.'.[this.ship.class, this.ship.idcode, this.ship.knownname, this.ship]" chance="$debugchance"/>
            <clear_group group="$miningtargets"/>
            <cease_fire object="this.ship" weaponmode="weaponmode.mining"/>
          </do_if>
        </do_if>
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_build_finished object="this.assignedcontrolled"/>
        <check_value value="$FiringRange != this.assignedcontrolled.maxcombatrange.all"/>
      </conditions>
      <actions>
        <set_value name="$FiringRange" exact="this.assignedcontrolled.maxcombatrange.all"/>
      </actions>
    </handler>
    <handler comment="clean up $table_targets">
      <conditions>
        <event_object_destroyed group="$targets_defensibles"/>
      </conditions>
      <actions>
        <set_value name="$evaltarget" exact="event.object"/>
        <include_interrupt_actions ref="ClearTarget"/>
        <remove_value name="$evaltarget"/>
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_object_changed_sector object="this.assignedcontrolled"/>
        <check_value value="event.param.exists"/>
      </conditions>
      <actions>
        <add_to_group groupname="$sectorgrp" object="event.param" replace="true"/>
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command_action commandaction="commandaction.standingby" />
    <!-- Initial variables -->
    <set_value name="$lastdronelaunch" exact="player.age - 10min" />
    <set_value name="$nextammocheck" exact="player.age + 100s" />
    <set_value name="$FiringRange" exact="this.ship.maxcombatrange.all"/>
    <set_value name="$operationalrange" exact="this.ship.maxradarrange * 0.8"/>
    <set_value name="$criticalrange" exact="this.ship.maxradarrange * 0.4"/>
    <set_value name="$checkrelation" exact="true"/>
    <set_value name="$default_checkrelation" exact="$checkrelation"/>
    <set_value name="$scantime" exact="500ms + ((1.0 - (@this.assignedcontrolled.combinedskill / 100.0)) * 60s)"/>

    <!-- objects that attack this ship including modules and surface elements. also includes $primarytarget and its modules and surface elements if defined. -->
    <create_group groupname="$attackers"/>
    <!-- all defensibles, modules, and surface elements that have been acquired except stations. -->
    <create_group groupname="$targets"/>
    <!-- all defensibles that have been acquired. includes stations. -->
    <create_group groupname="$targets_defensibles"/>
    <!-- subset of $targets including only capital ships and attached surface elements. populated, used, and discarded on the fly. -->
    <create_group groupname="$targets_capital"/>
    <!-- subset of $targets including only non-capital ships. populated, used, and discarded on the fly. -->
    <create_group groupname="$targets_fighters"/>
    <!-- targets set to be disabled. should only contain defensibles but may also contain surface elements and modules. -->
    <create_group groupname="$disabletargets"/>
    <create_group groupname="$incomingmissiles"/>
    <create_group groupname="$miningtargets"/>
    <!-- targets set to be engaged by defence drones. -->
    <create_group groupname="$dronetargets"/>
    <!-- table of targets. keys are defensibles including stations, values are the modules and surface elements of those defensibles including the defensibles themselves if not stations. for quick access to all modules and surface elements of specific targets. -->
    <set_value name="$table_targets" exact="table[]"/>
    <!-- needed for global event handlers listening for events triggered on our current sector -->
    <create_group groupname="$sectorgrp"/>

    <set_value name="$defencedronemode" exact="this.assignedcontrolled.defencedronemode"/>
    <create_group groupname="$group_launcheddefencedrones"/>
    <set_value name="$transportdronemode" exact="this.assignedcontrolled.transportdronemode"/>
    <create_group groupname="$group_launchedtransportdrones"/>
    <set_value name="$miningdronemode" exact="this.assignedcontrolled.miningdronemode"/>
    <create_group groupname="$group_launchedminingdrones"/>

    <create_group groupname="$pilotgroup"/>
    <do_if value="this.assignedcontrolled.pilot.exists">
      <add_to_group groupname="$pilotgroup" object="this.assignedcontrolled.pilot"/>
    </do_if>

    <set_value name="$num_launchtubes" exact="0"/>
    <set_value name="$num_dronedocks" exact="0"/>
    <find_dockingbay name="$docks" object="this.ship" checkoperational="1" multiple="1">
      <match_dock size="tag.dock_s" storage="false"/>
    </find_dockingbay>
    <do_all exact="$docks.count" counter="$i">
      <do_if value="$docks.{$i}.islaunchtube">
        <set_value name="$num_launchtubes" exact="$num_launchtubes + 1"/>
      </do_if>
      <set_value name="$num_dronedocks" exact="$num_dronedocks + 1"/>
    </do_all>
    <remove_value name="$docks"/>
    <set_value name="$iscarrier" exact="this.assignedcontrolled.type == shiptype.carrier"/>
  </init>
  <patch sinceversion="1">
    <set_value name="$numpatchcleared" exact="0"/>
    <do_all exact="$attackers.count" counter="$p" reverse="true">
      <do_if value="not $attackers.{$p}.isclass.defensible and not $attackers.{$p}.container">
        <remove_from_group group="$attackers" object="$attackers.{$p}"/>
        <set_value name="$numpatchcleared" exact="$numpatchcleared + 1"/>
      </do_if>
    </do_all>
    <do_all exact="$targets.count" counter="$p" reverse="true">
      <do_if value="not $targets.{$p}.isclass.defensible and not $targets.{$p}.container">
        <remove_from_group group="$targets" object="$targets.{$p}"/>
        <set_value name="$numpatchcleared" exact="$numpatchcleared + 1"/>
      </do_if>
    </do_all>
    <do_all exact="$disabletargets.count" counter="$p" reverse="true">
      <do_if value="not $disabletargets.{$p}.isclass.defensible and not $disabletargets.{$p}.container">
        <remove_from_group group="$disabletargets" object="$disabletargets.{$p}"/>
        <set_value name="$numpatchcleared" exact="$numpatchcleared + 1"/>
      </do_if>
    </do_all>
    <do_all exact="@$dronetargets.count" counter="$p" reverse="true">
      <do_if value="not $dronetargets.{$p}.isclass.defensible and not $dronetargets.{$p}.container">
        <remove_from_group group="$dronetargets" object="$dronetargets.{$p}"/>
        <set_value name="$numpatchcleared" exact="$numpatchcleared + 1"/>
      </do_if>
    </do_all>
    <debug_text text="'PATCH: cleared target lists of %s invalid targets.'.[$numpatchcleared]" chance="$numpatchcleared * 100" filter="savegame"/>
    <remove_value name="$numpatchcleared"/>
  </patch>
  <patch sinceversion="2">
    <set_value name="$num_dronedocks" exact="0"/>
    <find_dockingbay name="$docks" object="this.ship" checkoperational="1" multiple="1">
      <match_dock size="tag.dock_s" storage="false"/>
    </find_dockingbay>
    <set_value name="$num_dronedocks" exact="$docks.count"/>
    <remove_value name="$docks"/>
  </patch>
  <patch sinceversion="7">
    <set_value name="$locship" exact="this.assignedcontrolled"/>
    <set_value name="$locnum_deployedunits" exact="0"/>
    <set_value name="$locnum_unavailableunits" exact="$locship.units.{unitcategory.defence}.count - $locship.availableunits.{unitcategory.defence}.count"/>
    <do_all exact="$locship.subordinates.count" counter="$_i">
      <do_if value="$locship.subordinates.{$_i}.isunit">
        <set_value name="$locnum_deployedunits" exact="$locnum_deployedunits + 1"/>
      </do_if>
    </do_all>

    <set_value name="$locnum_destroyedunits" exact="0"/>
    <set_value name="$locnum_reassignedunits" exact="0"/>
    <find_object_component name="$localldockedunits" object="$locship" unit="true" recursive="true" multiple="true"/>
    <do_all exact="$localldockedunits.count" counter="$_i" reverse="true">
      <set_value name="$loccommander" exact="$localldockedunits.{$_i}.commander"/>
      <do_if value="@$loccommander.isunit and (not $loccommander.commander or ($loccommander.commander == $locship))">
        <set_value name="$loccommander" exact="null"/>
      </do_if>
      <do_if value="not $loccommander.isoperational">
        <do_if value="$locnum_unavailableunits gt $locnum_deployedunits">
          <set_object_commander object="$localldockedunits.{$_i}" commander="$locship"/>
          <set_value name="$locnum_deployedunits" exact="$locnum_deployedunits + 1"/>
          <set_value name="$locnum_reassignedunits" exact="$locnum_reassignedunits + 1"/>
        </do_if>
        <do_else>
          <destroy_object object="$localldockedunits.{$_i}" explosion="false"/>
          <set_value name="$locnum_destroyedunits" exact="$locnum_destroyedunits + 1"/>
        </do_else>
      </do_if>
    </do_all>
    <debug_text text="'PATCH: found %s docked units that have no commander.\n reassigned: %s\n destroyed: %s\n deployed: %s'.[$locnum_reassignedunits + $locnum_destroyedunits, $locnum_reassignedunits, $locnum_destroyedunits, $locnum_deployedunits]" filter="savegame" chance="(($locnum_destroyedunits gt 0) or ($locnum_reassignedunits gt 0)) * 100"/>

    <set_value name="$locnum_collected" exact="0"/>
    <set_value name="$locnum_destroyedunits" exact="0"/>
    <do_all exact="$locship.subordinates.count" counter="$_i" reverse="true">
      <set_value name="$locsub" exact="$locship.subordinates.{$_i}"/>
      <do_if value="$locsub.isunit and $locsub.dock and (@$locsub.order.id == 'DockAndWait' or @$locsub.order.id == 'DockAt')">
        <do_if value="$locship.units.{unitcategory.defence}.count gt $locship.availableunits.{unitcategory.defence}.count">
          <collect_unit object="$locship" unit="$locsub"/>
          <set_value name="$locnum_collected" exact="$locnum_collected + 1"/>
        </do_if>
        <do_else>
          <destroy_object object="$locsub" explosion="false"/>
          <set_value name="$locnum_destroyedunits" exact="$locnum_destroyedunits + 1"/>
        </do_else>
      </do_if>
    </do_all>
    <debug_text text="'PATCH: %s %s %s found %s defence drones that were docked but uncollected.\n collected: %s\n destroyed: %s'.[@$locship.idcode, @$locship.knownname, $locship, $locnum_collected + $locnum_destroyedunits, $locnum_collected, $locnum_destroyedunits]" filter="savegame" chance="($locnum_collected gt 0) * 100"/>

    <remove_value name="$locnum_unavailableunits"/>
    <remove_value name="$locnum_deployedunits"/>
    <remove_value name="$locnum_reassignedunits"/>
    <remove_value name="$locnum_destroyedunits"/>
    <remove_value name="$loccommander"/>
    <remove_value name="$localldockedunits"/>
    <remove_value name="$locnum_collected"/>
    <remove_value name="$locsub"/>
    <remove_value name="$locship"/>
  </patch>
  <patch sinceversion="8" early="true">
    <!-- orig v3 -->
    <do_if value="not $dronetargets?">
      <create_group groupname="$dronetargets"/>
    </do_if>

    <set_value name="$defencedronemode" exact="this.assignedcontrolled.defencedronemode"/>
    <do_if value="not $group_launcheddefencedrones?">
      <create_group groupname="$group_launcheddefencedrones"/>
    </do_if>
    <debug_text text="'PATCH: initializing defencedronemode: %s'.[$defencedronemode]" filter="savegame" chance="0"/>

    <!-- orig v4 -->
    <set_value name="$transportdronemode" exact="this.assignedcontrolled.transportdronemode"/>
    <do_if value="not $group_launchedtransportdrones?">
      <create_group groupname="$group_launchedtransportdrones"/>
    </do_if>
    <set_value name="$miningdronemode" exact="this.assignedcontrolled.miningdronemode"/>
    <do_if value="not $group_launchedminingdrones?">
      <create_group groupname="$group_launchedminingdrones"/>
    </do_if>
    <debug_text text="'PATCH: initializing transportdronemode: %s and miningdronemode: %s'.[$transportdronemode, $miningdronemode]" filter="savegame" chance="0"/>

    <!-- orig v6 -->
    <do_if value="not $pilotgroup?">
      <create_group groupname="$pilotgroup"/>
    </do_if>
    <do_if value="this.assignedcontrolled.pilot.exists">
      <add_to_group groupname="$pilotgroup" object="this.assignedcontrolled.pilot"/>
      <debug_text text="'PATCH: recognizing pilot: %s %s'.[@this.assignedcontrolled.pilot.knownname, this.assignedcontrolled.pilot]" filter="savegame" chance="0"/>
    </do_if>
  </patch>
  <patch sinceversion="8">
    <!-- orig v3 -->
    <do_all exact="this.assignedcontrolled.allsubordinates.count" counter="$p">
      <set_value name="$locsub" exact="this.assignedcontrolled.allsubordinates.{$p}"/>
      <do_if value="$locsub.isoperational and $locsub.isunit and this.assignedcontrolled.hasunitdrone.{$locsub}">
        <do_if value="$locsub.unitcategory == unitcategory.defence">
          <add_to_group groupname="$group_launcheddefencedrones" object="$locsub"/>
          <do_if value="@$locsub.defaultorder.id != 'DockAndWait'">
            <create_order id="'DockAndWait'" object="$locsub" default="true">
              <param name="destination" value="this.assignedcontrolled"/>
              <param name="dockfollowers" value="true"/>
              <param name="debugchance" value="$debugchance"/>
            </create_order>
          </do_if>
          <debug_text text="'PATCH: adding %s %s %s to $group_launcheddefencedrones'.[@$locsub.idcode, $locsub.knownname, $locsub]" filter="savegame" chance="0"/>
        </do_if>
      </do_if>
    </do_all>
    <remove_value name="$locsub"/>

    <!-- orig v5 -->
    <do_if value="this.assignedcontrolled.dock">
      <stop_shooting object="this.assignedcontrolled"/>
      <stop_shooting object="this.assignedcontrolled" missiles="true"/>
    </do_if>
  </patch>
  <patch sinceversion="9">
    <do_if value="not $incomingmissiles?">
      <create_group groupname="$incomingmissiles"/>
    </do_if>
    <create_group groupname="$targets_capital"/>
    <create_group groupname="$targets_fighters"/>
    <do_all exact="$targets.count" counter="$_i">
      <do_if value="@$targets.{$_i}.iscapitalship or @$targets.{$_i}.isrealclass.station">
        <add_to_group groupname="$targets_capital" object="$targets.{$_i}"/>
      </do_if>
      <do_elseif value="$targets.{$_i}.isclass.ship">
        <add_to_group groupname="$targets_fighters" object="$targets.{$_i}"/>
      </do_elseif>
      <do_else>
        <do_if value="$targets.{$_i}.container">
          <do_if value="@$targets.{$_i}.container.iscapitalship or @$targets.{$_i}.container.isrealclass.station">
            <add_to_group groupname="$targets_capital" object="$targets.{$_i}"/>
          </do_if>
          <do_elseif value="$targets.{$_i}.container.isclass.ship">
            <add_to_group groupname="$targets_fighters" object="$targets.{$_i}"/>
          </do_elseif>
        </do_if>
      </do_else>
    </do_all>
  </patch>
  <patch sinceversion="10">
    <!--removed for version 27-->
  </patch>
  <patch sinceversion="11">
    <do_for_each name="$loctarget" in="$targets_fighters" reverse="true">
      <do_if value="not $targets.indexof.{$loctarget}">
        <remove_from_group group="$targets_fighters" object="$loctarget"/>
      </do_if>
    </do_for_each>
    <do_for_each name="$loctarget" in="$targets_capital" reverse="true">
      <do_if value="not $targets.indexof.{$loctarget}">
        <remove_from_group group="$targets_capital" object="$loctarget"/>
      </do_if>
    </do_for_each>
    <do_if value="@$preferredtarget.exists and not $targets.indexof.{$preferredtarget}">
      <set_value name="$preferredtarget" exact="null"/>
    </do_if>
    <do_if value="not $targets.count">
      <cease_fire object="this.assignedcontrolled"/>
    </do_if>
  </patch>
  <patch sinceversion="12">
    <do_if value="this.assignedcontrolled.attention lt attention.visible">
      <create_group groupname="$targets_low"/>
      <do_if value="@$targets.count">
        <do_for_each name="$loctarget" in="$targets">
          <do_if value="$loctarget.isoperational and not @$loctarget.dock">
            <!-- target not being defensible and having a container means it's a surface element. we cannot get the attackstrength of something that is not a defensible. so target the container. -->
            <do_while value="not $loctarget.isclass.defensible and $loctarget.container">
              <set_value name="$loctarget" exact="$loctarget.container"/>
            </do_while>
            <do_if value="not $targets_low.indexof.{$loctarget}">
              <add_to_group groupname="$targets_low" object="$loctarget"/>
            </do_if>
          </do_if>
        </do_for_each>
      </do_if>
      <!-- reset the script -->
      <signal_objects object="this" param="'attack'" param2="null" param3="[null, null, null, null, null, null, null, null, true]"/>
    </do_if>
  </patch>
  <patch sinceversion="14">
    <do_if value="@$behaviortargetclasses.count and not $targets.count">
      <remove_value name="$behaviortargetclasses"/>
    </do_if>
  </patch>
  <patch sinceversion="15">
    <do_for_each name="$loctarget" in="$targets">
      <do_if value="$loctarget.isoperational and this.trueowner.relationto.{$loctarget.trueowner} gt -0.01">
        <debug_text text="'PATCH: %s %s %s was attacking %s %s %s which belongs to a non-hostile faction. resetting relations and re-evaluating.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$loctarget.idcode, @$loctarget.knownname, $loctarget]" filter="savegame"/>
        <reset_relation_boost object="this.assignedcontrolled" otherobject="$loctarget"/>
        <set_value name="$locreset"/>
      </do_if>
    </do_for_each>
    <do_if value="$locreset?">
      <signal_objects object="this" param="'attack'"/>
    </do_if>
    <remove_value name="$locreset"/>
  </patch>
  <patch sinceversion="16">
    <do_if value="this.$launchedunitcount? and (this.assignedcontrolled.units.{unitcategory.defence}.count == this.assignedcontrolled.availableunits.{unitcategory.defence}.count)">
      <debug_text text="'PATCH: %s %s %s has launched unit counter but all units on board. removing counter.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" filter="savegame"/>
      <remove_value name="this.$launchedunitcount"/>
    </do_if>
  </patch>
  <patch sinceversion="17">
    <do_if value="$FiringRange lt this.assignedcontrolled.maxcombatrange.all">
      <set_value name="$FiringRange" exact="this.assignedcontrolled.maxcombatrange.all"/>
    </do_if>
  </patch>
  <patch sinceversion="18" early="true">
    <create_group groupname="$targets_defensibles"/>
    <set_value name="$table_targets" exact="table[]"/>
  </patch>
  <patch sinceversion="18">
    <do_if value="$targets_low?">
      <remove_value name="$targets_low"/>
    </do_if>
    <do_for_each name="$evaltarget" in="$targets">
      <do_if value="$evaltarget.canbeattacked">
        <do_if value="$evaltarget.isclass.defensible or not $evaltarget.container">
          <add_to_group groupname="$targets_defensibles" object="$evaltarget"/>
          <include_interrupt_actions ref="SelectTargets_High"/>
          <do_if value="@$resulttargets.count">
            <set_value name="$table_targets.{$evaltarget}" exact="$resulttargets"/>
          </do_if>
          <remove_value name="$resulttargets"/>
        </do_if>
        <do_elseif value="not $targets_defensibles.indexof.{$evaltarget.container} and $evaltarget.container.isrealclass.station">
          <include_interrupt_actions ref="SelectTarget_Low"/>
          <do_if value="@$resulttarget">
            <add_to_group groupname="$targets_defensibles" object="$resulttarget"/>
            <set_value name="$evaltarget" exact="$resulttarget"/>
            <include_interrupt_actions ref="SelectTargets_High"/>
            <do_if value="@$resulttargets.count">
              <set_value name="$table_targets.{$evaltarget}" exact="$resulttargets"/>
            </do_if>
            <remove_value name="$resulttargets"/>
          </do_if>
          <remove_value name="$resulttarget"/>
        </do_elseif>
      </do_if>
    </do_for_each>
  </patch>
  <patch sinceversion="19" early="true">
    <create_group groupname="$sectorgrp"/>
  </patch>
  <patch sinceversion="19">
    <do_if value="this.sector.exists">
      <add_to_group groupname="$sectorgrp" object="this.sector"/>
    </do_if>
  </patch>
  <patch sinceversion="20" early="true">
    <set_value name="$obstructiondelay" exact="0s"/>
  </patch>
  <patch sinceversion="21">
    <do_if value="$waittime?">
      <set_value name="$combinedskill" exact="this.assignedcontrolled.combinedskill"/>
      <set_value name="$forwardweapontarget" exact="null"/>
      <set_value name="$forwardrange" exact="this.assignedcontrolled.maxcombatrange.primary"/>
    </do_if>
  </patch>
  <patch sinceversion="22" early="true">
    <do_if value="$targets_defensibles?">
      <set_value name="$BaseScanWaitTime" exact="4s"/>
    </do_if>
  </patch>
  <patch sinceversion="22">
    <do_if value="$waittime? and $targets_defensibles?">
      <set_value name="$targets_defensibles_list" exact="$targets_defensibles.list"/>
    </do_if>
  </patch>
  <patch sinceversion="23">
    <do_if value="$FiringRange != this.ship.maxcombatrange.all">
      <debug_text text="'Updating fire range from ' + $FiringRange + ' to ' + this.ship.maxcombatrange.all" filter="savegame"/>
    </do_if>
    <set_value name="$FiringRange" exact="this.ship.maxcombatrange.all"/>
  </patch>
  <patch sinceversion="24">
    <do_if value="@$turretmodes.count and not $turretmodes.indexof.{weaponmode.attackenemies} and ($turretmodes.indexof.{weaponmode.attackcapital} or $turretmodes.indexof.{weaponmode.attackfighters})">
      <!-- reset the script -->
      <signal_objects object="this" param="'attack'" param2="null" param3="[null, null, null, null, null, null, null, null, true]"/>
    </do_if>
  </patch>
  <patch sinceversion="25">
    <do_if value="$targets_defensibles.indexof.{this.assignedcontrolled}">
      <set_value name="$evaltarget" exact="this.assignedcontrolled"/>
      <include_interrupt_actions ref="ClearTarget"/>
      <remove_value name="$evaltarget"/>
      <!-- reset, clear all targets -->
      <signal_objects object="this" param="'attack'" param2="null" param3="[null, null, null, null, null, null, null, null, false]"/>
    </do_if>
  </patch>
  <patch sinceversion="27">
    <remove_value name="$table_ammousage"/>
  </patch>
  <patch sinceversion="28">
    <do_if value="not $pilotgroup.count and this.assignedcontrolled.assignedaipilot">
      <add_to_group groupname="$pilotgroup" object="this.assignedcontrolled.assignedaipilot"/>
      <debug_text text="'PATCH: registering pilot: %s %s'.[this.assignedcontrolled.assignedaipilot.knownname, this.assignedcontrolled.assignedaipilot]" filter="savegame"/>
    </do_if>
  </patch>
  <patch sinceversion="29">
    <do_for_each name="$loctarget" in="$targets_fighters" reverse="true">
      <do_if value="not $targets.indexof.{$loctarget}">
        <remove_from_group group="$targets_fighters" object="$loctarget"/>
      </do_if>
    </do_for_each>
    <do_for_each name="$loctarget" in="$targets_capital" reverse="true">
      <do_if value="not $targets.indexof.{$loctarget}">
        <remove_from_group group="$targets_capital" object="$loctarget"/>
      </do_if>
    </do_for_each>
  </patch>
  <patch sinceversion="30">
    <do_if value="@$primarytarget and this.assignedcontrolled.order.id != 'Attack' and this.assignedcontrolled.order.id != 'Attack_Player' and this.assignedcontrolled.order.id != 'Board'">
      <debug_text text="'PATCH: signalling %s %s %s to hold fire.\nprimarytarget: %s %s %s\norder: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$primarytarget.idcode, @$primarytarget.knownname, $primarytarget, this.assignedcontrolled.order.id]" filter="savegame" chance="0"/>
      <!-- reset, clear all targets -->
      <signal_objects object="this" param="'attack'" param2="null" param3="[null, null, null, null, null, null, null, null, false]"/>
    </do_if>
  </patch>
  <patch sinceversion="31">
    <do_if value="not $targets.count and (this.assignedcontrolled.attention ge attention.visible) and ($turretmodes.indexof.{weaponmode.attackenemies} or $turretmodes.indexof.{weaponmode.attackcapital} or $turretmodes.indexof.{weaponmode.attackfighters} or $turretmodes.indexof.{weaponmode.prefercapital} or $turretmodes.indexof.{weaponmode.preferfighters} or $turretmodes.indexof.{weaponmode.prefermissiles} or ($defencedronemode == dronemode.attackenemies and this.assignedcontrolled.hasarmeddefencedrones))">
      <signal_objects object="this" param="'attack'" param2="null" param3="[null, null, null, null, null, null, null, null, false]"/>
    </do_if>
  </patch>
  <patch sinceversion="32">
    <do_if value="this.isplayerowned and this.sector">
      <find_gravidar_contact name="$_contacts" object="this.assignedcontrolled" class="class.defensible" checkoperational="false" docked="false" multiple="true">
        <match_context macro="this.sector.macro"/>
        <match_distance object="this.assignedcontrolled" max="this.assignedcontrolled.maxradarrange"/>
        <match class="class.buildstorage" negate="true"/>
        <match state="componentstate.wreck" negate="true"/>
        <match maybeattackedby="this.assignedcontrolled" negate="true"/>
      </find_gravidar_contact>
      <do_for_each name="$evaltarget" in="$_contacts">
        <do_if value="not $targets_defensibles.indexof.{$evaltarget}">
          <include_interrupt_actions ref="AcquireTarget"/>
          <include_interrupt_actions ref="ClearTarget"/>
          <debug_text text="'PATCH: removing %s %s %s from internal target list'.[@$evaltarget.idcode, @$evaltarget.knownname, $evaltarget]" filter="savegame"/>
          <remove_value name="$resulttargets_high"/>
          <remove_value name="$resulttarget_low"/>
        </do_if>
      </do_for_each>
      <remove_value name="$_contacts"/>
    </do_if>
  </patch>
  <patch sinceversion="33">
    <do_if value="$table_targets.keys.count">
      <do_for_each name="$_lockey" valuename="$_locgroup" in="$table_targets">
        <!-- at least one case where $_locgroup is already a list -->
        <do_if value="typeof $_locgroup == datatype.group">
          <set_value name="$table_targets.{$_lockey}" exact="$_locgroup.list"/>
        </do_if>
      </do_for_each>
    </do_if>
  </patch>
  <patch sinceversion="34">
    <do_for_each name="$_lockey" valuename="$_loclist" in="$table_targets">
      <do_if value="@$_lockey.iscapitalship and not $_loclist.indexof.{$_lockey} and not @$disabletargets.indexof.{$_lockey}">
        <append_to_list name="$_loclist" exact="$_lockey"/>
        <debug_text text="'PATCH: adding capital ship %s %s %s to target list'.[@$_lockey.idcode, @$_lockey.knownname, $_lockey]" filter="savegame"/>
      </do_if>
    </do_for_each>
  </patch>
  <attention min="visible">
    <actions>
      <do_if value="this.sector.exists">
        <add_to_group groupname="$sectorgrp" object="this.sector"/>
      </do_if>

      <label name="Start"/>

      <set_value name="$FiringRange" exact="this.ship.maxcombatrange.all"/>
      <set_value name="$weapons_all" exact="this.ship.turrets.operational.list"/>
      <create_list name="$turretmodes"/>
      <do_all exact="$weapons_all.count" counter="$i">
        <do_if value="not $turretmodes.indexof.{$weapons_all.{$i}.mode}">
          <append_to_list name="$turretmodes" exact="$weapons_all.{$i}.mode"/>
        </do_if>
      </do_all>
      <remove_value name="$weapons_all"/>

      <!-- Go to find enemies if:
            - configuration attack is on
            - There are targets 
            - attackers
      -->
      <!--If not, go to wait -->
      <do_if value="$turretmodes.indexof.{weaponmode.attackenemies} or $turretmodes.indexof.{weaponmode.attackcapital} or $turretmodes.indexof.{weaponmode.attackfighters} or $turretmodes.indexof.{weaponmode.prefercapital} or $turretmodes.indexof.{weaponmode.preferfighters} or $turretmodes.indexof.{weaponmode.prefermissiles} or ($defencedronemode == dronemode.attackenemies and this.assignedcontrolled.hasarmeddefencedrones) or ($turretmodes.indexof.{weaponmode.mining} and this.ship == player.occupiedship) or ($turretmodes.indexof.{weaponmode.autoassist} and $autoassist_active?) or (($defencedronemode == dronemode.autoassist) and $dronetargets.count) or @$primarytarget.canbeattacked or @$targets.count">
        <debug_text text="'%s %s %s %s %s %s'.[$turretmodes.indexof.{weaponmode.attackenemies}, ($defencedronemode == dronemode.attackenemies and this.assignedcontrolled.hasarmeddefencedrones), ($turretmodes.indexof.{weaponmode.mining} and this.ship == player.occupiedship), ($turretmodes.indexof.{weaponmode.autoassist} and $autoassist_active?), @$primarytarget.canbeattacked, @$targets.count]" chance="0"/>
        <resume label="FindEnemies" />
      </do_if>

      <!-- DEFENSIVE MODE -->
      <label name="Wait" />

      <set_alert_level object="this.assignedcontrolled" level="green"/>
      <!-- Stop fire -->
      <cease_fire object="this.assignedcontrolled" excludedweaponmode="weaponmode.towing"/>
      <remove_value name="$isshooting"/>
      <remove_value name="$behaviortargetclasses"/>
      <!-- Recall drones -->
      <signal_objects object="this" param="'recall_defencedrones'"/>
      <run_script name="'lib.recall.subordinates'" chance="0">
        <param name="timeout" value="-1s" comment="recall drones" />
      </run_script>
      <!-- wait for attack signal or updated configurations-->
      <!-- NB: if we are here, we are not firing. -->
      <wait>
        <interrupt>
          <conditions>
            <!-- NB: when a target is selected, two events are dispatched. first with param null, second with param target. -->
            <event_player_changed_target/>
            <check_value value="this.assignedcontrolled.isplayerowned"/>
            <check_any>
              <check_all>
                <check_value value="$turretmodes.indexof.{weaponmode.autoassist} or ($defencedronemode == dronemode.autoassist and this.assignedcontrolled.hasarmeddefencedrones)"/>
                <check_any>
                  <!-- NB: order of checks is important -->
                  <check_value value="@this.assignedcontrolled.mayattack.{event.param}"/>
                  <check_value value="event.param"/>
                  <check_value value="not player.target"/>
                </check_any>
                <set_value name="$locattack"/>
              </check_all>
              <check_all>
                <check_value value="$transportdronemode == dronemode.collectselected"/>
                <check_value value="this.assignedcontrolled == player.occupiedship"/>
                <check_value value="event.param.exists and event.param.isclass.collectable and event.param.canbepickedup"/>
                <check_value value="this.assignedcontrolled.cansee.{event.param}"/>
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <do_if value="event.param">
              <do_if value="$locattack?">
                <do_if value="this.assignedcontrolled.mayattack.{event.param}">
                  <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
                    <do_if value="event.param.canbeattacked and event.param.sector and (event.param.sector == this.sector)">
                      <debug_text text="'setting autoassist turrets to fire upon target: %s %s %s'.[@event.param.idcode, @event.param.knownname, event.param]" chance="$debugchance"/>
                      <!-- NB: this target list will be ignored. target acquisition for autoassist turrets is handled in code. -->
                      <set_turret_targets object="this.assignedcontrolled" target="[event.param]" weaponmode="weaponmode.autoassist"/>
                      <set_value name="$autoassist_active"/>
                    </do_if>
                  </do_if>

                  <do_if value="($defencedronemode == dronemode.autoassist) and this.assignedcontrolled.hasarmeddefencedrones">
                    <set_value name="$evaltarget" exact="event.param"/>
                    <include_interrupt_actions ref="SelectTargets_High"/>
                    <do_if value="@$resulttargets.count">
                      <add_to_group groupname="$dronetargets" list="$resulttargets" replace="true"/>

                      <!-- if any defence drones are already out, simply redirect them to the new target. otherwise, proceed to FindEnemies and launch new ones. -->
                      <do_if value="$group_launcheddefencedrones.count">
                        <do_all exact="$group_launcheddefencedrones.count" counter="$i">
                          <cancel_all_orders object="$group_launcheddefencedrones.{$i}"/>
                          <create_order object="$group_launcheddefencedrones.{$i}" id="'Attack'">
                            <param name="primarytarget" value="$evaltarget"/>
                            <param name="secondarytargets" value="$dronetargets"/>
                            <param name="internalorder" value="true"/>
                            <param name="debugchance" value="$debugchance"/>
                          </create_order>
                        </do_all>
                        <set_value name="$donotlaunchdefencedrones"/>
                      </do_if>
                    </do_if>
                    <remove_value name="$resulttargets"/>
                    <remove_value name="$evaltarget"/>
                  </do_if>
                </do_if>
                <do_elseif value="$autoassist_active?">
                  <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
                    <cease_fire object="this.assignedcontrolled" weaponmode="weaponmode.autoassist"/>
                  </do_if>

                  <!-- defence drones continue attacking previously selected target -->

                  <remove_value name="$autoassist_active"/>
                  <remove_value name="$locattack"/>
                  <resume label="Start"/>
                </do_elseif>
              </do_if>
              <do_else>
                <debug_text text="'player selected collectable %s %s and transport drones are set to collect selected crates.'.[@event.param.knownname, event.param]" chance="$debugchance"/>
                <set_value name="$pickuptargets_container" exact="[event.param]"/>
                <include_interrupt_actions ref="LaunchDrone_Transport"/>

                <resume label="Start"/>
              </do_else>
            </do_if>
            <do_elseif value="not player.target">
              <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
                <debug_text text="'target deselected. autoassist turrets ceasing fire.'" chance="$debugchance"/>
                <!-- player just deselected a target and there is no target. autoassist turrets simply cease firing and we resume waiting. -->
                <cease_fire object="this.assignedcontrolled" weaponmode="weaponmode.autoassist"/>
              </do_if>

              <do_if value="$defencedronemode == dronemode.autoassist">
                <clear_group group="$dronetargets"/>
                <do_all exact="$group_launcheddefencedrones.count" counter="$i">
                  <cancel_all_orders object="$group_launcheddefencedrones.{$i}"/>
                </do_all>
              </do_if>

              <!-- transport drones keep collecting what they were sent out to collect. -->

              <remove_value name="$autoassist_active"/>
              <remove_value name="$locattack"/>
              <resume label="Start"/>
            </do_elseif>
            <remove_value name="$locattack"/>
          </actions>
        </interrupt>
      </wait>

      <!-- Find and update Enemies and Targets -->
      <label name="FindEnemies" />

      <!-- time before which ship re-evaluates targets. refresh here in case pilot or crew gets better.
        scantime * dps also used to define how much damage we could do before we potentially change targets.
        Scan time
          100   0.5s
          80    12.5s
          60    24.5s
          40    36.5s
          20    48.5s
          10    54.5s -->
      <set_value name="$scantime" exact="500ms + ((1.0 - (@this.assignedcontrolled.combinedskill / 100.0)) * 60s)"/>

      <!-- Find (more) targets if no target or other targets are allowed -->
      <!-- NB: include all weaponmodes that do not acquire by event -->
      <do_if value="@$allowothertargets or $turretmodes.indexof.{weaponmode.attackenemies} or $turretmodes.indexof.{weaponmode.attackcapital} or $turretmodes.indexof.{weaponmode.attackfighters} or $turretmodes.indexof.{weaponmode.prefercapital} or $turretmodes.indexof.{weaponmode.preferfighters} or $turretmodes.indexof.{weaponmode.prefermissiles} or ($defencedronemode == dronemode.attackenemies and this.assignedcontrolled.hasarmeddefencedrones)">
        <!-- Clear targets to update them -->
        <clear_group group="$targets"/>
        <clear_group group="$targets_defensibles"/>
        <clear_group group="$targets_capital"/>
        <clear_group group="$targets_fighters"/>
        <clear_table table="$table_targets"/>
        <remove_value name="this.$combat_obstructiondelay"/>
        <do_if value="$defencedronemode == dronemode.attackenemies">
          <clear_group group="$dronetargets"/>
        </do_if>

        <do_if value="this.sector">
          <find_gravidar_contact groupname="$evaltargets" object="this.ship" class="class.defensible" checkoperational="false" docked="false" maybeattackedby="this.ship" multiple="true">
            <match_context macro="this.sector.macro"/>
            <match_distance object="this.assignedcontrolled" max="this.assignedcontrolled.currentradarrange"/>
            <match class="class.buildstorage" negate="true"/>
            <match state="componentstate.wreck" negate="true"/>
          </find_gravidar_contact>
        </do_if>
        <do_if value="@$evaltargets.count">
          <debug_text text="'evaluating %s targets'.[$evaltargets.count]" chance="$debugchance"/>
          <do_for_each name="$evaltarget" in="$evaltargets">
            <do_if value="not $disabletargets.indexof.{$evaltarget} and (not $evaltarget.isclass.ship_xs or $evaltarget.macro.ismacro.{param.boarding.boardingpodmacro})">
              <debug_text text="'target acquired: %s %s %s'.[@$evaltarget.idcode, $evaltarget.knownname, $evaltarget]" chance="$debugchance"/>
              <include_interrupt_actions ref="AcquireTarget"/>
              <do_if value="@$resulttargets_high.count">
                <!-- If $allowothertargets, then add these targets to defend mode turrets too -->
                <do_if value="@$allowothertargets">
                  <add_to_group groupname="$attackers" group="$resulttargets_high"/>
                </do_if>

                <do_if value="$defencedronemode == dronemode.attackenemies">
                  <add_to_group groupname="$dronetargets" group="$resulttargets_high"/>
                  <debug_text text="'target acquired. %s %s %s launching drones against %s %s %s'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $evaltarget.idcode, $evaltarget.knownname, $evaltarget]" chance="$debugchance"/>
                </do_if>
              </do_if>
            </do_if>
            <remove_value name="$resulttargets_high"/>
            <remove_value name="$resulttarget_low"/>
          </do_for_each>
        </do_if>
        <remove_value name="$evaltargets"/>
      </do_if>
      <!-- If no new enemies, update the current ones -->
      <do_else>
        <debug_text text="'cleanup. evaluating %s targets'.[$targets_defensibles.count]" chance="$debugchance"/>
        <do_for_each name="$evaltarget" in="$targets_defensibles" reverse="true">
          <debug_text text="'evaluating: %s %s %s\nnot mayattack: %s\ndocked: %s\nout of range: %s\ndistance: %sm'.[@$evaltarget.idcode, $evaltarget.knownname, $evaltarget, not this.assignedcontrolled.mayattack.{$evaltarget}, @$evaltarget.dock, not this.assignedcontrolled.cansee.{$evaltarget}, this.assignedcontrolled.distanceto.{$evaltarget}]" chance="$debugchance"/>
          <!-- Relation, dock and distance check -->
          <do_if value="not this.assignedcontrolled.mayattack.{$evaltarget} or @$evaltarget.dock or not this.assignedcontrolled.cansee.{$evaltarget} or @$evaltarget.hascontext.{this.assignedcontrolled}">
            <debug_text text="'clearing: %s %s %s'.[@$evaltarget.idcode, $evaltarget.knownname, $evaltarget]" chance="$debugchance"/>
            <include_interrupt_actions ref="ClearTarget"/>
          </do_if>
        </do_for_each>
      </do_else>

      <do_if value="$turretmodes.indexof.{weaponmode.mining} and this.ship == player.occupiedship" comment="turret handling for AI pilots is handled in the respective mining scripts">
        <!-- Clear targets to update them -->
        <find_asteroid_in_cluster name="$miningtargetlist" cluster="this.cluster" refobject="this.ship" canpickup="false" multiple="true" maxdistance="[this.ship.maxcombatrange.{weaponmode.mining}.turrets, 3km].max"/>
        <add_to_group groupname="$miningtargets" list="$miningtargetlist" replace="true"/>
        <remove_value name="$miningtargetlist"/>
        <debug_text text="'found %s asteroids within %sm. max range of turrets with mining weapon mode: %sm'.[$miningtargets.count, [this.ship.maxcombatrange.{weaponmode.mining}.turrets, 3km].max, this.ship.maxcombatrange.{weaponmode.mining}.turrets]" chance="$debugchance"/>
      </do_if>

      <!-- Update Main target (parameter in signal) -->
      <do_if value="@$primarytarget">
        <set_value name="$evaltarget" exact="$primarytarget"/>
        <!-- Relation, dock and distance check -->
        <do_if value="@$evaltarget.canbeattacked and (not $checkrelation or this.ship.mayattack.{$evaltarget}) and not @$evaltarget.dock">
          <include_interrupt_actions ref="AcquireTarget"/>
          <do_if value="@$resulttargets_high.count">
            <add_to_group groupname="$attackers" group="$resulttargets_high"/>
          </do_if>
          <remove_value name="$resulttargets_high"/>
          <remove_value name="$resulttarget_low"/>
        </do_if>
        <do_else>
          <include_interrupt_actions ref="ClearTarget"/>
        </do_else>
        <remove_value name="$evaltarget"/>
      </do_if>
      <!-- Update Secondary Targets -->
      <do_if value="@$secondarytargets.count">
        <do_for_each name="$evaltarget" in="$secondarytargets">
          <!-- Relation, dock and distance check -->
          <do_if value="$evaltarget.canbeattacked and (not $checkrelation or this.assignedcontrolled.mayattack.{$evaltarget}) and not @$evaltarget.dock">
            <include_interrupt_actions ref="AcquireTarget"/>
            <do_if value="@$resulttargets_high.count">
              <add_to_group groupname="$attackers" group="$resulttargets_high"/>
            </do_if>
            <remove_value name="$resulttargets_high"/>
            <remove_value name="$resulttarget_low"/>
          </do_if>
          <do_else>
            <include_interrupt_actions ref="ClearTarget"/>
          </do_else>
        </do_for_each>
      </do_if>

      <label name="Attack" />

      <!-- ok, we have found targets, let's do something about them -->
      <do_if value="this.ship.assignedpilot and (@$targets.count or $dronetargets.count or ($miningtargets.count and this.ship == player.occupiedship))">
        <!-- Simulate the attack -->
        <set_command_action commandaction="commandaction.attacking" />
        <!-- alert level -->
        <set_alert_level object="this.assignedcontrolled" level="red"/>
        <!-- cease fire before updating target information. -->
        <do_if value="@$disabletargets.count">
          <!-- increase scantime to give turrets time to fire before we reset targets. -->
          <set_value name="$scantime" exact="[$scantime, 5s].max"/>
          <do_for_each name="$locmode" in="$turretmodes">
            <do_if value="$locmode != weaponmode.autoassist">
              <cease_fire object="this.assignedcontrolled" weaponmode="$locmode" staydeployed="true"/>
              <remove_value name="$isshooting"/>
            </do_if>
          </do_for_each>
        </do_if>

        <do_all exact="@$targets_defensibles.count" counter="$i">
          <debug_text text="'i: %1 target for %2 is: %3 of class: %4 size: %5'.[$i, this.ship.knownname, $targets_defensibles.{$i}.knownname, $targets_defensibles.{$i}.class, $targets_defensibles.{$i}.size]" chance="$debugchance"/>
          <!-- carrier operational range has to be less than radar range because we lose track of targets once they leave radar range. we want to keep track of them. -->
          <do_if value="(this.ship.distanceto.{$targets_defensibles.{$i}} gt $operationalrange) and $dronetargets.indexof.{$targets_defensibles.{$i}}">
            <remove_from_group group="$dronetargets" object="$targets_defensibles.{$i}"/>
          </do_if>

          <do_if value="$iscarrier and @$targets_defensibles.{$i}.iscapitalship">
            <do_if value="not @$closestthreat.canbeattacked or (this.ship.distanceto.{$targets_defensibles.{$i}} lt this.ship.distanceto.{$closestthreat})">
              <set_value name="$closestthreat" exact="$targets_defensibles.{$i}"/>
            </do_if>
          </do_if>
        </do_all>

        <set_value name="$preferredtarget" exact="@$primarytarget"/>
        <!-- For the primary target -->
        <do_if value="@$primarytarget.canbeattacked">
          <!-- add primary target's subcomponents -->
          <set_value name="$evaltarget" exact="$primarytarget"/>
          <include_interrupt_actions ref="AcquireTarget"/>
          <do_if value="@$resulttargets_high.count">
            <add_to_group groupname="$attackers" group="$resulttargets_high"/>
            <do_if value="$dronetargets.indexof.{$resulttarget_low}">
              <add_to_group groupname="$dronetargets" group="$resulttargets_high"/>
            </do_if>
            <do_if value="@$resulttarget_low.ismodular or @$resulttarget_low.canhaveattackablemodules">
              <!-- if $resulttarget_low.ismodular or canhaveattackablemodules, $resulttargets_high is sorted by distance. first entry is the closest. -->
              <set_value name="$preferredtarget" exact="$resulttargets_high.{1}"/>
              <do_if value="@$aimtarget.canbeattacked">
                <set_value name="$preferredtarget" exact="$aimtarget"/>
                <debug_text text="'switching aim to %s %s.'.[$preferredtarget.knownname, $preferredtarget]" chance="$debugchance"/>
              </do_if>
            </do_if>
          </do_if>
          <debug_text text="'attacking %s %s %s %s.\n preferred target is now: %s %s.\n num targets: %s'.[$evaltarget.class, $evaltarget.idcode, $evaltarget.knownname, $evaltarget, $preferredtarget.knownname, $preferredtarget, $targets.count]" chance="$debugchance"/>
          <remove_value name="$resulttargets_high"/>
          <remove_value name="$resulttarget_low"/>
          <remove_value name="$evaltarget"/>

          <do_if value="$disabletargets.indexof.{$primarytarget} or ( $disabletargets.indexof.{$primarytarget.container} and (not @$behaviortargetclasses.count or not $primarytarget.isclass.{$behaviortargetclasses}) and ($primarytarget.container.hull lt (this.ship.dps.all * ([$scantime, 1s].max)hp) or ($primarytarget.container.hullpercentage + $primarytarget.shieldpercentage) lt $disablehullpercentagethreshold) )">
            <!-- if we have a target that we want to disable, do not shoot at that target, only at its surface elements. note that ships that do not have surface elements and have been designated for disabling will not be fired upon at all. -->
            <set_value name="$preferredtarget" exact="null"/>
          </do_if>
          <!-- if the player is not the pilot and the ship has primary and/or secondary weapons, set them. -->
          <do_elseif value="(this.assignedcontrolled != player.occupiedship) and not this.assignedcontrolled.dock">
            <do_if value="@$isshooting == $preferredtarget">
              <do_for_each name="$locweapon" in="this.assignedcontrolled.weapons.operational.list">
                <do_if value="not $locweapon.isclass.turret and not $locweapon.isreadytofire">
                  <!-- if weapon deactivates, request shoot again to reactivate. -->
                  <debug_text text="'%s %s on %s %s %s not ready to fire'.[$locweapon.knownname, $locweapon.macro, @this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
                  <remove_value name="$isshooting"/>
                  <break/>
                </do_if>
              </do_for_each>
            </do_if>

            <do_if value="@$isshooting != $preferredtarget">
              <!-- NB: $preferredtarget is either:
                a ship,
                a surface element,
                or a station module,
                or null.
                never a station because stations resolve to their origin position which could be empty. -->
              <set_value name="$largetarget" exact="@$preferredtarget.iscapitalship"/>
              <debug_text text="'shooting at %s. large: %s'.[@$preferredtarget.debugname, $largetarget]" chance="$debugchance"/>
              <shoot_at object="this.assignedcontrolled" target="$preferredtarget" largetarget="$largetarget" additional_targets="if not $largetarget then $targets.list else []" fixedtarget="true" />
              <shoot_at object="this.assignedcontrolled" target="$preferredtarget" missiles="true" largetarget="$largetarget" additional_targets="if not $largetarget then $targets.list else []" tolerance="360.0deg" fixedtarget="true" />
              <set_value name="$isshooting" exact="$preferredtarget"/>
            </do_if>
          </do_elseif>
        </do_if>

        <do_all exact="$disabletargets.count" counter="$i">
          <do_if value="@$disabletargets.{$i}.iscapitalship or @$disabletargets.{$i}.ismodular or @$disabletargets.{$i}.canhaveattackablemodules or $disabletargets.{$i}.container.exists">
            <!-- target having a container means either target is a surface element or is docked. -->
            <set_value name="$evaltarget" exact="if $disabletargets.{$i}.container.exists then $disabletargets.{$i}.container else $disabletargets.{$i}"/>
            <do_if value="$behaviortargetclasses.count">
              <find_object_component name="$loctargets" object="$evaltarget" class="$behaviortargetclasses" checkoperational="true" surfaceelement="true" multiple="true" append="true"/>
              <debug_text text="'disabling %s'.[@$evaltarget.debugname]" chance="$debugchance"/>
              <do_if value="$table_targets.{$evaltarget}?">
                <set_value name="$loctargetgroups" exact="[$targets, $attackers, $dronetargets]"/>
                <do_for_each name="$loctarget" in="$table_targets.{$evaltarget}">
                  <do_for_each name="$locgroup" in="$loctargetgroups">
                    <do_if value="$locgroup.indexof.{$loctarget} and not $loctargets.indexof.{$loctarget}">
                      <remove_from_group group="$locgroup" object="$loctarget"/>
                    </do_if>
                  </do_for_each>
                </do_for_each>
                <remove_value name="$loctargetgroups"/>
              </do_if>

              <debug_text text="'acquired %s targets on %s.'.[$loctargets.count, @$evaltarget.debugname]" chance="$debugchance"/>
            </do_if>
            <do_else>
              <find_object_component name="$loctargets" object="$evaltarget" checkoperational="true" surfaceelement="true" multiple="true" append="true"/>
            </do_else>
            <!-- if disabletarget hull is above threshold ... -->
            <do_if value="(@$behaviortargetclasses.count and $primarytarget.isclass.{$behaviortargetclasses}) or ($evaltarget.hull gt (this.ship.dps.turrets.all * ([$scantime, 1s].max)hp) and ($evaltarget.hullpercentage + $evaltarget.shieldpercentage) gt $disablehullpercentagethreshold)">
              <!-- ... and disabletarget has surface elements, only target those surface elements. -->
              <add_to_group groupname="$targets_defensibles" object="$evaltarget"/>
              <set_value name="$table_targets.{$evaltarget}" exact="$loctargets"/>
              <do_if value="$loctargets.count">
                <do_if value="$targets.indexof.{$evaltarget}">
                  <add_to_group groupname="$targets" list="$loctargets"/>
                  <remove_from_group group="$targets" object="$evaltarget"/>
                </do_if>
                <do_if value="$attackers.indexof.{$evaltarget}">
                  <add_to_group groupname="$attackers" list="$loctargets"/>
                  <remove_from_group group="$attackers" object="$evaltarget"/>
                </do_if>
                <do_if value="$dronetargets.indexof.{$evaltarget}">
                  <add_to_group groupname="$dronetargets" list="$loctargets"/>
                  <remove_from_group group="$dronetargets" object="$evaltarget"/>
                </do_if>
              </do_if>
              <!-- ... and disabletarget has no surface elements, fire upon the hull. -->
              <do_elseif value="not $targets.indexof.{$evaltarget}">
                <add_to_group groupname="$targets" object="$evaltarget"/>
              </do_elseif>
            </do_if>
            <!-- if disabletarget hull is below threshold, stop firing at it, -->
            <do_elseif value="$targets_defensibles.indexof.{$evaltarget}">
              <debug_text text="'%s %s hull below threshold. holding fire on target.'.[$evaltarget.knownname, $evaltarget]" chance="$debugchance"/>
              <include_interrupt_actions ref="ClearTarget"/>
            </do_elseif>
            <remove_value name="$loctargets"/>
            <remove_value name="$evaltarget"/>
          </do_if>
          <do_elseif value="$disabletargets.{$i}.isclass.ship">
            <set_value name="$evaltarget" exact="$disabletargets.{$i}"/>
            <do_if value="$evaltarget.hull gt (this.assignedcontrolled.dps.turrets.all * ([$scantime, 1s].max)hp) and ($evaltarget.hullpercentage + $evaltarget.shieldpercentage) gt $disablehullpercentagethreshold">
              <debug_text text="'Acquiring disabletarget: %s %s %s'.[@$evaltarget.idcode, @$evaltarget.knownname, $evaltarget]" chance="$debugchance"/>
              <do_if value="not $targets_defensibles.indexof.{$evaltarget}">
                <add_to_group groupname="$targets_defensibles" object="$evaltarget"/>
              </do_if>
              <do_if value="not $targets.indexof.{$evaltarget}">
                <add_to_group groupname="$targets" object="$evaltarget"/>
              </do_if>
            </do_if>
            <do_elseif value="$targets_defensibles.indexof.{$evaltarget}">
              <debug_text text="'Disabletarget %s %s %s hull below threshold. holding fire on target.'.[@$evaltarget.idcode, @$evaltarget.knownname, $evaltarget]" chance="$debugchance"/>
              <include_interrupt_actions ref="ClearTarget"/>
            </do_elseif>
            <remove_value name="$evaltarget"/>
          </do_elseif>
          <do_else>
            <debug_text text="'disabletarget %s %s %s is of a type that is unsupported.'.[$disabletargets.{$i}.class, $disabletargets.{$i}.knownname, $disabletargets.{$i}.macro]" filter="error"/>
          </do_else>
        </do_all>

        <do_if value="not this.isplayerowned">
          <!-- non player-owned ships use only one weapon mode. throw all targets into one group and allow shoot controller to select targets per turret as appropriate. -->
          <clear_group group="$targets_capital"/>
          <clear_group group="$targets_fighters"/>
          <do_if value="$incomingmissiles.count">
            <add_to_group groupname="$targets" group="$incomingmissiles"/>
          </do_if>
          <do_if value="$attackers.count">
            <add_to_group groupname="$targets" group="$attackers"/>
          </do_if>
          <do_if value="$targets.count">
            <do_for_each name="$locmode" in="$turretmodes">
              <do_if value="$locmode != weaponmode.towing">
                <set_turret_targets object="this.assignedcontrolled" target="$targets.list" weaponmode="$locmode" preferredtarget="$preferredtarget"/>
              </do_if>
            </do_for_each>
          </do_if>
        </do_if>
        <do_else>
          <do_for_each name="$loctarget" in="$targets_defensibles">
            <do_if value="$table_targets.{$loctarget}?">
              <set_value name="$evaltarget" exact="$loctarget"/>
              <include_interrupt_actions ref="ValidateTableTargets"/>
              <remove_value name="$evaltarget"/>
              <do_if value="@$loctarget.iscapitalship or @$loctarget.ismodular">
                <append_list_elements name="$list_capital" other="$table_targets.{$loctarget}" create="true"/>
              </do_if>
              <do_elseif value="$loctarget.isclass.ship">
                <append_list_elements name="$list_fighters" other="$table_targets.{$loctarget}" create="true"/>
              </do_elseif>
            </do_if>
          </do_for_each>
          <do_if value="$list_capital?">
            <add_to_group groupname="$targets_capital" list="$list_capital" replace="true"/>
            <remove_value name="$list_capital"/>
          </do_if>
          <do_else>
            <clear_group group="$targets_capital"/>
          </do_else>
          <do_if value="$list_fighters?">
            <add_to_group groupname="$targets_fighters" list="$list_fighters" replace="true"/>
            <remove_value name="$list_fighters"/>
          </do_if>
          <do_else>
            <clear_group group="$targets_fighters"/>
          </do_else>

          <do_if value="$targets.count">
            <!-- set turret targets (weapon mode: attack enemies) -->
            <do_if value="$turretmodes.indexof.{weaponmode.attackenemies}">
              <debug_text text="'setting attackenemies turrets to fire on %s targets.'.[$targets.count]" chance="$debugchance"/>
              <set_turret_targets object="this.assignedcontrolled" target="$targets.list" weaponmode="weaponmode.attackenemies" preferredtarget="$preferredtarget"/>
            </do_if>
            <!-- set turret targets (weapon mode: prefer capital ships) -->
            <do_if value="$turretmodes.indexof.{weaponmode.prefercapital}">
              <create_list name="$loctargets"/>
              <append_list_elements name="$loctargets" group="$targets_capital"/>
              <append_list_elements name="$loctargets" group="$incomingmissiles"/>
              <append_list_elements name="$loctargets" group="$targets_fighters"/>
              <set_value name="$locpreferred" exact="$preferredtarget"/>
              <do_if value="$targets_capital.count and (not $locpreferred or not $targets_capital.indexof.{$locpreferred})">
                <do_for_each name="$loctarget" in="$targets_capital">
                  <do_if value="$targets_defensibles.indexof.{$loctarget}">
                    <set_value name="$locpreferred" exact="$loctarget"/>
                    <break/>
                  </do_if>
                </do_for_each>
              </do_if>
              <debug_text text="'setting prefercapital turrets to fire on %s targets.'.[$loctargets.count]" chance="$debugchance"/>
              <set_turret_targets object="this.assignedcontrolled" target="$loctargets" weaponmode="weaponmode.prefercapital" preferredtarget="$locpreferred"/>
              <remove_value name="$loctargets"/>
            </do_if>
            <!-- set turret targets (weapon mode: prefer fighters) -->
            <do_if value="$turretmodes.indexof.{weaponmode.preferfighters}">
              <create_list name="$loctargets"/>
              <append_list_elements name="$loctargets" group="$targets_fighters"/>
              <append_list_elements name="$loctargets" group="$incomingmissiles"/>
              <append_list_elements name="$loctargets" group="$targets_capital"/>
              <set_value name="$locpreferred" exact="$preferredtarget"/>
              <do_if value="$targets_fighters.count and (not $locpreferred or not $targets_fighters.indexof.{$locpreferred})">
                <set_value name="$locpreferred" exact="$targets_fighters.random"/>
              </do_if>
              <debug_text text="'setting preferfighters turrets to fire on %s targets.'.[$loctargets.count]" chance="$debugchance"/>
              <set_turret_targets object="this.assignedcontrolled" target="$loctargets" weaponmode="weaponmode.preferfighters" preferredtarget="$locpreferred"/>
              <remove_value name="$loctargets"/>
            </do_if>
            <!-- set turret targets (weapon mode: prefer missiles) -->
            <do_if value="$turretmodes.indexof.{weaponmode.prefermissiles}">
              <create_list name="$loctargets"/>
              <append_list_elements name="$loctargets" group="$incomingmissiles"/>
              <append_list_elements name="$loctargets" group="$targets_fighters"/>
              <append_list_elements name="$loctargets" group="$targets_capital"/>
              <set_value name="$locpreferred" exact="$preferredtarget"/>
              <do_if value="$incomingmissiles.count and (not $locpreferred or not $incomingmissiles.indexof.{$locpreferred})">
                <set_value name="$locpreferred" exact="$incomingmissiles.random"/>
              </do_if>
              <debug_text text="'setting prefermissiles turrets to fire on %s targets.'.[$loctargets.count]" chance="$debugchance"/>
              <set_turret_targets object="this.assignedcontrolled" target="$loctargets" weaponmode="weaponmode.prefermissiles" preferredtarget="$locpreferred"/>
              <remove_value name="$loctargets"/>
            </do_if>
          </do_if>
          <!-- weapon mode: attack capital ships -->
          <do_if value="$targets_capital.count and $turretmodes.indexof.{weaponmode.attackcapital}">
            <set_value name="$locpreferred" exact="$preferredtarget"/>
            <do_if value="not $locpreferred or not $targets_capital.indexof.{$locpreferred}">
              <do_for_each name="$loctarget" in="$targets_capital">
                <do_if value="$targets_defensibles.indexof.{$loctarget}">
                  <set_value name="$locpreferred" exact="$loctarget"/>
                  <break/>
                </do_if>
              </do_for_each>
            </do_if>
            <debug_text text="'setting attackcapital turrets to fire on %s targets.'.[$targets_capital.count]" chance="$debugchance"/>
            <set_turret_targets object="this.ship" target="$targets_capital.list" weaponmode="weaponmode.attackcapital" preferredtarget="$locpreferred"/>
          </do_if>
          <!-- weapon mode: attack fighters -->
          <do_if value="$targets_fighters.count and $turretmodes.indexof.{weaponmode.attackfighters}">
            <set_value name="$locpreferred" exact="$preferredtarget"/>
            <do_if value="not $locpreferred or not $targets_fighters.indexof.{$locpreferred}">
              <set_value name="$locpreferred" exact="$targets_fighters.random"/>
            </do_if>
            <debug_text text="'setting attackfighters turrets to fire on %s targets.'.[$targets_fighters.count]" chance="$debugchance"/>
            <set_turret_targets object="this.ship" target="$targets_fighters.list" weaponmode="weaponmode.attackfighters" preferredtarget="$locpreferred"/>
          </do_if>
          <!-- set turret targets (weapon mode: defend) -->
          <do_if value="$attackers.count and $turretmodes.indexof.{weaponmode.defend}" >
            <set_value name="$locpreferred" exact="$preferredtarget"/>
            <do_if value="not $locpreferred or not $attackers.indexof.{$locpreferred}">
              <set_value name="$locpreferred" exact="$attackers.random"/>
            </do_if>
            <debug_text text="'setting defend turrets to fire on %s targets.'.[$attackers.count]" chance="$debugchance"/>
            <set_turret_targets object="this.ship" target="$attackers.list" weaponmode="weaponmode.defend" preferredtarget="$locpreferred"/>
          </do_if>
          <!-- set turret targets (weapon mode: missile defend) -->
          <do_if value="$incomingmissiles.count and $turretmodes.indexof.{weaponmode.missiledefence}">
            <set_value name="$locpreferred" exact="$preferredtarget"/>
            <do_if value="not $locpreferred or not $incomingmissiles.indexof.{$locpreferred}">
              <set_value name="$locpreferred" exact="$incomingmissiles.random"/>
            </do_if>
            <debug_text text="'setting missiledefence turrets to fire on %s targets.'.[$incomingmissiles.count]" chance="$debugchance"/>
            <set_turret_targets object="this.ship" target="$incomingmissiles.list" weaponmode="weaponmode.missiledefence" preferredtarget="$locpreferred"/>
          </do_if>
          <!-- set turret targets (weapon mode: mining) -->
          <do_if value="$miningtargets.count and $turretmodes.indexof.{weaponmode.mining} and this.ship == player.occupiedship">
            <debug_text text="'setting mining turrets to fire on %s asteroids'.[$miningtargets.count]" chance="$debugchance"/>
            <set_turret_targets object="this.ship" target="$miningtargets.list" weaponmode="weaponmode.mining"/>
          </do_if>
          <remove_value name="$locpreferred"/>
        </do_else>

        <include_interrupt_actions ref="CapitalLaunchFighters"/>
        <!-- adding a tiny wait to prevent carriers from sending the same ships against different targets. -->
        <wait min="11ms" max="17ms"/>

        <!-- Launch drones. Improves with NPC skill.
          we do not launch another group of drones until all members of this group have been launched.
          this.$launchedunitcount incremented and cleared in move.undock
            may also be cleared in lib.recall.subordinates -->
        <do_if value="$dronetargets.count and not this.$launchedunitcount? and this.assignedcontrolled.units.{unitcategory.defence}.count and not this.assignedcontrolled.zone.isclass.highway and not this.assignedcontrolled.travel.active">
          <!-- Better crews, launch with less time delay
                100 combinedskill   2 wings every second,
                80 combinedskill    once every 12.5 seconds,
                60 combinedskill    once every 24.5 seconds,
                40 combinedskill    once every 36.5 seconds,
                20 combinedskill    once every 48.5 seconds,
                0 combinedskill     once every minute. -->
          <!-- NB: $donotlaunchdefencedrones only set if defencedronemode is dronemode.autoassist and we already have drones in the air. -->
          <do_if value="not $donotlaunchdefencedrones? and this.assignedcontrolled.hasarmeddefencedrones">
            <do_if value="player.age" min="$lastdronelaunch + 500ms + ((1.0 - (this.assignedcontrolled.combinedskill / 100.0)) * 60s)">
              <set_value name="$lastdronelaunch" exact="player.age"/>
              <!-- num of units launched per squad depends on pilot combat skill and availability of launch tubes.
                 assuming 10 launch tubes:
                  5 stars   3 units per squad,
                  4 stars   4 units per squad,
                  3 stars   6 units per squad,
                  2 stars   8 units per squad,
                  0-1 star  10 units per squad.
                effective time needed to launch 30 units:
                  100 combinedskill,  5 combat  5 seconds,
                  80 combinedskill,   4 combat  93.75 seconds,
                  60 combinedskill,   3 combat  122.5 seconds,
                  40 combinedskill,   2 combat  136.875 seconds,
                  20 combinedskill,   1 combat  145.5 seconds,
                  0 combinedskill,    0 combat  180 seconds. -->
              <!-- quickly launch several discrete wings.
                roughly inversely proportional to pilot skill -->
              <do_if value="not $num_launchtubes and $num_dronedocks">
                <do_if value="$defencedronemode == dronemode.autoassist">
                  <!-- if autoassist, drones will only engage one target. no advantage to spreading them out. -->
                  <set_value name="$maxnum_dronespersquad" exact="$num_dronedocks"/>
                </do_if>
                <do_else>
                  <set_value name="$maxnum_dronespersquad" exact="[[$num_dronedocks * [1.2 - (@this.ship.pilot.skill.piloting / 15.0), 1.0].min, 1].max, this.ship.availableunits.{unitcategory.defence}.count].min"/>
                </do_else>
              </do_if>
              <do_else>
                <do_if value="$defencedronemode == dronemode.autoassist">
                  <set_value name="$maxnum_dronespersquad" exact="$num_launchtubes"/>
                </do_if>
                <do_else>
                  <set_value name="$maxnum_dronespersquad" exact="[[$num_launchtubes * [1.2 - (@this.ship.pilot.skill.piloting / 15.0), 1.0].min, 1].max, this.ship.availableunits.{unitcategory.defence}.count].min"/>
                </do_else>
              </do_else>
              <!-- dronetargets is a group because there is always a delay between when it is populated and when it is acted upon, but it has to be a list so that it can be shuffled. otherwise, consecutive groups of units will go after the same target. -->
              <set_value name="$list_dronetargets" exact="$dronetargets.list"/>
              <shuffle_list list="$list_dronetargets"/>
              <!-- only launch units if a valid target is actually within range. -->
              <do_all exact="$list_dronetargets.count" counter="$i">
                <!-- prioritize closer targets -->
                <do_if value="this.assignedcontrolled.distanceto.{$list_dronetargets.{$i}} lt (this.assignedcontrolled.currentradarrange * 0.5m)">
                  <set_value name="$dronetarget" exact="$list_dronetargets.{$i}"/>
                  <break/>
                </do_if>
                <do_elseif value="this.assignedcontrolled.cansee.{$list_dronetargets.{$i}}">
                  <do_if value="$dronetarget?">
                    <do_if value="this.assignedcontrolled.distanceto.{$list_dronetargets.{$i}} lt this.assignedcontrolled.distanceto.{$dronetarget}">
                      <set_value name="$dronetarget" exact="$list_dronetargets.{$i}"/>
                    </do_if>
                  </do_if>
                  <do_else>
                    <set_value name="$dronetarget" exact="$list_dronetargets.{$i}"/>
                  </do_else>
                </do_elseif>
              </do_all>
              <do_if value="@$dronetarget.canbeattacked">
                <set_value name="$locnumdrones" min="[($maxnum_dronespersquad * 0.8)i, 1].max" max="[($maxnum_dronespersquad)i, 1].max"/>
                <do_all exact="$group_launcheddefencedrones.count" counter="$i">
                  <do_if value="not @$group_launcheddefencedrones.{$i}.commander.isunit and (@$group_launcheddefencedrones.{$i}.order.id != 'Attack')">
                    <set_value name="$drone" exact="$group_launcheddefencedrones.{$i}"/>
                    <set_value name="$locnumdrones" exact="1"/>
                    <debug_text text="'%s redirecting %s to attack %s. current order: %s'.[@this.assignedcontrolled.debugname, @$drone.debugname, @$dronetarget.debugname, @$drone.order.id]" chance="$debugchance"/>
                    <break/>
                  </do_if>
                </do_all>

                <do_if value="not $num_launchtubes and $locnumdrones gt 1">
                  <!-- this.$launchedunitcount incremented in move.undock as each drone is launched, cleared in move.undock once this.$launchedunitcount.{1} == this.$launchedunitcount.{2} -->
                  <set_value name="this.$launchedunitcount" exact="[0, $locnumdrones]"/>
                </do_if>

                <do_if value="not @$drone and this.assignedcontrolled.availableunits.{unitcategory.defence}.count">
                  <launch_drone name="$drone" object="this.object" exact="$locnumdrones" category="unitcategory.defence"/>
                  <add_to_group groupname="$group_launcheddefencedrones" object="$drone"/>
                  <debug_text text="player.age + ': launching %s drones. next drones will be launched in at least %s seconds. skill: %s'.[$locnumdrones, ($lastdronelaunch + 500ms + ((1.0 - (this.assignedcontrolled.combinedskill / 100.0)) * 60s)) - player.age, @this.ship.pilot.skill.piloting]" chance="$debugchance"/>
                </do_if>

                <do_if value="@$drone">
                  <!-- Set them to our relation -->
                  <do_if value="not $drone.mayattack.{$dronetarget} and not this.object.isplayerowned">
                    <set_relation_boost object="$drone" otherobject="$dronetarget" value="this.object.relationto.{$dronetarget}" silent="true" />
                  </do_if>

                  <do_if value="not $num_launchtubes and $locnumdrones gt 1">
                    <!-- form on this.assignedcontrolled until all drones are launched. -->
                    <create_order object="$drone" id="'Escort'">
                      <param name="target" value="this.assignedcontrolled"/>
                      <!-- HACK -->
                      <param name="timeout" value="24h" comment="has to be a large positive number, otherwise order will immediately complete since other orders are queued."/>
                      <param name="releasesignal" value="['units_go']"/>
                      <param name="debugchance" value="$debugchance"/>
                    </create_order>
                  </do_if>

                  <!-- Attack order! -->
                  <create_order object="$drone" id="'Attack'">
                    <param name="primarytarget" value="$dronetarget" />
                    <param name="secondarytargets" value="$list_dronetargets" />
                    <param name="escort" value="this.object" />
                    <param name="pursuetargets" value="false"/>
                    <param name="pursuedistance" value="this.ship.maxradarrange" />
                    <param name="allowothertargets" value="true"/>
                    <param name="checkrelation" value="$checkrelation" />
                    <param name="disable" value="@$disabletargets.indexof.{$dronetarget} or ($dronetarget.container and $disabletargets.indexof.{$dronetarget.container})"/>
                    <param name="disablehullpercentagethreshold" value="@$disablehullpercentagethreshold"/>
                    <param name="behaviortargetclasses" value="if @$behaviortargetclasses.count then $behaviortargetclasses else []"/>
                    <param name="internalorder" value="true"/>
                    <param name="debugchance" value="$debugchance"/>
                  </create_order>

                  <do_if value="$defencedronemode != dronemode.escort">
                    <!-- Dock order for after finishing -->
                    <create_order object="$drone" id="'DockAndWait'" default="true">
                      <param name="destination" value="this.assignedcontrolled"/>
                      <param name="dockfollowers" value="true"/>
                      <param name="debugchance" value="$debugchance"/>
                    </create_order>
                  </do_if>
                  <do_else>
                    <create_order object="$drone" id="'Escort'" default="true"/>
                  </do_else>

                  <do_all exact="$drone.allsubordinates.count" counter="$i">
                    <set_value name="$locsub" exact="$drone.allsubordinates.{$i}"/>
                    <add_to_group groupname="$group_launcheddefencedrones" object="$locsub"/>
                    <do_if value="this.isplayerowned">
                      <set_relation_boost object="$dronetarget" otherobject="$locsub" value="this.assignedcontrolled.relationto.{$dronetarget}" silent="true"/>
                    </do_if>
                    <do_else>
                      <set_relation_boost object="$locsub" otherobject="$dronetarget" value="this.assignedcontrolled.relationto.{$dronetarget}" silent="true"/>
                    </do_else>

                    <do_if value="$defencedronemode != dronemode.escort">
                      <create_order object="$locsub" id="'DockAndWait'" default="true">
                        <param name="destination" value="this.assignedcontrolled"/>
                        <param name="dockfollowers" value="true"/>
                        <param name="debugchance" value="$debugchance"/>
                      </create_order>
                    </do_if>
                    <do_else>
                      <!-- default order in case $drone is killed is to escort the ship that launched them. -->
                      <create_order object="$locsub" id="'Escort'" default="true">
                        <param name="target" value="this.assignedcontrolled"/>
                      </create_order>
                    </do_else>

                    <!-- non-default order at the bottom of this ship's order queue to escort $drone. -->
                    <create_order object="$locsub" id="'Escort'"/>
                  </do_all>
                  <remove_value name="$locsub"/>

                  <remove_value name="$drone" />
                </do_if>
                <do_else>
                  <debug_text text="'no drones were launched.'" chance="$debugchance"/>
                </do_else>
                <remove_value name="$locnumdrones"/>
                <remove_value name="$dronetarget" />
              </do_if>
              <do_else>
                <debug_text text="'no drone targets are within radar range.'" chance="$debugchance"/>
              </do_else>
              <remove_value name="$list_dronetargets"/>
            </do_if>
          </do_if>
          <do_else>
            <remove_value name="$donotlaunchdefencedrones"/>
          </do_else>
        </do_if>
        <do_if value="$defencedronemode != dronemode.autoassist">
          <!-- Clear drone targets, it will be repopulated in the next iteration (if there are any) -->
          <clear_group group="$dronetargets"/>
        </do_if>
      </do_if>
      <do_else>
        <set_alert_level object="this.assignedcontrolled" level="green"/>
        <do_if value="$autoassist_active?">
          <!-- do nothing. go straight to wait. target selection handled in code. -->
        </do_if>
        <do_elseif value="@$hadnotargets">
          <!-- looped back and had no targets before scanning, still no targets after. no need to clear. clearing can cause conflict with scripts that involve pilot firing. -->
        </do_elseif>
        <do_else>
          <do_for_each name="$locmode" in="$turretmodes">
            <do_if value="$locmode != weaponmode.towing">
              <do_if value="$locmode != weaponmode.mining or @this.assignedcontrolled.order.id != 'MiningCollect'">
                <cease_fire object="this.assignedcontrolled" weaponmode="$locmode"/>
              </do_if>
            </do_if>
          </do_for_each>
          <remove_value name="$isshooting"/>
          <!-- Simulate the stand by -->
          <set_command_action commandaction="commandaction.standingby"/>
          <do_all exact="$group_launcheddefencedrones.count" counter="$i">
            <cancel_all_orders object="$group_launcheddefencedrones.{$i}"/>
          </do_all>
          <clear_group group="$dronetargets"/>
          <clear_group group="$targets"/>
          <clear_group group="$targets_defensibles"/>
          <clear_group group="$targets_capital"/>
          <clear_group group="$targets_fighters"/>
          <clear_group group="$miningtargets"/>
          <clear_group group="$attackers"/>
          <clear_table table="$table_targets"/>
          <remove_value name="$closestthreat"/>
          <remove_value name="this.$combat_obstructiondelay"/>
        </do_else>
      </do_else>
      <remove_value name="$hadnotargets"/>

      <!-- NB: if we are here, we are firing. -->
      <wait exact="$scantime" comment="To avoid performance problems">
        <interrupt>
          <conditions>
            <check_any>
              <!-- Enemy found (exclude xs) -->
              <check_all>
                <event_object_enemy_found object="this.ship" comment="this checks may be attacked by"/>
                <check_value value="not event.param.isclass.ship_xs or event.param.macro.ismacro.{param.boarding.boardingpodmacro} or (this.ship == player.controlled)"/>
              </check_all>
              <!-- Auto-assist check -->
              <check_all>
                <!-- NB: when a target is selected, two events are dispatched. first with param null, second with param target. -->
                <event_player_changed_target/>
                <check_value value="this.assignedcontrolled.isplayerowned"/>
                <check_any>
                  <check_all>
                    <check_value value="$turretmodes.indexof.{weaponmode.autoassist} or ($defencedronemode == dronemode.autoassist and this.assignedcontrolled.hasarmeddefencedrones)"/>
                    <check_any>
                      <!-- NB: order of checks is important -->
                      <check_value value="@this.assignedcontrolled.mayattack.{event.param}"/>
                      <check_value value="event.param"/>
                      <check_value value="not player.target"/>
                    </check_any>
                    <set_value name="$locattack"/>
                  </check_all>
                  <check_all>
                    <check_value value="$transportdronemode == dronemode.collectselected"/>
                    <check_value value="this.assignedcontrolled == player.occupiedship"/>
                    <check_value value="event.param.exists and event.param.isclass.collectable and event.param.canbepickedup"/>
                    <check_value value="this.assignedcontrolled.cansee.{event.param}"/>
                  </check_all>
                </check_any>
              </check_all>
              <check_all>
                <event_object_attacked group="$disabletargets"/>
                <check_value value="$targets.indexof.{event.object}"/>
                <check_value value="(event.object.shieldpercentage + event.object.hullpercentage) lt $disablehullpercentagethreshold"/>
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'event %1 (%2, %3)'.[event.name, @event.param.name, event.param]" chance="$debugchance" />
            <do_if value="event.name == 'event_player_changed_target'">
              <do_if value="event.param">
                <do_if value="$locattack?">
                  <do_if value="this.assignedcontrolled.mayattack.{event.param}">
                    <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
                      <do_if value="event.param.canbeattacked and event.param.sector and (event.param.sector == this.sector)">
                        <debug_text text="'setting autoassist turrets to fire upon target: %s'.[@event.param.debugname]" chance="$debugchance"/>
                        <!-- NB: this target list will be ignored. target acquisition for autoassist turrets is handled in code. -->
                        <set_turret_targets object="this.assignedcontrolled" target="[event.param]" weaponmode="weaponmode.autoassist"/>
                        <set_value name="$autoassist_active"/>
                      </do_if>
                    </do_if>

                    <do_if value="($defencedronemode == dronemode.autoassist) and this.assignedcontrolled.hasarmeddefencedrones">
                      <set_value name="$evaltarget" exact="event.param"/>
                      <include_interrupt_actions ref="SelectTargets_High"/>
                      <do_if value="@$resulttargets.count">
                        <add_to_group groupname="$dronetargets" list="$resulttargets" replace="true"/>

                        <!-- if any defence drones are already out, simply redirect them to the new target. otherwise, proceed to FindEnemies and launch new ones. -->
                        <do_if value="$group_launcheddefencedrones.count">
                          <do_all exact="$group_launcheddefencedrones.count" counter="$i">
                            <cancel_all_orders object="$group_launcheddefencedrones.{$i}"/>
                            <create_order object="$group_launcheddefencedrones.{$i}" id="'Attack'">
                              <param name="primarytarget" value="$evaltarget"/>
                              <param name="secondarytargets" value="$dronetargets"/>
                              <param name="internalorder" value="true"/>
                              <param name="debugchance" value="$debugchance"/>
                            </create_order>
                          </do_all>
                          <set_value name="$donotlaunchdefencedrones"/>
                        </do_if>
                      </do_if>
                      <remove_value name="$resulttargets"/>
                      <remove_value name="$evaltarget"/>
                    </do_if>
                    <remove_value name="$locattack"/>
                    <resume label="FindEnemies"/>
                  </do_if>
                  <do_elseif value="$autoassist_active?">
                    <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
                      <cease_fire object="this.assignedcontrolled" weaponmode="weaponmode.autoassist"/>
                    </do_if>

                    <!-- defence drones continue attacking previously designated target -->

                    <remove_value name="$autoassist_active"/>
                  </do_elseif>
                </do_if>
                <do_else>
                  <debug_text text="'player selected collectable %s %s and transport drones are set to collect selected crates.'.[@event.param.knownname, event.param]" chance="$debugchance"/>
                  <set_value name="$pickuptargets_container" exact="[event.param]"/>
                  <include_interrupt_actions ref="LaunchDrone_Transport"/>
                </do_else>
              </do_if>
              <do_elseif value="not player.target">
                <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
                  <debug_text text="'target deselected. autoassist turrets ceasing fire.'" chance="$debugchance"/>
                  <!-- player just deselected a target and there is no target. autoassist turrets simply cease firing and we resume waiting. -->
                  <cease_fire object="this.assignedcontrolled" weaponmode="weaponmode.autoassist"/>
                </do_if>

                <do_if value="$defencedronemode == dronemode.autoassist">
                  <clear_group group="$dronetargets"/>
                  <do_all exact="$group_launcheddefencedrones.count" counter="$i">
                    <cancel_all_orders object="$group_launcheddefencedrones.{$i}"/>
                  </do_all>
                </do_if>

                <!-- transport drones keep collecting what they were sent out to collect. -->

                <remove_value name="$autoassist_active"/>
              </do_elseif>
            </do_if>
            <do_elseif value="event.name == 'event_object_attacked'">
              <debug_text text="'disable target: %s under hull threshold.\ncurrent hull percentage: %s\nthreshold: %s.\nre-evaluating targets.'.[@event.object.debugname, event.object.hullpercentage, $disablehullpercentagethreshold]" chance="$debugchance"/>
            </do_elseif>
            <remove_value name="$locattack"/>
          </actions>
        </interrupt>
      </wait>

      <set_value name="$hadnotargets" exact="$targets.count gt 0"/>

      <resume label="Start" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <do_if value="this.sector.exists">
        <add_to_group groupname="$sectorgrp" object="this.sector"/>
      </do_if>

      <label name="Start"/>

      <set_value name="$FiringRange" exact="this.ship.maxcombatrange.all"/>
      <create_list name="$turretmodes"/>
      <do_for_each name="$operationalturret" in="this.ship.turrets.operational.list">
        <do_if value="not $turretmodes.indexof.{$operationalturret.mode}">
          <append_to_list name="$turretmodes" exact="$operationalturret.mode"/>
        </do_if>
      </do_for_each>

      <!-- Go to find enemies if:
            - configuration attack is on
            - Operational target
            - Hold Fire mode is off -->
      <!--If not, go to wait -->
      <do_if value="@$primarytarget.canbeattacked or @$targets.count">
        <resume label="FindEnemies" />
      </do_if>

      <!-- DEFENSIVE MODE -->
      <label name="Wait" />
      <!-- Stop fire -->
      <cease_fire object="this.assignedcontrolled" excludedweaponmode="weaponmode.towing"/>
      <remove_value name="$isshooting"/>
      <!-- Recall drones -->
      <signal_objects object="this" param="'recall_defencedrones'"/>
      <run_script name="'lib.recall.subordinates'" chance="0">
        <param name="timeout" value="-1s" comment="recall drones" />
      </run_script>
      <!-- wait for attack signal or updated configurations-->
      <wait>
        <interrupt>
          <conditions>
            <event_object_enemy_found object="this.assignedcontrolled"/>
            <check_value value="$turretmodes.indexof.{weaponmode.attackenemies} or $turretmodes.indexof.{weaponmode.attackcapital} or $turretmodes.indexof.{weaponmode.attackfighters} or $turretmodes.indexof.{weaponmode.prefercapital} or $turretmodes.indexof.{weaponmode.preferfighters} or $turretmodes.indexof.{weaponmode.prefermissiles} or ($defencedronemode == dronemode.attackenemies and this.assignedcontrolled.hasarmeddefencedrones)"/>
          </conditions>
        </interrupt>
        <on_attentionchange>
          <do_if value="$turretmodes.indexof.{weaponmode.attackenemies} or $turretmodes.indexof.{weaponmode.attackcapital} or $turretmodes.indexof.{weaponmode.attackfighters} or $turretmodes.indexof.{weaponmode.prefercapital} or $turretmodes.indexof.{weaponmode.preferfighters} or $turretmodes.indexof.{weaponmode.prefermissiles} or ($defencedronemode == dronemode.attackenemies and this.assignedcontrolled.hasarmeddefencedrones)">
            <resume label="FindEnemies"/>
          </do_if>
        </on_attentionchange>
      </wait>

      <!-- Find and update Enemies and Targets -->
      <label name="FindEnemies" />

      <!-- Find (more) targets if no target or other targets are allowed -->
      <do_if value="@$allowothertargets or $turretmodes.indexof.{weaponmode.attackenemies} or $turretmodes.indexof.{weaponmode.attackcapital} or $turretmodes.indexof.{weaponmode.attackfighters} or $turretmodes.indexof.{weaponmode.prefercapital} or $turretmodes.indexof.{weaponmode.preferfighters} or $turretmodes.indexof.{weaponmode.prefermissiles} or ($defencedronemode == dronemode.attackenemies and this.assignedcontrolled.hasarmeddefencedrones)">
        <!-- Clear targets to update them -->
        <clear_group group="$targets"/>
        <clear_group group="$targets_defensibles"/>
        <clear_group group="$targets_capital"/>
        <clear_group group="$targets_fighters"/>
        <clear_table table="$table_targets"/>
        <remove_value name="this.$combat_obstructiondelay"/>
        <do_if value="$defencedronemode == dronemode.attackenemies">
          <clear_group group="$dronetargets"/>
        </do_if>
        <do_if value="this.sector">
          <find_gravidar_contact groupname="$evaltargets" object="this.ship" class="class.defensible" checkoperational="false" docked="false" maybeattackedby="this.ship" multiple="true">
            <match_context macro="this.sector.macro"/>
            <match_distance object="this.assignedcontrolled" max="this.assignedcontrolled.currentradarrange"/>
            <match class="class.buildstorage" negate="true"/>
            <match state="componentstate.wreck" negate="true"/>
          </find_gravidar_contact>
        </do_if>
        <do_if value="@$evaltargets.count">
          <do_for_each name="$evaltarget" in="$evaltargets">
            <do_if value="not $disabletargets.indexof.{$evaltarget} and (not $evaltarget.isclass.ship_xs or $evaltarget.macro.ismacro.{param.boarding.boardingpodmacro})">
              <include_interrupt_actions ref="AcquireTarget"/>
              <do_if value="@$resulttargets_high.count">
                <!-- If $allowothertargets, then add these targets to defend mode turrets too -->
                <do_if value="@$allowothertargets or $turretmodes.indexof.{weaponmode.attackenemies} or $turretmodes.indexof.{weaponmode.prefercapital} or $turretmodes.indexof.{weaponmode.preferfighters} or $turretmodes.indexof.{weaponmode.prefermissiles}">
                  <add_to_group groupname="$attackers" group="$resulttargets_high"/>
                </do_if>

                <do_if value="$defencedronemode == dronemode.attackenemies">
                  <add_to_group groupname="$dronetargets" group="$resulttargets_high"/>
                </do_if>
              </do_if>
            </do_if>
            <remove_value name="$resulttargets_high"/>
            <remove_value name="$resulttarget_low"/>
          </do_for_each>
        </do_if>
        <remove_value name="$evaltargets"/>
      </do_if>
      <!-- If no new enemies, update the current ones -->
      <do_else>
        <do_for_each name="$evaltarget" in="$targets_defensibles" reverse="true">
          <!-- Relation, dock and distance check -->
          <do_if value="not this.assignedcontrolled.mayattack.{$evaltarget} or @$evaltarget.dock or not this.assignedcontrolled.cansee.{$evaltarget}">
            <include_interrupt_actions ref="ClearTarget"/>
          </do_if>
        </do_for_each>
      </do_else>

      <!-- Update Main target (parameter in signal) -->
      <do_if value="@$primarytarget">
        <set_value name="$evaltarget" exact="$primarytarget"/>
        <!-- Relation, dock and distance check -->
        <do_if value="@$evaltarget.canbeattacked and (not $checkrelation or this.ship.mayattack.{$evaltarget}) and not @$evaltarget.dock">
          <include_interrupt_actions ref="AcquireTarget"/>
          <do_if value="@$resulttargets_high.count">
            <add_to_group groupname="$attackers" group="$resulttargets_high"/>
          </do_if>
          <remove_value name="$resulttargets_high"/>
          <remove_value name="$resulttarget_low"/>
        </do_if>
        <do_else>
          <include_interrupt_actions ref="ClearTarget"/>
        </do_else>
        <remove_value name="$evaltarget"/>
      </do_if>
      <!-- Update Secondary Targets -->
      <do_if value="@$secondarytargets.count">
        <do_for_each name="$evaltarget" in="$secondarytargets">
          <!-- Relation, dock and distance check -->
          <do_if value="$evaltarget.canbeattacked and (not $checkrelation or this.assignedcontrolled.mayattack.{$evaltarget}) and not @$evaltarget.dock">
            <include_interrupt_actions ref="AcquireTarget"/>
            <do_if value="@$resulttargets_high.count">
              <add_to_group groupname="$attackers" group="$resulttargets_high"/>
            </do_if>
            <remove_value name="$resulttargets_high"/>
            <remove_value name="$resulttarget_low"/>
          </do_if>
          <do_else>
            <include_interrupt_actions ref="ClearTarget"/>
          </do_else>
        </do_for_each>
      </do_if>

      <label name="Attack" />

      <remove_value name="$isshooting"/>

      <!-- Fight Simulation -->
      <do_if value="@$targets_defensibles.count" min="1">
        <!-- Simulate the attack -->
        <set_command_action commandaction="commandaction.attacking" />
        <set_turret_targets object="this.ship" />
      </do_if>
      <do_else>
        <!-- Simulate the stand by -->
        <set_command_action commandaction="commandaction.standingby" />
        <cease_fire object="this.assignedcontrolled" excludedweaponmode="weaponmode.towing"/>
        <clear_group group="$targets"/>
        <clear_group group="$targets_defensibles"/>
        <clear_group group="$targets_capital"/>
        <clear_group group="$targets_fighters"/>
        <clear_table table="$table_targets"/>
        <remove_value name="this.$combat_obstructiondelay"/>
      </do_else>

      <do_if value="not $attacktime?">
        <set_value name="$attacktime" min="player.age + 30s" max="player.age + 40s" />
        <remove_value name="$forwardweapontime"/>
      </do_if>
      <set_value name="$waittime" exact="1s" />

      <debug_text text="'unknown. fight. targets: ' + @$targets_defensibles " chance="0" />
      <!-- For each enemy, apply strength-->
      <do_while value="player.age lt $attacktime and this.ship.pilot and @$targets_defensibles.count and this.sector">

        <set_value name="$FiringRange" exact="this.ship.maxcombatrange.all"/>
        <do_if value="$firingcooldowntime?">
          <do_if value="player.age lt $firingcooldowntime">
            <debug_text text="'attack was interrupted during a cooldown. resume cooldown wait'" chance="$debugchance"/>
            <wait exact="$firingcooldowntime - player.age" sinceversion="21"/>
          </do_if>
          <remove_value name="$firingcooldowntime"/>
        </do_if>

        <shuffle_group group="$targets_defensibles" chance="30"/>
        <do_if value="not $targets_defensibles_list?">
          <set_value name="$targets_defensibles_list" exact="$targets_defensibles.list"/>
          <!--Move the primary target to the back of the list so it's likely to be attacked-->
          <do_if value="@$primarytarget and $targets_defensibles_list.indexof.{$primarytarget}" chance="80">
            <remove_from_list name="$targets_defensibles_list" exact="$primarytarget"/>
            <append_to_list name="$targets_defensibles_list" exact="$primarytarget"/>
          </do_if>
        </do_if>
        <set_value name="$combinedskill" exact="this.assignedcontrolled.combinedskill"/>

        <set_value name="$lastforwardweapontarget" exact="@$forwardweapontarget"/>
        <set_value name="$forwardweapontarget" exact="null"/>
        <set_value name="$forwardrange" exact="this.assignedcontrolled.maxcombatrange.lasers.all"/>
        <do_if value="$forwardrange and @$primarytarget and (not $lastforwardweapontarget or $lastforwardweapontarget == $primarytarget) and $targets_defensibles.indexof.{$primarytarget} and $primarytarget.canbeattacked and this.assignedcontrolled.bboxdistanceto.{$primarytarget} le $forwardrange">
          <set_value name="$forwardweapontarget" exact="$primarytarget"/>
          <do_if value="$forwardweapontarget == $lastforwardweapontarget and $forwardweapontime?">
            <debug_text text="'keeping ' + $forwardweapontarget + ' ' + $forwardweapontarget.knownname + ' as the primary target. ' + ($forwardweapontime - player.age) + ' seconds left for primary weapon fire'" chance="$debugchance"/>
          </do_if>
          <do_else>
            <set_value name="$targetspeed" exact="@$primarytarget.maxspeed"/>
            <do_if value="not $targetspeed or $targetspeed lt 5m">
              <!--Able to use forward weapons all the time for stationary targets-->
              <!--TODO @Owen @Nick better take the current movement order into account-->
              <set_value name="$forwardweapontime" exact="$attacktime"/>
            </do_if>
            <do_else>
              <!--The forwardweapontime is calculated here to give better control over the course of the battle, as opposed to trying to scale the damage down in the DPS calculations which has limited info to go on-->
              <set_value name="$attackduration" exact="$attacktime - player.age"/>
              <do_if value="$attackduration gt 0s">
                <!--Some random range for the speed as the target is unlikely to be flying perpendicular or even at full speed in all situations, but if it's being targeted by a main weapon it'll be trying-->
                <set_value name="$targetspeed" min="$targetspeed * 0.80" max="$targetspeed"/>
                <set_value name="$turnspeed" exact="[this.assignedcontrolled.maxyawspeed, this.assignedcontrolled.maxpitchspeed].max"/>
                <!--A bit of a derp factor as the ship is likely not turning at 100% effectivness-->
                <set_value name="$turnspeed" min="$turnspeed * 0.7" max="$turnspeed * 0.9"/>
                <!--Get the distance of the target, with a minimum amount based on the max range of fire-->
                <set_value name="$forwardtargetrange" exact="[this.assignedcontrolled.bboxdistanceto.{$primarytarget}, $forwardrange * 0.1m].max"/>
                <!--The length that this ship can turn at the target distance during the attack time-->
                <set_value name="$firearclength" exact="($turnspeed * ($forwardtargetrange)f / pi)m * ($attackduration)m"/>
                <!--The length that the target can traverse during the attack time, -->
                <set_value name="$targetarctraversal" exact="($targetspeed * ($attackduration)m) - ($primarytarget.size / 2)"/>
                <debug_text text="'Ship ' + this.assignedcontrolled.debugname + ' can turn ' + $firearclength + ' during attacktime of ' + $attackduration + 
                          ' and primary target ' + $primarytarget.debugname + ' can cover ' + $targetarctraversal + ' in that time'" chance="$debugchance"/>
                <do_if value="$targetarctraversal == 0 or $firearclength ge $targetarctraversal">
                  <debug_text text="'primary target will be in sight of the forward weapons for the whole attack duration'" chance="$debugchance"/>
                  <set_value name="$forwardweapontime" exact="$attacktime"/>
                </do_if>
                <do_else>
                  <do_if value="$attackduration gt 0s">
                    <set_value name="$forwardweapontime" exact="player.age + ($attackduration * ([0.10, ($firearclength)f / $targetarctraversal].max)s)"/>
                    <debug_text text="'primary target will be in sight of the forward weapons for ' + ($forwardweapontime - player.age) + ' of the attack time'" chance="$debugchance"/>
                  </do_if>
                </do_else>
              </do_if>
              <remove_value name="$attackduration"/>
            </do_else>
          </do_else>
        </do_if>
        <do_all exact="$targets_defensibles_list.count" reverse="true">

          <do_if value="not this.sector">
            <set_value name="$break"/>
            <break/>
          </do_if>

          <do_if value="not @$maxtargets">
            <!-- NB: $maxtargets limits the number of targets engaged in one frame. -->
            <!--The maximum amount of targets to be hit in this volley, limited by number of operational turrets/targets-->
            <set_value name="$maxtargets" exact="[this.ship.turrets.operational.count, $targets_defensibles_list.count, 5].min"/>
            <set_value name="$maxtargets" min="1" max="$maxtargets" profile="increasing"/>

            <!-- Search/Attacking waiting time -->
            <set_value name="$waittime" min="1s" max="4s" profile="increasing" />
            <set_value name="$topcommander" exact="this.assignedcontrolled.toplevelcommander"/>
            <set_value name="$obstructiondelay" exact="@$topcommander.defencenpc.$combat_obstructiondelay"/>
            <do_if value="not $obstructiondelay or not $topcommander or this.assignedcontrolled.distanceto.{$topcommander} gt 10km">
              <set_value name="$obstructiondelay" exact="0s"/>
              <find_gravidar_contact name="$largeobstructions" excluded="$targets_defensibles" object="this.assignedcontrolled" class="[class.ship_l, class.ship_xl, class.station]" checkoperational="false" multiple="true">
                <match_context macro="this.sector.macro"/>
                <match_distance object="this.assignedcontrolled" max="this.assignedcontrolled.maxcombatrange.all"/>
              </find_gravidar_contact>

              <!--Depending on the number of upcoming targets, estimate the time that a nearby obstacle will block line of sight. More targets means more chance of hitting something, so less obstruction time.-->
              <set_value name="$obstructioncount" exact="[$largeobstructions.count, 10].min - ($maxtargets / 2)"/>
              <do_if value="$obstructioncount gt 0">
                <set_value name="$obstructiondelay" min="0ms" max="1.5s * $obstructioncount"/>
                <debug_text text="'found %s large obstructions.'.[$largeobstructions.count]" chance="$debugchance"/>
              </do_if>
              <do_if value="this.assignedcontrolled.subordinates.count">
                <set_value name="this.$combat_obstructiondelay" exact="$obstructiondelay"/>
              </do_if>
              <remove_value name="$largeobstructions"/>
              <remove_value name="$obstructioncount"/>
            </do_if>
            <remove_value name="$topcommander"/>

            <set_value name="$firingcooldowntime" exact="player.age + $waittime + $obstructiondelay"/>
            <wait exact="$waittime + $obstructiondelay" chance="0"/>
            <do_if value="$targets_defensibles_list.count == 0">
              <!--Savegame support for when $targets_defensibles_list did not exist-->
              <continue/>
            </do_if>
          </do_if>

          <set_value name="$target" exact="$targets_defensibles_list.last"/>
          <remove_value name="$targets_defensibles_list.last"/>
          <!-- do not attack objects that are too far away, gravidar range can be substantially greater than firing range !! -->
          <do_if value="this.assignedcontrolled.pilot and @$target.canbeattacked and not @$target.dock and not $target.zone.isclass.highway and this.assignedcontrolled.mayattack.{$target} and (this.assignedcontrolled.bboxdistanceto.{$target} le $FiringRange)">

            <!-- Get and apply strengths-->
            <do_if value="true" chance="[$combinedskill, 90].max" comment="chance of success">
              <!-- Get the strength in 'result'-->
              <do_if value="$target == $forwardweapontarget and not this.assignedcontrolled.dock">
                <is_in_quadrant result="$useforwardweapons" object="this.assignedcontrolled" target="$forwardweapontarget" front="true"/>
              </do_if>
              <get_attackstrength object="this.assignedcontrolled" target="$target" allowanyturret="$target == @$primarytarget" usedrones="$target.isclass.[class.ship_xs, class.ship_s, class.ship_m]" useforwardweapons="@$useforwardweapons and (player.age lt @$forwardweapontime)">
                <result hullshield="$result_hullshield" hullonly="$result_hullonly" shieldonly="$result_shieldonly" hullnoshield="$result_hullnoshield"/>
                <missileresult ammo="$spentammotable" hullshield="$result_missilehullshield" hullonly="$result_missilehullonly" shieldonly="$result_missileshieldonly" hullnoshield="$result_missilehullnoshield"/>
              </get_attackstrength>
              <remove_value name="$useforwardweapons"/>
              <do_if value="$target == $forwardweapontarget" chance="$debugchance">
                <debug_text text="'Primary weapons against : ' + $target + ' ' + $target.knownname"/>
              </do_if>
              <debug_text text="'%s attacking %s. target hull: %s. attack strength:\nhullshield: %s\nhullonly: %s\nshieldonly: %s\nhullnoshield: %s\ndps all: %s\ndps main: %s\ndps turrets: %s'.[@this.assignedcontrolled.debugname, @$target.debugname, $target.hull, $result_hullshield, $result_hullonly, $result_shieldonly, $result_hullnoshield, this.assignedcontrolled.dps.all, (this.assignedcontrolled.dps.primary + this.assignedcontrolled.dps.secondary), this.assignedcontrolled.dps.turrets.all]" chance="0"/>

              <!--Check if a guided missile was fired. If so, attempt to launch a countermeasure from the target-->
              <set_value name="$guidedmissilelaunched" exact="false"/>
              <do_for_each name="$missilemacro" valuename="$missileamount" in="$spentammotable">
                <do_if value="not $guidedmissilelaunched and $missilemacro.isguided">
                  <set_value name="$guidedmissilelaunched" exact="true"/>
                </do_if>
                <remove_ammo object="this.assignedcontrolled" macro="$missilemacro" amount="$missileamount"/>
              </do_for_each>
              <do_if value="$guidedmissilelaunched and $target.isclass.defensible">
                <launch_countermeasures object="$target" virtual="true"/>
              </do_if>
              <remove_value name="$guidedmissilelaunched"/>
              <remove_value name="$spentammotable"/>

              <do_if value="not @$module.canbeattacked or not $targets_defensibles.indexof.{$module.defensible}">
                <set_value name="$module" exact="null"/>
                <do_if value="$target.modules.all.count" comment="checking .modules first is an optimisation">
                  <find_object_component name="$module" class="class.module" object="$target" checkoperational="false" sortbydistanceto="this.assignedcontrolled">
                    <match state="componentstate.wreck" negate="true"/>
                  </find_object_component>
                </do_if>
              </do_if>

              <debug_text text="'applying damage to %s %s of %s %s %s\nhullshield: %s\nhullonly: %s\nshieldonly: %s\nhullnoshield: %s'.[@$module.macro, @$module.knownname, @$target.idcode, @$target.knownname, $target, $result_hullshield, $result_hullonly, $result_shieldonly, $result_hullnoshield]" chance="$debugchance"/>
              <!-- Apply the regular dps attack strength, multiplied by time -->
              <set_value name="$result_hullshield" exact="$result_hullshield * ($waittime)f"/>
              <set_value name="$result_hullonly" exact="$result_hullonly * ($waittime)f"/>
              <set_value name="$result_shieldonly" exact="$result_shieldonly * ($waittime)f"/>
              <set_value name="$result_hullnoshield" exact="$result_hullnoshield * ($waittime)f"/>
              <apply_attackstrength object="$target" attacker="this.assignedcontrolled" hullshield="$result_hullshield" hullonly="$result_hullonly" shieldonly="$result_shieldonly" hullnoshield="$result_hullnoshield" module="if @$module.defensible == $target then $module else null">
                <result killed="$isdead" module="$module"/>
              </apply_attackstrength>
              <do_if value="$result_missilehullshield? and not $isdead">
                <!-- Apply the missile explosive damage, not multiplied by time -->
                <apply_attackstrength object="$target" attacker="this.assignedcontrolled" explosion="true" hullshield="$result_missilehullshield" hullonly="$result_missilehullonly" shieldonly="$result_missileshieldonly" hullnoshield="$result_missilehullnoshield" module="if @$module.defensible == $target then $module else null">
                  <result killed="$isdead" module="$module"/>
                </apply_attackstrength>
                <debug_text text="'%1 OOS. Apply explosive damage of %2 against %3 is: %4(%5|%6). Is killed: %7'.[player.age,this.ship.knownname,$target.knownname,$result_missilehullshield+$result_missilehullonly+$result_missileshieldonly+$result_missilehullnoshield,$target.hull,$target.shield,$isdead]" chance="$debugchance" />
              </do_if>
              <do_if value="false">
                <is_in_quadrant result="$q_front" object="this.assignedcontrolled" target="$target" front="true"/>
                <is_in_quadrant result="$q_right" object="this.assignedcontrolled" target="$target" right="true"/>
                <is_in_quadrant result="$q_left" object="this.assignedcontrolled" target="$target" left="true"/>
                <is_in_quadrant result="$q_back" object="this.assignedcontrolled" target="$target" back="true"/>
                <is_in_quadrant result="$q_up" object="this.assignedcontrolled" target="$target" up="true"/>
                <is_in_quadrant result="$q_down" object="this.assignedcontrolled" target="$target" down="true"/>
                <debug_text text="'%s attacking %s. target is destroyed: %s. applied attack strength:\nhullshield: %s\nhullonly: %s\nshieldonly: %s\nhullnoshield: %s\ntotal dps: %s, weapon dps: %s, turret dps: %s\nwaittime: %ss\nquadrant: front: %s, right: %s, left: %s, back: %s, up: %s, down: %s\nquadrant dps: front: %s, right: %s, left: %s, back: %s, up: %s, down: %s\ntarget hull: %s. module hull: %s'.[@this.assignedcontrolled.debugname, @$target.debugname, $isdead, $result_hullshield, $result_hullonly, $result_shieldonly, $result_hullnoshield, this.assignedcontrolled.dps.all, this.assignedcontrolled.dps.lasers.all, this.assignedcontrolled.dps.turrets.all, $waittime, $q_front, $q_right, $q_left, $q_back, $q_up, $q_down, this.assignedcontrolled.dps.lasers.all + this.assignedcontrolled.dps.missiles.all + this.assignedcontrolled.dps.turrets.{quadrant.front}, this.assignedcontrolled.dps.turrets.{quadrant.right}, this.assignedcontrolled.dps.turrets.{quadrant.left}, this.assignedcontrolled.dps.turrets.{quadrant.back}, this.assignedcontrolled.dps.turrets.{quadrant.up}, this.assignedcontrolled.dps.turrets.{quadrant.down}, $target.hull, @$module.hull]"/>
                <remove_value name="$q_down"/>
                <remove_value name="$q_up"/>
                <remove_value name="$q_back"/>
                <remove_value name="$q_left"/>
                <remove_value name="$q_right"/>
                <remove_value name="$q_front"/>
              </do_if>
              <debug_text text="'%s attacking %s. target is destroyed: %s applied attack strength:\nhullshield: %s\nhullonly: %s\nshieldonly: %s\nhullnoshield: %s\ntarget hull: %s. module hull: %s'.[@this.assignedcontrolled.debugname, @$target.debugname, $isdead, $result_hullshield, $result_hullonly, $result_shieldonly, $result_hullnoshield, $target.hull, @$module.hull]" chance="$debugchance"/>
              <debug_text text="'%1 OOS. Apply strength of %2 against %3 is: %4(%5|%6). Is killed: %7'.[player.age,this.ship.knownname,$target.knownname,$result_hullshield + $result_hullonly + $result_shieldonly + $result_hullnoshield,$target.hull,$target.shield,$isdead]" chance="0" />
              <!--Wait so that attack/killed events are processed-->
              <wait exact="1ms" />
            </do_if>
            <do_else>
              <debug_text text="'%1 OOS. Attack fail of %2 against %3'.[player.age,this.ship.knownname,$target.knownname]" chance="$debugchance" />
            </do_else>
          </do_if>

          <remove_value name="$target" />
          <do_if value="@$maxtargets gt 0">
            <set_value name="$maxtargets" operation="subtract"/>
            <do_if value="$maxtargets == 0">
              <break/>
            </do_if>
          </do_if>
        </do_all>
        <!-- important that this list is removed after this do_all to refresh the list. -->
        <remove_value name="$targets_defensibles_list"/>

        <do_if value="$break?">
          <remove_value name="$break"/>
          <break/>
        </do_if>

        <do_if value="$firingcooldowntime?">
          <do_if value="player.age lt $firingcooldowntime">
            <debug_text text="'total wait time: %ss, obstruction delay: %ss'.[$firingcooldowntime - player.age, $obstructiondelay]" chance="$debugchance"/>
            <wait exact="$firingcooldowntime - player.age" sinceversion="21"/>
          </do_if>
          <remove_value name="$firingcooldowntime"/>
        </do_if>

        <include_interrupt_actions ref="CapitalLaunchFighters"/>
      </do_while>
      <remove_value name="$combinedskill"/>
      <remove_value name="$forwardrange"/>
      <remove_value name="$forwardweapontarget"/>
      <remove_value name="$obstructiondelay"/>
      <remove_value name="$attacktime" />
      <remove_value name="$waittime" />
      <remove_value name="$maxtargets" />

      <!-- Scan time -->
      <set_value name="$BaseScanWaitTime" exact="[3s, [$targets_defensibles.count * 0.4s, 7s].min].max"/>
      <wait min="$BaseScanWaitTime" max="$BaseScanWaitTime * 1.5f" comment="To avoid performance problems" />
      <remove_value name="$BaseScanWaitTime"/>

      <resume label="Start" />

    </actions>
  </attention>
  <on_abort>
    <!-- Stop shooting targets if interrupted (change the npc)-->
    <cease_fire object="this.ship" />
  </on_abort>
</aiscript>
