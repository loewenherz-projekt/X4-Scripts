<?xml version="1.0" encoding="utf-8"?>
<mdscript name="GM_BringItems" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">
  <cues>

    <!--Base Mission information-->
    <!--
      Generic Mission name:    Bring Item
      Primary 'missiontype':   missiontype.deliver 
      Page: 30135 + pirate subscription (30207) and trade subscriptions (30204, 30205, 30208, ...)
      
      Notes:
      - This mission supports unlocking a shadyguy as a reward (actor passed in as $RewardObj, requires $RewardObj.isshadyguy=true)
    -->

    <!-- Variant Table -->
    <cue name="TextOffsets" namespace="this">
      <actions>
        <set_value name="$Cue" exact="md.GM_BringItems.GenerateGenericMission"/>
        <append_to_list name="md.GenericMissions.Manager.$StaticGMCues" exact="$Cue" create="true" unique="true"/>
        <set_value name="$Cue.$TextOffsets" exact="table[]" comment="$Cue.$TextOffsets.{$Page}.{$TextOffset}"/>
        <set_value name="$Cue.$TextOffsets.{30135}"
                   exact="table[ {1000} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {1100} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2000} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2100} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2200} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2300} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2400} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2500} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2600} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {3000} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {4000} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {4100} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {5000} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {5100} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {5200} = table[$lastoffertime = 0s, $offercounter = 0]]"/>
      </actions>
    </cue>

    <!--
      The Feedback Manager contains a table of feedback values related to this Generic Mission. 
		  This table is 'const' during the mission (the table itself doesn't change anymore after inialization)
	    There are several maintypes of feedback:
        event:    Something which happens during a mission but does not cause it to end e.g. the mission being accepted
        removed:  The mission offer was removed before acceptance
        success:  The mission was successfully completed by the player
        failure:  The player failed the mission
        error:    Something went wrong with the mission set-up or during the mission
    -->
    <cue name="FeedbackValueManager" namespace="this" version="5">
      <actions>
        <set_value name="$FeedbackValues" exact="table[
                   $MISSION_GENERATED             = table[$type = 'event',    $text = 'Mission variation generated successfully'],
                   $MISSION_ACCEPTED              = table[$type = 'event',    $text = 'Mission accepted'],
                   $MISSION_NO_VARIANT            = table[$type = 'event',    $text = 'No mission variant currently possible'],
                   
                   $OFFER_REMOVED                     = table[$type = 'removed',  $text = 'Offer removed'],
                   $DECLINED_OFFER                    = table[$type = 'removed',  $text = 'Player declined Event Offer'],
                   $EVENT_OFFER_TIMEOUT               = table[$type = 'removed',  $text = 'Event Offer timeout'],
                   $SIGNAL_LEAK_REMOVED               = table[$type = 'removed',  $text = 'Signal leak offer removed'],
                   $DELIVERYNPC_KILLED_EARLY          = table[$type = 'removed',  $text = 'Delivery NPC was killed early'],
                   $DELIVERY_STATION_DESTROYED_EARLY  = table[$type = 'removed',  $text = 'Deliver station destroyed early'],
                   
                   $MISSION_SUCCEEDED             = table[$type = 'success',  $text = 'Mission succeeded'],
                   
                   $MISSION_ABORTED               = table[$type = 'failure',  $text = 'Mission aborted by player'],
                   $FORCED_CLEANUP                = table[$type = 'failure',  $text = 'Forced to end from outside'],
                   $MISSION_TIMEOUT               = table[$type = 'failure',  $text = 'Mission timeout'],
                   $MISSION_FAILED                = table[$type = 'failure',  $text = 'Mission failure'],
                   $DELIVERYNPC_KILLED            = table[$type = 'failure',  $text = 'Delivery NPC was killed'],
                   $DELIVERY_STATION_DESTROYED    = table[$type = 'failure',  $text = 'Deliver station destroyed'],
                   
                   $NO_VALID_CLIENT_OWNER         = table[$type = 'error',    $text = 'No valid ClientOwner parameter provided'],
                   $INVALID_OFFER_TYPE            = table[$type = 'error',    $text = 'No offer parameters were valid'],
                   $NO_TEXT_OFFSET                = table[$type = 'error',    $text = 'No TextOffset set'],
                   $INVALID_DELIVERYNPC_PARAM     = table[$type = 'error',    $text = 'Invalid DeliveryNPC param'],
                   $INVALID_DELIVERYSTATION_PARAM = table[$type = 'error',    $text = 'Invalid DeliveryStation param'],
                   $INVALID_DELIVERYROOM_PARAMS   = table[$type = 'error',    $text = 'Invalid delivery room params. Either DeliveryRoomMacro, DeliveryCorridorMacro, DeliveryDoors or DeliveryInteriorName'],
                   $INVALID_DELIVERYITEM_PARAM    = table[$type = 'error',    $text = 'Invalid DeliveryItem param'],
                   $INVALID_ITEMOBJECT            = table[$type = 'error',    $text = 'Invalid ItemPlacementObject which is required to this mission variant'],
                   $INVALID_FORCE_CLEANUP         = table[$type = 'error',    $text = 'ForceCleanup cue invalid']
                   ]"/>
      </actions>
      <patch sinceversion="5">
        <!--To patch new feedback values, increment 'version' and 'sinceversion' number-->
        <force_cue cue="FeedbackValueManager"/>
      </patch>
    </cue>

    <!--Required variables: $Page & $TextOffset (and any below substitute_text values)
    If text is to be substituted for a new text variant, people should feel free to add the substitution below. Alternatively, pass in an overriding text in the $TextTable param-->
    <library name="GenerateTextTable">
      <actions>
        <!-- Register unknown TextOffsets to the TextOffsets table -->
        <run_actions ref="md.GenericMissions.RegisterMissionVariant">
          <param name="StaticGMCue" value="md.GM_BringItems.GenerateGenericMission"/>
          <param name="Page"        value="$Page"/>
          <param name="TextOffset"  value="$TextOffset"/>
        </run_actions>

        <!--Text page indexes $TextOffset + #
        1 = $TextTable.$missionname
        2 = $TextTable.$description
        3 = $TextTable.$objective
        4 = $TextTable.$conversationoption  Used to substitute current amount and warename. Table value only used for substitution. example: "Deliver: $AMOUNT$x $WARE$"
        5 = $TextTable.$tooltip             Conversation option tooltip if not selectable
        7 = $TextTable.$progress            Progress bar text, e.g. 'Delivered' -->

        <set_value name="$TextTable.$missionname" exact="readtext.{$Page}.{$TextOffset + 1}" chance="if $TextTable.$missionname? then 0 else 100" />
        <set_value name="$TextTable.$description" exact="readtext.{$Page}.{$TextOffset + 2}" chance="if $TextTable.$description? then 0 else 100" />

        <do_if value="$DeliveryNPC.exists or $DeliveryStation.exists">
          <run_actions ref="md.LIB_Generic.GenerateTextTable_BriefingWarning_Call" result="$TextTable.$description">
            <param name="BriefingText" value="$TextTable.$description"/>
            <param name="TargetSpace" value="if $DeliveryNPC.exists then $DeliveryNPC.sector else $DeliveryStation.sector"/>
          </run_actions>
        </do_if>

        <do_if value="$TimeBonusCr_Max? and not $TextTable.$timebonus?">
          <do_if value="$DurationUntilBonusDecay? and ($DurationUntilBonusDecay le $MissionDuration)">
            <substitute_text text="$TextTable.$timebonus" source="readtext.{30135}.{108}">
              <replace string="'$TIME$'" with="($MissionDuration - $DurationUntilBonusDecay).formatted.{if ($MissionDuration - $DurationUntilBonusDecay) >= 3600 then '%h:%M:%S' else '%M:%S'}"/>
              <replace string="'$REWARD$'" with="(($TimeBonusCr_Max)ct).formatted.default + ' ' + readtext.{1001}.{101}" comment="Cr"/>
            </substitute_text>
          </do_if>
          <do_elseif value="$DurationUntilBonusExpiry? and ($DurationUntilBonusExpiry le $MissionDuration)">
            <substitute_text text="$TextTable.$timebonus" source="readtext.{30135}.{109}">
              <replace string="'$TIME$'" with="($MissionDuration - $DurationUntilBonusExpiry).formatted.{if ($MissionDuration - $DurationUntilBonusExpiry) >= 3600 then '%h:%M:%S' else '%M:%S'}"/>
              <replace string="'$REWARD$'" with="(($TimeBonusCr_Max)ct).formatted.default + ' ' + readtext.{1001}.{101}" comment="Cr"/>
            </substitute_text>
          </do_elseif>
        </do_if>

        <do_if value="$TextTable.$timebonus?">
          <set_value name="$TextTable.$description" exact="$TextTable.$description + '\n\n' + $TextTable.$timebonus"/>
        </do_if>

        <substitute_text text="$TextTable.$objective" source="readtext.{$Page}.{$TextOffset + 3}" chance="if $TextTable.$objective? then 0 else 100">
          <replace string="'$AMOUNT$'" with="$DeliveryAmount" />
          <replace string="'$WARE$'" with="$DeliveryItem.name" />
        </substitute_text>

        <set_value name="$TextTable.$conversationoption" exact="readtext.{$Page}.{$TextOffset + 4}" chance="if $TextTable.$conversationoption? then 0 else 100"/>

        <set_value name="$TextTable.$tooltip" exact="readtext.{$Page}.{$TextOffset + 5}" chance="if $TextTable.$tooltip? then 0 else 100" />
        <set_value name="$TextTable.$progress" exact="readtext.{$Page}.{$TextOffset + 7}" chance="if $TextTable.$progress? then 0 else 100" />
      </actions>
    </library>

    <library name="GenerateVoiceTable">
      <actions>
        <run_actions ref="md.LIB_Generic.GenerateGenericVoiceTable" result="$VoiceTable">
          <param name="VoiceTable" value="$VoiceTable"/>
        </run_actions>
      </actions>
    </library>

    <library name="Start" version="13">
      <params>
        <!-- Generic Parameters -->
        <param name="OfferObject" default="null" comment="The object on which this mission is based e.g. A Ship / Station / Signal Leak. Only needed for missions with a physical location."/>
        <param name="Client" default="null" comment="Pre-existing client"/>
        <param name="ClientOwner" default="null" comment="Overriding owner for reward calculation or creation of $Client if not provided. Defaults to $OfferObject owner if able"/>
        <param name="MissionCue" default="null" comment="Cue the mission is attached to. Defaults to Start (this)."/>
        <param name="MissionThread" default="null" comment="Mission thread for the offer and mission"/>

        <param name="GenerateReward" default="true" comment="If RewardCr or RewardNotoriety are invalid, generate them?"/>
        <param name="RewardCr" default="null" comment="If the reward for this mission is credits, the number of credits should be set to this variable." />
        <param name="RewardObj" default="null" comment="If the reward for this mission is not credits, and is an object, it should be set to this variable." />
        <param name="RewardNotoriety" default="null"/>
        <param name="RewardText" default="null"  comment="Any text needed to define the reward for this mission - may be used in conjunction with $RewardCr and $RewardObj." />
        <param name="MissionDuration" default="null"/>
        <param name="MissionAbortable" default="true"/>
        <param name="DurationUntilBonusDecay" default="null" comment="Mission duration until the bonus reward credits start to decay"/>
        <param name="DurationUntilBonusExpiry" default="null" comment="Mission duration until the bonus reward credits expire completely"/>
        <param name="MissionType" default="missiontype.deliver" comment="Variations can override mission type if required"/>
        <param name="MissionLevel"/>
        <param name="Difficulty"/>

        <!--Offer location and conversation-->
        <param name="WithoutOffer" default="false" comment="Do not create a mission offer. Either run immediatly or wait for WithoutOfferWaitCue"/>
        <param name="WithoutOfferWaitCue" default="null" comment="Do not create a mission offer but wait for this cue to be completed before running the mission"/>
        <param name="AcceptOnItemObjectCollection" default="true" comment="Accept the mission if the resulting object of $ItemPlacementParam is collected by the player"/>
        <param name="DeclineButton" default="true" comment="Have a decline button instead of a back button in the offer conversation"/>
        <param name="EventOffer" default="false" comment="Is the mission offered directly to the player with an interactive event"/>
        <param name="ConversationOffer" default="false" comment="When $EventOffer is false, should this offer be through a conversation with the $Client. Otherwise, offer at mission location"/>
        <param name="ConversationTriggerCue" default="null" comment="If provided, when this cue is signalled, start the mission offer conversation."/>
        <param name="OfferMaxDistance" default="null"/>
        <param name="HideFromBBS" default="false" comment="Hide this offer from the BBS? Show only through locations or special conversation handling."/>
        <param name="RemoveOnSectorChange" default="true"/>
        <param name="OfferDistance" default="50km" comment="Distance to the offer location before it becomes visible on the map or BBS (unless otherwise hidden)"/>

        <!--BBS only params-->
        <param name="BBSObject" default="null"/>
        <param name="BBSDistance" default="null"/>
        <param name="BBSTimeoutMin" default="null"/>
        <param name="BBSTimeoutMax" default="null"/>
        <param name="BBSSpace" default="null"/>

        <!--Mission text-->
        <param name="Page"        comment="Allows a different text page to be used instead of the generic one. Text IDs must be mapped similarly."/>
        <param name="TextOffset"  comment="The text offset for this variant's text on the page."/>
        <param name="TextTable" default="table[]" comment="Table, usually populated by the mission, to store the texts by an identifier key e.g. $missionname = 'Kill Bala Gi'
               Check library 'GenerateTextTable' for identifier keys. Pass in a table with such an entry to override the text usually generated from the $Page and $TextOffset"/>
        <param name="VoiceTable" default="table[]" comment="Table, usually populated by the mission, keys can have a value of 0 (=stay silent)
               .$SignalLeakVoiceLine = The line that should be used for signal leak introductions to this mission"/>

        <!--Mission specific params-->
        <param name="BriefingIcon"        default="''"/>
        <param name="DeliveryNPC"                                       comment="The NPC to which the items should be delivered" />
        <param name="DeliveryStation"                                   comment="The station in which to place the NPC or to place the dynamic interior" />
        <param name="DeliveryItem"                                      comment="The item to be delivered" />
        <param name="DeliveryAmount"      default="1"                   comment="The number of DeliveryItem to be delivered" />
        <param name="OwnedAmount"         default="null"                comment="The number of DeliveryItem to be delivered" />
        <param name="ItemHolder"          default="null"                comment="Container holding the ware. Can be existing collectableware/lockbox/room crate or the macro of one for creation."/>
        <param name="HolderPlacementDef"  default="null"                comment="
                                   Lockbox/Collectablewares case:       Space position list: [$component, $offset(defaults to 0,0,0)]
                                   ---------
                                   Room crate case:                     Room crate slot OR,
                                                                        room/walkablemodule/defensible/dynamicinterior component in which to find a crate slot OR,
                                                                        list [room/walkablemodule/defensible/dynamicinterior component, roomtag] in which to find a crate slot."/>
        <param name="DeliveryRoomTags"    default="[]"                  comment="List of tags used to generate the room."/>
        <!-- ************************************************************************************************************************************************************************ -->
        <!-- If the mission is to manage placing the delivery NPC, $StartObject must be set.
        Interior parameters are optional but if one is set, they must be passed in together -->
        <param name="PlaceNPC"            default="false"               comment="Does the mission handle the placement and removal of the delivery NPC? If false, some other system must be in charge of doing so." />
        <param name="PlacementTable"      default="table[$cue = namespace, $priority = 50]"  comment="Table containing the owning cue and priority of placing the NPC vs other missions"/>
        <param name="DeliveryNPCSlotTags" default="[tag.npc_generic]"   comment="NPC slot tags to help position the DeliveryNPC" />
        <!-- Interior parameters: Room, corridor and door definitions could be provided by the caller through get_room_definition -->
        <param name="DeliveryRoomMacro" default="null" comment="The dynamic interior room the DeliveryNPC should be placed in, if not placed already" />
        <param name="DeliveryCorridorMacro" default="null" comment="The dynamic interior corridor leading to DeliveryRoomMacro" />
        <param name="DeliveryDoors" default="null" comment="The possible dynamic interior doors used to connect the room and corridor. When defining a room or corridor macro, this is is the variable saved in the doors parameter" />
        <param name="DeliveryInteriorName" default="null" comment="The name of the dynamic interior the DeliveryNPC should used, if not placed already" />
        <!-- ************************************************************************************************************************************************************************ -->

        <param name="ReportSignalCue" default="null" comment="Cue to be signalled when something happens which could be of interest to the calling cue. Saves values to ReportSignalCue.$FeedbackValue and ReportSignalCue.$EndFeedbackValue"/>
        <param name="CancelOfferCue" default="null" comment="Cue which when completed will force this missions offer to be removed and cleaned up. No effect if mission has been accepted."/>
        <param name="ForceCleanup" default="null" comment="Cue to force a cleanup from outside when completed"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <!--Feedback value setup-->
        <set_value name="$Feedback" exact="null"/>
        <set_value name="$FeedbackManager" exact="md.GM_BringItems.FeedbackValueManager"/>

        <assert value="$WithoutOffer or not $MissionCue or (not $MissionCue.hasmission and not $MissionCue.hasmissionoffer)"
                text="'Mission is set to create an offer but provided MissionCue: ' + $MissionCue + ' already has an offer or is a running mission [Owen]'"/>

        <!--Param validation-->
        <do_if value="not $WithoutOffer">
          <!--Optional variables (at least one should exist): $OfferObject, (bool)$HideFromBBS, (bool)$ConversationOffer, (bool)$EventOffer
          Result variables:
          $OfferType = 'signalleak' OR 'objectbased' OR 'eventoffer' OR 'conversationoffer'
          $AllowOfferEvent = Will an event offering this event be also fired immediatly?-->
          <include_actions ref="md.GenericMissions.GetOfferType"/>
          <do_if value="not $OfferType">
            <set_value name="$Feedback" exact="'$INVALID_OFFER_TYPE'"/>
          </do_if>
        </do_if>

        <do_if value="not $Feedback">
          <do_if value="not $TextOffset">
            <set_value name="$Feedback" exact="'$NO_TEXT_OFFSET'"/>
          </do_if>
          <do_else>
            <do_if value="$Client">
              <set_value name="$PreexistingClient"/>
            </do_if>
            <do_if value="not $ClientOwner">
              <set_value name="$ClientOwner" exact="if $Client then $Client.owner else @$OfferObject.owner"/>
              <assert value="$ClientOwner" text="'No valid $ClientOwner [Owen]'"/>
            </do_if>

            <do_if value="not $ClientOwner">
              <set_value name="$Feedback" exact="'$NO_VALID_CLIENT_OWNER'"/>
            </do_if>
            <do_else>
              <!--Mission specific param checks-->
              <do_if value="not $DeliveryNPC.isclass.npc">
                <set_value name="$Feedback" exact="'$INVALID_DELIVERYNPC_PARAM'"/>
              </do_if>
              <do_elseif value="not ($DeliveryStation.isclass.station and $DeliveryStation.isoperational)">
                <set_value name="$Feedback" exact="'$INVALID_DELIVERYSTATION_PARAM'" />
              </do_elseif>
              <do_elseif value="typeof $DeliveryItem != datatype.ware">
                <set_value name="$Feedback" exact="'$INVALID_DELIVERYITEM_PARAM'"/>
              </do_elseif>
              <do_elseif value="typeof $DeliveryAmount != datatype.integer or $DeliveryAmount le 0">
                <set_value name="$Feedback" exact="'$INVALID_ENEMY_SPAWNZONE_PARAM'"/>
              </do_elseif>
              <do_elseif value="not ($DeliveryRoomMacro and $DeliveryCorridorMacro and $DeliveryDoors and $DeliveryInteriorName) and 
                       not (not $DeliveryRoomMacro and not $DeliveryCorridorMacro and not $DeliveryDoors and not $DeliveryInteriorName)">
                <!--Interior parameters were incomplete-->
                <set_value name="$Feedback" exact="'$INVALID_DELIVERYROOM_PARAMS'"/>
              </do_elseif>
            </do_else>
          </do_else>
        </do_if>
      </actions>
      <patch sinceversion="3">
        <!--all variants of of this mission in this version should have these flags set-->
        <!--<set_value name="$AllowInteriorFallback" exact="true" comment="unused as of 2.0 B1"/>-->
        <set_entity_traits entity="$DeliveryNPC" missionactor="true" customhandler="true"/>
      </patch>
      <patch sinceversion="4" state="complete">
        <do_if value="not $DeliveryNPC.isclass.npc">
          <set_value name="$DebugChance" exact="100"/>
          <set_value name="$Feedback" exact="'$DELIVERYNPC_KILLED_EARLY'"/>
          <signal_cue cue="CleanUp"/>
        </do_if>
        <do_elseif value="not $DeliveryStation.isoperational">
          <set_value name="$DebugChance" exact="100"/>
          <set_value name="$Feedback" exact="'$DELIVERY_STATION_DESTROYED_EARLY'"/>
          <signal_cue cue="CleanUp"/>
        </do_elseif>
      </patch>
      <patch sinceversion="5" state="complete">
        <set_value name="$PlaceNPC" exact="false"/>
        <do_if value="$DeliveryNPC.isclass.npc and $DeliveryStation.isoperational">
          <!--The shady guy has its own handler for being placed-->
          <do_if value="$DeliveryNPC.controlpost != controlpost.shadyguy">
            <debug_text text="'Setting bring item mission to handle the placement of delivery NPC ' + $DeliveryNPC + ' ' + $DeliveryNPC.knownname + ' on ' + $DeliveryStation + ' ' + $DeliveryStation.knownname" filter="savegame"/>
            <set_value name="$PlaceNPC" exact="true"/>
          </do_if>
        </do_if>
        <remove_value name="$AllowInteriorFallback"/>
        <remove_value name="$PreexistingDeliveryNPC"/>
      </patch>
      <patch sinceversion="6" state="complete">
        <set_value name="$DeliveryNPCSlot" exact="null"/>
        <do_if value="$PlaceNPC">
          <get_room_definition macro="$DeliveryCorridorMacro" doors="$DeliveryDoors" race="$DeliveryStation.owner.primaryrace" tags="tag.corridor" />
          <get_room_definition macro="$DeliveryRoomMacro" tags="tag.bar" />
          <set_value name="$DeliveryInteriorName" exact="readtext.{20007}.{1031}" />
        </do_if>
      </patch>
      <patch sinceversion="7" state="complete">
        <set_value name="$PlacementTable" exact="table[$cue = namespace, $priority = 50]"/>
        <set_value name="$DeliveryNPCSlotTags" exact="[tag.npc_generic]"/>
        <remove_value name="$DeliveryNPCSlot"/>
      </patch>
      <patch sinceversion="9">
        <set_value name="$VoiceTable" exact="table[]"/>
      </patch>
      <patch sinceversion="10">
        <set_value name="$MissionAbortable" exact="true"/>
      </patch>
      <patch sinceversion="11">
        <set_value name="$BriefingIcon" exact="''"/>
      </patch>
      <patch sinceversion="12">
        <run_actions ref="md.LIB_Generic.GenerateGenericVoiceTable" result="$VoiceTable">
          <param name="VoiceTable" value="$VoiceTable"/>
        </run_actions>
      </patch>
      <patch sinceversion="13">
        <set_value name="$AcceptOnItemObjectCollection" exact="true"/>
        <set_value name="$ItemHolder" exact="null"/>
        <set_value name="$HolderPlacementDef" exact="null"/>
      </patch>
      <cues>
        <cue name="Do_Not_Start_Mission" onfail="cancel">
          <conditions>
            <check_value value="$Feedback"/>
          </conditions>
          <actions>
            <signal_cue cue="CleanUp"/>
          </actions>
        </cue>

        <cue name="Do_Start_Mission" onfail="cancel" version="2">
          <conditions>
            <check_value value="not $Feedback"/>
          </conditions>
          <actions>
            <do_if value="not $MissionCue">
              <set_value name="$MissionCue" exact="Start"/>
            </do_if>

            <do_if value="not $PreexistingClient?">
              <!-- No pre-existing client, create a temporary client for this mission -->
              <create_cue_actor cue="Start" name="$Client">
                <select faction="$ClientOwner" tags="tag.crew"/>
                <owner exact="$ClientOwner"/>
              </create_cue_actor>
            </do_if>

            <do_if value="$ItemHolder">
              <set_value name="$ItemHolderObject" exact="null"/>
              <do_if value="typeof $ItemHolder == datatype.component">
                <do_if value="$ItemHolder.isclass.[class.lockbox, class.collectablewares, class.crate]">
                  <set_value name="$ItemHolderObject" exact="$ItemHolder"/>
                </do_if>
                <do_else>
                  <debug_text text="'Unsupported item holder class. ' + $ItemHolderObject + ' ' + $ItemHolderObject.knownname + ' class: ' + $ItemHolderObject.class" filter="error"/>
                </do_else>
              </do_if>
              <do_elseif value="typeof $ItemHolder == datatype.macro">
                <do_if value="$ItemHolder.isclass.crate">
                  <do_if value="typeof $HolderPlacementDef == datatype.componentslot">
                    <create_crate name="$ItemHolderObject" slot="$HolderPlacementDef" macro="$ItemHolder"/>
                  </do_if>
                  <do_else>
                    <set_value name="$CrateObject" exact="null"/>
                    <do_if value="typeof $HolderPlacementDef == datatype.component">
                      <set_value name="$CrateObject" exact="$HolderPlacementDef"/>
                      <set_value name="$CrateSlotTags" exact="[]"/>
                    </do_if>
                    <do_elseif value="typeof $HolderPlacementDef == datatype.list">
                      <set_value name="$CrateObject" exact="$HolderPlacementDef.{1}"/>
                      <set_value name="$CrateSlotTags" exact="$HolderPlacementDef.{2}"/>
                    </do_elseif>
                    <do_if value="$CrateObject">
                      <set_value name="$PlacementModuleOrRoom" exact="null"/>
                      <do_if value="$CrateObject.isclass.[class.walkablemodule, class.room]">
                        <find_crate_slot name="$CrateSlot" object="$CrateObject" tags="$CrateSlotTags"/>
                        <do_if value="$CrateSlot">
                          <create_crate name="$ItemHolderObject" slot="$CrateSlot" macro="$ItemHolder"/>
                        </do_if>
                      </do_if>
                      <do_elseif value="$CrateObject.isclass.defensible">
                        <find_object_component name="$PotentialModules" class="class.walkablemodule" walkable="true" object="$CrateObject" multiple="true"/>
                        <shuffle_list list="$PotentialModules"/>
                        <do_for_each name="$PotentialModule" in="$PotentialModules">
                          <!--TODO @Owen support find_crate_slot for more classes-->
                          <find_crate_slot name="$CrateSlot" object="$PotentialModule" tags="$CrateSlotTags"/>
                          <do_if value="$CrateSlot">
                            <create_crate name="$ItemHolderObject" slot="$CrateSlot" macro="$ItemHolder"/>
                            <break/>
                          </do_if>
                        </do_for_each>
                      </do_elseif>
                      <do_elseif value="$CrateObject.isclass.navcontext">
                        <set_value name="$InteriorRooms" exact="$CrateObject.rooms"/>
                        <shuffle_list list="$InteriorRooms"/>
                        <do_for_each name="$InteriorRoom" in="$InteriorRooms">
                          <find_crate_slot name="$CrateSlot" object="$InteriorRoom" tags="$CrateSlotTags"/>
                          <do_if value="$CrateSlot">
                            <create_crate name="$ItemHolderObject" slot="$CrateSlot" macro="$ItemHolder"/>
                            <break/>
                          </do_if>
                        </do_for_each>
                      </do_elseif>
                    </do_if>
                    <do_else>
                      <debug_text text="'Invalid $HolderPlacementDef case for creation of a crate: ' + $HolderPlacementDef" filter="error"/>
                    </do_else>
                  </do_else>
                </do_if>
                <do_elseif value="$ItemHolder.isclass.[class.lockbox, class.collectablewares]">
                  <!--TODO @Owen move some of this validation to the Start cue-->
                  <do_if value="typeof $HolderPlacementDef == datatype.list and typeof $HolderPlacementDef.{1} == datatype.component and $HolderPlacementDef.{1} == datatype.position">
                    <set_value name="this.$PlacementSector" exact="if $ItemPlacementOffset.{1}.isclass.sector then $ItemPlacementOffset.{1} else $ItemPlacementOffset.{1}.sector"/>
                    <do_if value="$ItemHolder.isclass.lockbox">
                      <create_lockbox name="$ItemHolderObject" macro="$ItemHolder" sector="this.$PlacementSector">
                        <safepos object="$ItemPlacementOffset.{1}" value="$ItemPlacementOffset.{2}"/>
                        <rotation value="if @$ItemPlacementOffset.{3} then $ItemPlacementOffset.{3} else null"/>
                      </create_lockbox>
                    </do_if>
                    <do_else>
                      <create_object name="$ItemHolderObject" macro="$ItemHolder" sector="this.$PlacementSector">
                        <safepos object="$ItemPlacementOffset.{1}" value="$ItemPlacementOffset.{2}"/>
                        <rotation value="if @$ItemPlacementOffset.{3} then $ItemPlacementOffset.{3} else null"/>
                      </create_object>
                    </do_else>
                  </do_if>
                  <do_else>
                    <debug_text text="'Invalid $ItemPlacementOffset for creation of a lockbox. Must be a list of [space, position]. $ItemPlacementOffset: ' + @$ItemPlacementOffset" filter="error"/>
                  </do_else>
                </do_elseif>
                <do_else>
                  <debug_text text="'Unsupported item holder class. ' + $ItemHolderObject + ' class: ' + $ItemHolderObject.class" filter="error"/>
                </do_else>
              </do_elseif>

              <do_if value="$ItemHolderObject">
                <add_cargo object="$ItemHolderObject" ware="$DeliveryItem" exact="$DeliveryAmount"/>
              </do_if>
              <do_else>
                <set_value name="$Feedback" exact="'$INVALID_ITEMOBJECT'"/>
                <signal_cue cue="CleanUp"/>
              </do_else>
            </do_if>

            <do_if value="not $Feedback">
              <!-- Determine the reward (credits/object/notoriety) -->
              <do_if value="$GenerateReward">
                <include_actions ref="md.LIB_Reward_Balancing.Allocate_RewardWeight" comment="input: $Difficulty, $ClientOwner; output: $RewardCreditsWeight, $RewardModWeight, $RewardSeminarWeight"/>

                <signal_cue_instantly cue="md.LIB_Reward_Balancing.Reward_Money" param="[Start, $Difficulty, $MissionLevel, $ClientOwner]" comment="basic reward credits"/>
                <include_actions ref="md.LIB_Reward_Balancing.TimeBonusCr_Max" comment="Input: $Reward_Money__Result; Output: $TimeBonusCr_Max"/>


                <do_if value="not $RewardCr" weight="$RewardCreditsWeight">
                  <include_actions ref="md.LIB_Reward_Balancing.Apply_RewardMultiplier" comment="signal leak and mission thread bonus"/>
                  <run_actions ref="CalculateResourceCost" result="$ResourceCost__Result">
                    <param name="DeliveryItem" value="$DeliveryItem"/>
                    <param name="DeliveryAmount" value="$DeliveryAmount"/>
                  </run_actions>
                  <set_value name="$RewardCr" exact="$Reward_Money__Result_Multiplied + $ResourceCost__Result"/>
                  <debug_text text="'Item: ' + $DeliveryAmount + 'x ' + $DeliveryItem.name  + ' - Total money: ' + ($RewardCr).formatted.{'%.s %Cr'} + ' ResourceCost: ' + ($DeliveryItem.maxprice * $DeliveryAmount).formatted.{'%.s %Cr'} + ' Profits: ' + ($RewardCr-($DeliveryItem.maxprice * $DeliveryAmount)).formatted.{'%.s %Cr'} + ' Ratio: ' + ($RewardCr / ($DeliveryItem.maxprice * $DeliveryAmount))" chance="$DebugChance"/>
                </do_if>

                <do_if value="not $RewardObj">
                  <run_actions ref="md.LIB_Reward_Balancing.DetermineAdditionalReward" result="$AdditionalReward">
                    <param name="RewardModWeight" value="$RewardModWeight"/>
                    <param name="RewardSeminarWeight" value="$RewardSeminarWeight"/>
                  </run_actions>
                  <do_if value="$AdditionalReward != null">
                    <set_value name="$RewardObj" exact="$AdditionalReward"/>
                    <set_value name="$RewardText" exact="$RewardObj.name"/>
                  </do_if>
                </do_if>

                <do_if value="not $RewardNotoriety">
                  <signal_cue_instantly cue="md.LIB_Reward_Balancing.Reward_Notoriety" param="[Start, $Difficulty, $MissionLevel, $ClientOwner]"/>
                  <set_value name="$RewardNotoriety" exact="$Reward_Notoriety__Result"/>
                </do_if>
              </do_if>

              <include_actions ref="GenerateTextTable"/>
              <include_actions ref="GenerateVoiceTable"/>

              <do_if value="$ReportSignalCue">
                <!--Signal the $ReportSignalCue that the mission has been successfully generated-->
                <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_GENERATED.clone"/>
                <set_value name="$FeedbackData.$ID" exact="'$MISSION_GENERATED'"/>
                <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="Mission variation generated successfully"/>
                <signal_cue_instantly cue="$ReportSignalCue" param="table[$Name = $TextTable.$missionname, $Cue = $MissionCue, $Reward = $RewardCr, $RewardText = $RewardText]"/>
              </do_if>
            </do_if>
          </actions>
          <patch sinceversion="2">
            <set_value name="$TextTable.$progress" exact="readtext.{$Page}.{$TextOffset + 7}" chance="if $TextTable.$progress? then 0 else 100" />
          </patch>
          <cues>

            <!--***MISSION OFFER***-->
            <cue name="With_Offer" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer" exact="false"/>
              </conditions>
              <cues>
                <!--Cue which creates the offer, when signalled. To be signalled from the GenericMissions.OfferMission library, referenced below-->
                <cue name="CreateOffer" instantiate="true" comment="instanced to prevent cleanup">
                  <conditions>
                    <event_cue_signalled/>
                    <check_value value="not @$OfferCreated"/>
                  </conditions>
                  <actions>
                    <do_if value="not @$OfferCreated">
                      <!-- Briefing details -->
                      <create_offer cue="$MissionCue" location="$OfferObject" distance="$OfferDistance" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" actor="$Client"
                                  faction="$ClientOwner" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText" duration="$MissionDuration" hidden="$HideFromBBS" space="$BBSSpace" icon="$BriefingIcon">
                        <briefing>
                          <objective step="1" action="objective.deliver" text="$TextTable.$objective" encyclopedia="$DeliveryItem" comment="Deliver: $AMOUNT$x $WARE$"/>
                        </briefing>
                      </create_offer>
                      <!-- Offers might be outside the $OfferDistance (default 50km) and not seen by players but still count up -->
                      <run_actions ref="md.GenericMissions.UpdateTextOffsetsTable">
                        <param name="StaticGMCue" value="md.GM_BringItems.GenerateGenericMission"/>
                        <param name="Page"        value="$Page"/>
                        <param name="TextOffset"  value="$TextOffset"/>
                      </run_actions>
                    </do_if>
                    <set_value name="$OfferCreated" exact="true"/>

                    <do_if value="$OfferObject.isclass.signalleak">
                      <do_if value="readtext.{$Client.page}.{$VoiceTable.$SignalLeakVoiceLine}?">
                        <update_signal_leak_voice object="$OfferObject" page="$Client.page" lines="$VoiceTable.$SignalLeakVoiceLine" />
                      </do_if>
                      <do_else>
                        <set_value name="$Feedback" exact="'$INVALID_SIGNALLEAKVOICELINE_PARAM'" />
                        <signal_cue cue="CleanUp" />
                      </do_else>
                    </do_if>
                  </actions>
                </cue>

                <!--The majority of the offer logic is within this library. The parameters we pass down below, specify in which way this mission is going to be offered to the player (i.e. BBS, Signal-Leak, ...)
                Some of the mission specific handling is still contained in this file but triggered via the library via a signal e.g. setting up the briefing details via the 'CreateOffer' cue above.-->
                <cue name="Offer_Management" ref="md.GenericMissions.OfferMission">
                  <param name="OfferType"     value="$OfferType"/>
                  <param name="OfferCue"      value="$MissionCue"/>
                  <param name="CleanupCue"    value="Offer_End"/>
                  <param name="BriefingSetupCue" value="CreateOffer"/>
                  <param name="MissionName"   value="$TextTable.$missionname"/>
                  <param name="CancelOfferCue" value="$CancelOfferCue"/>

                  <!--Object based params (offered by Station/Ship/Signal-leak)-->
                  <param name="TimeoutMin"  value="8min" comment="Minimum time the offer remains valid"/>
                  <param name="TimeoutMax"  value="12min"/>
                  <param name="MaxDistance" value="$OfferMaxDistance"/>
                  <param name="RemoveOnSectorChange" value="$RemoveOnSectorChange"/>

                  <!--Object and Signal Leak based params-->
                  <param name="OfferObject" value="$OfferObject"/>

                  <!--BBS based offers-->
                  <param name="BBSObject"     value="@$BBSObject"/>
                  <param name="BBSDistance"   value="@$BBSDistance"/>
                  <param name="BBSTimeoutMin" value="@$BBSTimeoutMin"/>
                  <param name="BBSTimeoutMax" value="@$BBSTimeoutMax"/>

                  <!--Conversation event offers-->
                  <param name="AllowOfferEvent" value="$AllowOfferEvent"/>
                  <param name="ConversationTriggerCue" value="$ConversationTriggerCue"/>

                  <!--Client-->
                  <param name="Client"                 value="$Client"/>
                  <param name="VoiceTable"             value="$VoiceTable"/>

                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <!--Cue signalled when the offer library is finished-->
                <cue name="Offer_End">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <do_if value="this.$Feedback.$ID == '$accepted_offer'">
                      <signal_cue cue="MissionAccepted"/>
                    </do_if>
                    <do_elseif value="this.$Feedback.$ID == '$DECLINED_OFFER'">
                      <set_value name="$Feedback" exact="'$DECLINED_OFFER'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$OFFER_REMOVED'">
                      <set_value name="$Feedback" exact="'$OFFER_REMOVED'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$SIGNAL_LEAK_REMOVED'">
                      <set_value name="$Feedback" exact="'$SIGNAL_LEAK_REMOVED'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$EVENT_OFFER_TIMEOUT'">
                      <set_value name="$Feedback" exact="'$EVENT_OFFER_TIMEOUT'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                  </actions>
                </cue>
              </cues>
            </cue>

            <!--These cues handle the cases where a mission is automatically accepted on creation-->
            <cue name="Without_Offer" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer"/>
                <check_value value="not $WithoutOfferWaitCue"/>
                <check_value value="not $AcceptOnItemObjectCollection"/>
              </conditions>
              <actions>
                <signal_cue cue="MissionAccepted" />
              </actions>
            </cue>

            <cue name="Without_Offer_Wait_Cue" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer"/>
                <check_value value="$WithoutOfferWaitCue"/>
              </conditions>
              <cues>
                <cue name="Without_Offer_Wait_Cue_Completed">
                  <conditions>
                    <check_any>
                      <event_cue_completed cue="$WithoutOfferWaitCue"/>
                      <check_all>
                        <event_cue_signalled cue="$WithoutOfferWaitCue"/>
                        <check_value value="event.param == $MissionCue"/>
                      </check_all>
                    </check_any>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="MissionAccepted" />
                    <cancel_cue cue="Without_Offer_Accept_On_Collection"/>
                    <cancel_cue cue="Without_Offer_Wait_Cue"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="Without_Offer_Accept_On_Collection" onfail="cancel">
              <conditions>
                <check_value value="$AcceptOnItemObjectCollection and $ItemHolderObject?"/>
              </conditions>
              <actions>
                <debug_text text="'Awaiting collection of ' + $ItemHolderObject + ' ' + $ItemHolderObject.knownname"/>
                <do_if value="$ItemHolderObject.exists">
                  <add_to_group groupname="$CollectionGroup" object="$ItemHolderObject"/>
                </do_if>
                <do_else>
                  <set_value name="$Feedback" exact="'$INVALID_ITEMOBJECT'"/>
                  <signal_cue cue="CleanUp"/>
                  <cancel_cue cue="this"/>
                </do_else>
              </actions>
              <cues>
                <cue name="Without_Offer_Accept_On_Collection_Destroyed">
                  <conditions>
                    <check_any>
                      <event_object_destroyed group="$CollectionGroup"/>
                      <check_all>
                        <event_player_opened_crate/>
                        <check_value value="$CollectionGroup.indexof.{event.param}"/>
                      </check_all>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="event.name == 'event_player_opened_crate' or (event.param2 == killmethod.collected and event.param.isplayerowned)">
                      <signal_cue cue="MissionAccepted" />
                      <do_if value="Without_Offer_Wait_Cue.state == cuestate.complete">
                        <cancel_cue cue="Without_Offer_Wait_Cue"/>
                      </do_if>
                      <cancel_cue cue="Without_Offer_Accept_On_Collection"/>
                    </do_if>
                    <do_else>
                      <!--TODO-->
                      <set_value name="$Feedback" exact="'$INVALID_ITEMOBJECT'"/>
                      <signal_cue cue="CleanUp"/>
                    </do_else>
                  </actions>
                </cue>
                <cue name="Without_Offer_Accept_On_Collection_Lockbox" onfail="cancel">
                  <conditions>
                    <check_value value="$ItemHolderObject.isclass.lockbox"/>
                  </conditions>
                  <cues>
                    <cue name="Without_Offer_Accept_On_Collection_Lockbox_Dropped">
                      <conditions>
                        <event_object_dropped_objects object="$ItemHolderObject"/>
                      </conditions>
                      <actions>
                        <remove_from_group group="$CollectionGroup" object="$ItemHolderObject"/>
                        <do_for_each name="$Dropped" in="event.param">
                          <do_if value="$Dropped.wares.{$DeliveryItem}.exists">
                            <add_to_group groupname="$CollectionGroup" object="$Dropped"/>
                          </do_if>
                        </do_for_each>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <!--These cues handle the briefing presentations e.g. Holomap or cutscene render targets (depending on the mission)-->
            <cue name="BriefingStarted">
              <conditions>
                <check_any>
                  <event_briefing_started cue="$MissionCue"/>
                  <event_briefing_submission_selected cue="$MissionCue"/>
                </check_any>
              </conditions>
              <actions>
                <set_value name="$RenderTarget" exact="event.param.{1}"/>

                <set_value name="$BriefingCutsceneStarted" />
                <debug_text text="'Briefing started'" chance="$DebugChance"/>
              </actions>
              <cues>

                <cue name="DisplayCutscene" onfail="cancel">
                  <conditions>
                    <check_value value="$BriefingCutsceneStarted?"/>
                  </conditions>
                  <actions>
                    <set_value name="$CutsceneObject" exact="$DeliveryNPC" />
                    <set_value name="$CutsceneKey" exact="'ShowCharacter'" />
                    <play_cutscene key="$CutsceneKey" rendertarget="$RenderTarget">
                      <param name="npcref" object="$CutsceneObject" />
                    </play_cutscene>
                  </actions>
                </cue>

                <cue name="BriefingStopped">
                  <conditions>
                    <check_any>
                      <event_briefing_cancelled cue="$MissionCue"/>
                      <event_briefing_submission_unselected cue="$MissionCue"/>
                    </check_any>
                  </conditions>
                  <actions>
                    <!--Temp value. This is used to identify if a cutscene for this mission is still playing.-->
                    <do_if value="$BriefingCutsceneStarted?">
                      <remove_value name="$BriefingCutsceneStarted"/>
                      <stop_cutscene key="$CutsceneKey"/>
                    </do_if>

                    <debug_text text="'Briefing cancelled'" chance="$DebugChance"/>
                    <reset_cue cue="BriefingStarted"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="DeliveryNpcKilled_Early">
              <conditions>
                <event_object_destroyed object="$DeliveryNPC"/>
              </conditions>
              <actions>
                <set_value name="$Feedback" exact="'$DELIVERYNPC_KILLED_EARLY'"/>
                <signal_cue cue="CleanUp"/>
              </actions>
            </cue>

            <cue name="DeliverStationDestroyed_Early">
              <conditions>
                <event_object_destroyed object="$DeliveryStation"/>
              </conditions>
              <actions>
                <set_value name="$Feedback" exact="'$DELIVERY_STATION_DESTROYED_EARLY'"/>
                <signal_cue cue="CleanUp"/>
              </actions>
            </cue>

            <!--This cue creates the mission itself, either from scratch or via an existing mission offer-->
            <cue name="MissionAccepted">
              <conditions>
                <event_cue_signalled />
              </conditions>
              <actions>
                <debug_text text="'Mission accepted!'" chance="$DebugChance"/>
                <set_value name="stat.missions_accepted" operation="add"/>

                <do_if value="$WithoutOffer">
                  <!--$MissionCue may already be a mission cue passed in as a parameter-->
                  <do_if value="not $MissionCue.hasmission">
                    <do_if value="$MissionThread">
                      <create_mission cue="$MissionCue" missionthread="$MissionThread" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" faction="$ClientOwner" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText" abortable="$MissionAbortable" icon="$BriefingIcon"/>
                    </do_if>
                    <do_else>
                      <create_mission cue="$MissionCue" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" faction="$ClientOwner" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText" abortable="$MissionAbortable" icon="$BriefingIcon"/>
                    </do_else>
                  </do_if>

                  <update_mission cue="$MissionCue">
                    <briefing>
                      <objective step="1" action="objective.deliver" text="$TextTable.$objective" encyclopedia="$DeliveryItem" comment="Deliver: $AMOUNT$x $WARE$" />
                    </briefing>
                  </update_mission>
                </do_if>
                <do_else>
                  <!--Copy data from the offer, then remove it-->
                  <do_if value="$MissionThread">
                    <create_mission cue="$MissionCue" offercue="$MissionCue" missionthread="$MissionThread" abortable="$MissionAbortable" icon="$BriefingIcon"/>
                  </do_if>
                  <do_else>
                    <create_mission cue="$MissionCue" offercue="$MissionCue" abortable="$MissionAbortable" icon="$BriefingIcon"/>
                  </do_else>
                  <remove_offer cue="$MissionCue"/>
                  <cancel_cue cue="With_Offer"/>
                </do_else>

                <do_if value="$ReportSignalCue">
                  <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_ACCEPTED.clone"/>
                  <set_value name="$FeedbackData.$ID" exact="'$MISSION_ACCEPTED'"/>
                  <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="Mission accepted"/>
                  <signal_cue_instantly cue="$ReportSignalCue"/>
                </do_if>

                <signal_cue_instantly cue="md.GenericMissions.GenericAcceptLogbookEntry" param="[$TextTable.$missionname, $Client, $ClientOwner]"/>
              </actions>
              <cues>
                <cue name="ActivateImmediately" onfail="cancel">
                  <conditions>
                    <check_value value="not $MissionThread"/>
                  </conditions>
                  <actions>
                    <signal_cue cue="ActivateMission"/>
                  </actions>
                </cue>

                <cue name="ActivateOnCondition" onfail="cancel">
                  <conditions>
                    <check_value value="$MissionThread"/>
                  </conditions>
                  <actions>
                    <do_if value="$MissionThread.canactivatesubmission.{$MissionCue}">
                      <signal_cue cue="ActivateMission"/>
                      <cancel_cue cue="ActivateOnCondition"/>
                    </do_if>
                  </actions>
                  <cues>
                    <!--TODO @Owen add an event for when a submission has been removed from the thread-->
                    <cue name="CheckMissionThreadState" checkinterval="1s">
                      <conditions>
                        <check_value value="$MissionThread.canactivatesubmission.{$MissionCue}"/>
                      </conditions>
                      <actions>
                        <signal_cue cue="ActivateMission"/>
                        <cancel_cue cue="ActivateOnCondition"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="ActivateMission" version="2">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <cancel_cue cue="DeliveryNpcKilled_Early"/>
                    <cancel_cue cue="DeliverStationDestroyed_Early"/>

                    <set_value name="$StartStep" exact="1"/>

                    <set_value name="$AmountToBeDelivered" exact="$DeliveryAmount" comment="Track the number of items the player has already delivered - when it hits 0, this mission is complete" />
                    <do_if value="$DeliveryNPC.type" exact="entitytype.shadyguy">
                      <!-- If this is the mission variant working with a shady guy, check to see whether they require unlocking -->
                      <debug_text text="'We are working with a shady guy - look to see whether they require unlocking'" chance="$DebugChance" />
                      <do_if value="not $DeliveryNPC.tradesvisible">
                        <debug_text text="'Registering this mission ' + $MissionCue + ' as a requester for shady guy instantiation of ' + $DeliveryNPC" chance="$DebugChance" />
                        <do_if value="not $DeliveryNPC.$InstantiationRequesters?">
                          <set_value name="$DeliveryNPC.$InstantiationRequesters" exact="[]"/>
                        </do_if>
                        <append_to_list name="$DeliveryNPC.$InstantiationRequesters" exact="$MissionCue"/>
                        <signal_objects object="$DeliveryStation" param="'npc_instantiation__mission'" comment="Make sure the shady guy is actually properly instantiated on the station" />
                      </do_if>
                    </do_if>
                    <set_value name="$MissionActivationTime" exact="player.age"/>
                  </actions>
                  <patch sinceversion="2" state="complete">
                    <set_value name="$Patch200_CancelDestructionCues" exact="true"/>
                  </patch>
                  <cues>

                    <cue name="Debug_AddNecessaryItems" instantiate="true">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <add_inventory entity="player.entity" ware="$DeliveryItem" exact="$DeliveryAmount" />
                        <debug_text text="$DeliveryAmount + ' ' + $DeliveryItem.name + ' added to player inventory'" />
                      </actions>
                    </cue>

                    <cue name="Patch200_CancelDestructionCues" onfail="cancel">
                      <conditions>
                        <check_value value="$Patch200_CancelDestructionCues?" />
                      </conditions>
                      <actions>
                        <cancel_cue cue="DeliveryNpcKilled_Early"/>
                        <cancel_cue cue="DeliverStationDestroyed_Early"/>
                      </actions>
                    </cue>

                    <cue name="DeliverInventory_RML">
                      <actions>
                        <set_value name="$WaresTable" exact="table[]"/>
                        <set_value name="$WaresTable.{$DeliveryItem}" exact="[$DeliveryAmount, $AmountToBeDelivered]"/>
                      </actions>
                      <cues>
                        <cue name="DeliverInventory_RML_Ref" ref="md.RML_Deliver_Inventory.Deliver_Inventory">
                          <param name="EndSignalCue"    value="MissionEnded"/>
                          <param name="MissionCue"      value="$MissionCue"/>
                          <param name="StartStep"       value="$StartStep"  comment="Briefing step to start the mission on"/>
                          <param name="UpdateBriefing"  value="true"        comment="Update the briefing objective step when the objective is updated"/>

                          <!--Delivery params-->
                          <param name="WaresTableParam" value="$WaresTable"       comment="Table of ware amounts. Key = ware. Value = [$maxamount, $remainingamount]. Inventory wares only."/>
                          <param name="DeliveryNPC"     value="$DeliveryNPC"      comment="The NPC to which the items should be delivered." />
                          <param name="DeliveryObject"  value="$DeliveryStation"  comment="The object on which to point to before the NPC is placed. Also used to create the interior with the below parameters" />
                          <param name="ProgressBarText"         value="$TextTable.$progress" comment="Text to be displayed next to the ware delivery progress bar e.g. ('Delivered')"/>
                          <param name="ConversationOptionText"  value="$TextTable.$conversationoption"/>
                          <param name="ConversationTipText"     value="$TextTable.$tooltip"/>
                          <!-- ************************************************************************************************************************************************************************ -->
                          <!-- NPC Placement and interior creation - See library for parameter details-->
                          <param name="PlaceNPC"              value="$PlaceNPC"/>
                          <param name="PlacementTable"        value="$PlacementTable"/>
                          <param name="DeliveryNPCSlotTags"   value="$DeliveryNPCSlotTags"/>

                          <!-- Interior parameters. If either is provided, all must be valid. -->
                          <param name="DeliveryRoomMacro"     value="$DeliveryRoomMacro"    comment="The dynamic interior room the DeliveryNPC should be placed in, if not placed already" />
                          <param name="DeliveryCorridorMacro" value="$DeliveryCorridorMacro" comment="The dynamic interior corridor leading to DeliveryRoomMacro" />
                          <param name="DeliveryDoor"          value="if $DeliveryDoors then $DeliveryDoors.random else null" comment="The possible dynamic interior doors used to connect the room and corridor. When defining a room or corridor macro, this is is the variable saved in the doors parameter" />
                          <param name="DeliveryInteriorName"  value="$DeliveryInteriorName" comment="The name of the dynamic interior the DeliveryNPC should used, if not placed already" />
                          <!-- ************************************************************************************************************************************************************************ -->
                          <param name="DebugChance"           value="$DebugChance"/>
                        </cue>
                      </cues>
                    </cue>

                    <cue name="Aborted">
                      <conditions>
                        <event_mission_aborted cue="$MissionCue"/>
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="md.GenericMissions.GenericAbortLogbookEntry" param="[$TextTable.$missionname, $Client]"/>

                        <set_value name="$Feedback" exact="'$MISSION_ABORTED'"/>
                        <remove_mission cue="$MissionCue" type="aborted"/>
                        <signal_cue cue="CleanUp" />
                      </actions>
                    </cue>

                    <cue name="MissionTimeout" onfail="cancel">
                      <conditions>
                        <check_value value="typeof $MissionDuration == datatype.time"/>
                        <check_value value="$MissionDuration" min="1s"/>
                      </conditions>
                      <delay exact="$MissionDuration"/>
                      <actions>
                        <signal_cue_instantly cue="md.GenericMissions.GenericTimeoutLogbookEntry" param="[$TextTable.$missionname, $Client]"/>

                        <remove_mission cue="$MissionCue" type="failed"/>
                        <set_value name="$Feedback" exact="'$MISSION_TIMEOUT'"/>
                        <signal_cue_instantly cue="CleanUp" />
                      </actions>
                    </cue>

                    <cue name="MissionEnded">
                      <conditions>
                        <event_cue_signalled/>
                      </conditions>
                      <actions>
                        <!-- Failure case -->
                        <do_if value="MissionEnded.$EndFeedbackValue" max="0">
                          <debug_text text="'This mission has failed. Feedback: ' + MissionEnded.$EndFeedbackValue" chance="$DebugChance"/>
                          <do_if value="MissionEnded.$EndFeedbackValue == -3">
                            <set_value name="$Feedback" exact="'$DELIVERY_STATION_DESTROYED'"/>
                          </do_if>
                          <do_elseif value="MissionEnded.$EndFeedbackValue == -2">
                            <set_value name="$Feedback" exact="'$DELIVERYNPC_KILLED'"/>
                          </do_elseif>
                          <do_else>
                            <set_value name="$Feedback" exact="'$MISSION_FAILED'"/>
                            <speak actor="$Client" line="$VoiceTable.$MissionFailed" comment="(failed mission)" chance="if $VoiceTable.$MissionFailed == 0 then 0 else 100" />
                          </do_else>
                          <signal_cue_instantly cue="md.GenericMissions.GenericFailLogbookEntry" param="[$TextTable.$missionname, $Client, @MissionEnded.$EndFeedbackText]"/>

                          <remove_mission cue="$MissionCue" type="failed" reason="@MissionEnded.$EndFeedbackText"/>
                        </do_if>

                        <!-- Success case -->
                        <do_else>
                          <debug_text text="'This mission has ended. Feedback: ' + MissionEnded.$EndFeedbackValue" chance="$DebugChance"/>
                          <do_if value="$RewardNotoriety and $ClientOwner">
                            <debug_text text="'Relation was: ' + player.entity.relationto.{$ClientOwner}" chance="$DebugChance"/>
                            <add_faction_relation faction="faction.player" otherfaction="$ClientOwner" value="$RewardNotoriety" reason="relationchangereason.missioncompleted" />
                            <debug_text text="'Relation is now: ' + player.entity.relationto.{$ClientOwner}" chance="$DebugChance"/>
                          </do_if>

                          <include_actions ref="md.LIB_Reward_Balancing.Apply_TimeBonusCr" comment="Input: $TimeBonusCr_Max, $MissionActivationTime, ($DurationUntilBonusDecay), ($DurationUntilBonusExpiry), ($RewardCr); Output: $RewardCr"/>

                          <do_if value="$RewardCr" comment="There may be a credit reward (e.g. time bonus) even if the main reward is an object">
                            <reward_player money="$RewardCr"/>
                          </do_if>
                          <do_if value="$RewardObj">
                            <do_if value="typeof $RewardObj == datatype.ware and $RewardObj.isinventory">
                              <add_inventory entity="player.entity" ware="$RewardObj" />
                              <show_notification text="[{1015,100}, '', $RewardText]" sound="notification_achievement" comment="Item received" />
                            </do_if>
                            <do_elseif value="$RewardObj.isclass.npc and $RewardObj.isshadyguy">
                              <set_entity_traits entity="$RewardObj" tradesvisible="true"/>
                              <unlock_achievement name="BLACK_MARKET"/>
                            </do_elseif>
                          </do_if>
                          <set_value name="stat.missions_completed" operation="add"/>
                          <set_value name="$Feedback" exact="'$MISSION_SUCCEEDED'"/>
                          <speak actor="$Client" line="$VoiceTable.$MissionSuccess" comment="(successful mission)" chance="if $VoiceTable.$MissionSuccess == 0 then 0 else 100" />
                          <signal_cue_instantly cue="md.GenericMissions.GenericCompleteLogbookEntry" param="[$TextTable.$missionname, $Client, null, $RewardCr]"/>

                          <run_actions ref="md.GenericMissions.UpdateTextOffsetsTable_completedcounter">
                            <param name="StaticGMCue" value="md.GM_BringItems.GenerateGenericMission"/>
                            <param name="Page"        value="$Page"/>
                            <param name="TextOffset"  value="$TextOffset"/>
                          </run_actions>

                          <remove_mission cue="$MissionCue" type="completed" activate="next" />
                        </do_else>
                        <signal_cue cue="CleanUp" />
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="ForceCleanup" onfail="cancel">
          <conditions>
            <check_value value="$ForceCleanup"/>
          </conditions>
          <actions>
            <do_if value="not $ForceCleanup.exists">
              <set_value name="$Feedback" exact="'$INVALID_FORCE_CLEANUP'"/>
              <signal_cue_instantly cue="CleanUp"/>
            </do_if>
          </actions>
          <cues>
            <cue name="ForceCleanup_Wait">
              <conditions>
                <check_any>
                  <event_cue_completed cue="$ForceCleanup"/>
                  <check_all>
                    <event_cue_signalled cue="$ForceCleanup"/>
                    <check_value value="event.param == $MissionCue"/>
                  </check_all>
                </check_any>
              </conditions>
              <actions>
                <set_value name="$Feedback" exact="'$FORCED_CLEANUP'"/>
                <signal_cue_instantly cue="CleanUp"/>
              </actions>
            </cue>
          </cues>
        </cue>

        <cue name="CleanUp">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <!--Temp value. This is used to identify if a cutscene for this mission is still playing.-->
            <do_if value="$BriefingCutsceneStarted?">
              <remove_value name="$BriefingCutsceneStarted"/>
              <stop_cutscene key="$CutsceneKey"/>

              <do_if value="@$CutsceneCluster.exists">
                <destroy_object object="$CutsceneCluster"/>
              </do_if>
              <do_if value="$CutsceneShip.exists">
                <destroy_object object="$CutsceneShip"/>
              </do_if>
            </do_if>
            <do_if value="$HoloMap?">
              <remove_holomap />
              <remove_value name="$HoloMap"/>
            </do_if>


            <!--***Cleanup objects***-->
            <!--No .exists check here as $Client may not be connected to gamegraph-->
            <do_if value="$Client.isclass.npc and (not $PreexistingClient?)">
              <signal_cue_instantly cue="md.GenericMissions.CleanupActor" param="[$Client]" />
            </do_if>

            <do_if value="$DeliveryNPC.$InstantiationRequesters?">
              <remove_from_list name="$DeliveryNPC.$InstantiationRequesters" exact="$MissionCue" multiple="false" />
              <do_if value="$DeliveryNPC.$InstantiationRequesters.count == 0">
                <remove_value name="$DeliveryNPC.$InstantiationRequesters"/>
              </do_if>
            </do_if>

            <!--***Evaluate result***-->
            <do_if value="$DebugChance or $ReportSignalCue">
              <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.{$Feedback}.clone"/>
              <do_if value="$FeedbackData">
                <set_value name="$FeedbackData.$ID" exact="$Feedback"/>
                <debug_text text="'Mission ended with reason: ' + $FeedbackData.$type + ' - ' + $FeedbackData.$text" chance="$DebugChance"/>
              </do_if>
              <do_else>
                <set_value name="$FeedbackData" exact="table[$ID = 'error_unknown', $type = 'error', $text = 'This is an unknown error']" comment="feedback = id, type and error-text from the above FeedbackValues-table"/>
                <assert value="false" text="'Mission ended with unknown case: ' + $Feedback + ' [Owen]'" break="1"/>
              </do_else>

              <do_if value="$ReportSignalCue" comment ="The cue which called us">
                <set_value name="$ReportSignalCue.$EndFeedbackValue" exact="$FeedbackData" comment="return feedback-data to calling cue"/>
                <signal_cue cue="$ReportSignalCue"/>
              </do_if>
            </do_if>

            <cancel_cue cue="Start"/>
          </actions>
        </cue>
      </cues>
    </library>

    <!-- Clean up of non-preexisting delivery client and dynamic interior -->
    <!-- NO LONGER SIGNALLED - Cue remains for savegame compatibility-->
    <cue name="CleanUpDynamicInterior" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <set_value name="$Interior" exact="event.param.{1}" />
        <set_value name="$InteriorStation" exact="$Interior.station" />
        <set_value name="$NPC" exact="event.param.{2}" />
      </actions>
      <cues>
        <cue name="PlayerLeavesArea">
          <conditions>
            <event_object_interiors_despawning object="$InteriorStation" />
          </conditions>
          <actions>
            <signal_cue_instantly cue="md.GenericMissions.CleanupActor" param="[$NPC]" />
            <remove_dynamic_interior object="$InteriorStation" interior="$Interior" />
          </actions>
        </cue>
      </cues>
    </cue>


    <!-- MISSION SETUP HELPERS -->

    <!--TODO @Owen - check if the setup libraries for GMs and subscription missions should be separated-->

    <!-- Requires: $Faction, Result: $TargetStation, $DeliveryItem, $DeliveryAmount
    If $Station is provided, it will be used as the $TargetStation-->
    <library name="Setup_Production_MiningEquipment">
      <actions>
        <set_value name="$TargetStation" exact="null"/>
        <do_if value="@$Station.exists">
          <find_dockingbay name="$Stationdock" object="$Station" multiple="false">
            <match_dock walkable="true"/>
          </find_dockingbay>
          <do_if value="$Stationdock.isoperational">
            <set_value name="$TargetStation" exact="$Station"/>
          </do_if>
        </do_if>
        <do_else>
          <find_cluster_in_range name="$LocalClusters" object="player.entity" maxdistance="2" multiple="true"/>
          <shuffle_list list="$LocalClusters"/>
          <do_all exact="$LocalClusters.count" counter="$cluster_i">
            <find_station_by_true_owner name="$TargetStation" space="$LocalClusters.{$cluster_i}" faction="$Faction" multiple="false">
              <match_dock size="tag.dock_s"/>
              <match_relation_to faction="faction.player" relation="dock" comparison="ge" />
            </find_station_by_true_owner>
            <do_if value="$TargetStation">
              <break/>
            </do_if>
          </do_all>
        </do_else>
        <!-- Common station trader's corner items, see stock.xml -->
        <set_value name="$DeliveryItem" exact="[ware.inv_carbonfilter, ware.inv_micromotor, ware.inv_hydraulicpump].random"/>
        <set_value name="$DeliveryAmount" min="5" max="13"/>
        <set_value name="$DeliveryRoomTags" exact="[tag.crewquarters]"/>
      </actions>
    </library>

    <!-- Requires: $Faction, Result: $TargetStation, $DeliveryItem, $DeliveryAmount
    If $Station is provided, it will be used as the $TargetStation-->
    <library name="Setup_Production_Explosives">
      <actions>
        <set_value name="$TargetStation" exact="null"/>
        <do_if value="@$Station.exists">
          <find_dockingbay name="$Stationdock" object="$Station" multiple="false">
            <match_dock walkable="true"/>
          </find_dockingbay>
          <do_if value="$Stationdock.isoperational">
            <set_value name="$TargetStation" exact="$Station"/>
          </do_if>
        </do_if>
        <do_else>
          <find_cluster_in_range name="$LocalClusters" object="player.entity" maxdistance="2" multiple="true"/>
          <shuffle_list list="$LocalClusters"/>
          <do_all exact="$LocalClusters.count" counter="$cluster_i">
            <find_station_by_true_owner name="$TargetStation" space="$LocalClusters.{$cluster_i}" faction="$Faction" multiple="false">
              <match_dock walkable="true"/>
              <match_relation_to faction="faction.player" relation="dock" comparison="ge" />
            </find_station_by_true_owner>
            <do_if value="$TargetStation">
              <break/>
            </do_if>
          </do_all>
        </do_else>
        <!-- Rare shady guy and mining items, see stock.xml -->
        <set_value name="$Difficulty" exact="level.easy"/>
        <set_value name="$MissionLevel" exact="10" operation="add"/>
        <set_value name="$DeliveryItem" exact="[ware.inv_unstablecrystal].random"/>
        <set_value name="$DeliveryAmount" min="1" max="2"/>
        <set_value name="$DeliveryRoomTags" exact="[tag.livingroom, tag.shady]"/>
      </actions>
    </library>


    <!-- Requires: $Faction, Result: $TargetStation, $DeliveryItem, $DeliveryAmount
    If $Station is provided, it will be used as the $TargetStation-->
    <library name="Setup_Production_Spices">
      <actions>
        <set_value name="$TargetStation" exact="null"/>
        <do_if value="@$Station.exists">
          <find_dockingbay name="$Stationdock" object="$Station" multiple="false">
            <match_dock walkable="true"/>
          </find_dockingbay>
          <do_if value="$Stationdock.isoperational">
            <set_value name="$TargetStation" exact="$Station"/>
          </do_if>
        </do_if>
        <do_else>
          <find_cluster_in_range name="$LocalClusters" object="player.entity" maxdistance="2" multiple="true"/>
          <shuffle_list list="$LocalClusters"/>
          <do_all exact="$LocalClusters.count" counter="$cluster_i">
            <find_station_by_true_owner name="$TargetStation" space="$LocalClusters.{$cluster_i}" faction="$Faction" multiple="false">
              <match_dock walkable="true"/>
              <match_relation_to faction="faction.player" relation="dock" comparison="ge" />
            </find_station_by_true_owner>
            <do_if value="$TargetStation">
              <break/>
            </do_if>
          </do_all>
        </do_else>
        <!-- Common station trader's corner items, see stock.xml -->
        <set_value name="$DeliveryItem" exact="[ware.inv_rarespices].random"/>
        <set_value name="$DeliveryAmount" min="5" max="13"/>
        <set_value name="$DeliveryRoomTags" exact="[tag.bar]"/>
      </actions>
    </library>

    <!-- Requires: $Faction, Result: $TargetStation, $DeliveryItem, $DeliveryAmount
    If $Station is provided, it will be used as the $TargetStation-->
    <library name="Setup_Production_WaterPurification">
      <actions>
        <set_value name="$TargetStation" exact="null"/>
        <do_if value="@$Station.exists">
          <find_dockingbay name="$Stationdock" object="$Station" multiple="false">
            <match_dock size="tag.dock_s"/>
          </find_dockingbay>
          <do_if value="$Stationdock.isoperational">
            <set_value name="$TargetStation" exact="$Station"/>
          </do_if>
        </do_if>
        <do_else>
          <find_cluster_in_range name="$LocalClusters" object="player.entity" maxdistance="2" multiple="true"/>
          <shuffle_list list="$LocalClusters"/>
          <do_all exact="$LocalClusters.count" counter="$cluster_i">
            <find_station_by_true_owner name="$TargetStation" space="$LocalClusters.{$cluster_i}" faction="$Faction" multiple="false">
              <match_dock walkable="true"/>
              <match_relation_to faction="faction.player" relation="dock" comparison="ge" />
            </find_station_by_true_owner>
            <do_if value="$TargetStation">
              <break/>
            </do_if>
          </do_all>
        </do_else>
        <!-- Common station trader's corner items, see stock.xml -->
        <set_value name="$DeliveryItem" exact="[ware.inv_algaescrubber, ware.inv_rapidsandfilter, ware.inv_carbonfilter].random"/>
        <set_value name="$DeliveryAmount" min="5" max="13" comment="See stock.xml"/>
        <set_value name="$DeliveryRoomTags" exact="[tag.generatorroom]"/>
      </actions>
    </library>

    <!-- Requires: $Faction, Result: $TargetStation, $DeliveryItem, $DeliveryAmount
    If $Station is provided, it will be used as the $TargetStation-->
    <library name="Setup_Production_Herbices">
      <actions>
        <set_value name="$TargetStation" exact="null"/>
        <do_if value="@$Station.exists">
          <find_dockingbay name="$Stationdock" object="$Station" multiple="false">
            <match_dock walkable="true"/>
          </find_dockingbay>
          <do_if value="$Stationdock.isoperational">
            <set_value name="$TargetStation" exact="$Station"/>
          </do_if>
        </do_if>
        <do_else>
          <find_cluster_in_range name="$LocalClusters" object="player.entity" maxdistance="2" multiple="true"/>
          <shuffle_list list="$LocalClusters"/>
          <do_all exact="$LocalClusters.count" counter="$cluster_i">
            <find_station_by_true_owner name="$TargetStation" space="$LocalClusters.{$cluster_i}" faction="$Faction" multiple="false">
              <match_dock walkable="true"/>
              <match_relation_to faction="faction.player" relation="dock" comparison="ge" />
            </find_station_by_true_owner>
            <do_if value="$TargetStation">
              <break/>
            </do_if>
          </do_all>
        </do_else>
        <!-- Common station trader's corner items, see stock.xml -->
        <set_value name="$DeliveryItem" exact="[ware.inv_herbicide].random"/>
        <set_value name="$DeliveryAmount" min="20" max="30"/>
        <set_value name="$DeliveryRoomTags" exact="[tag.crewquarters]"/>
      </actions>
    </library>

    <!-- Requires: $Faction, Result: $TargetStation, $DeliveryItem, $DeliveryAmount
    If $Station is provided, it will be used as the $TargetStation-->
    <library name="Setup_ExquisiteFood">
      <actions>
        <set_value name="$TargetStation" exact="null"/>
        <do_if value="@$Station.exists">
          <find_dockingbay name="$Stationdock" object="$Station" multiple="false">
            <match_dock walkable="true"/>
          </find_dockingbay>
          <do_if value="$Stationdock.isoperational">
            <set_value name="$TargetStation" exact="$Station"/>
          </do_if>
        </do_if>
        <do_else>
          <find_cluster_in_range name="$LocalClusters" object="player.entity" maxdistance="2" multiple="true"/>
          <shuffle_list list="$LocalClusters"/>
          <do_all exact="$LocalClusters.count" counter="$cluster_i">
            <find_station_by_true_owner name="$TargetStation" space="$LocalClusters.{$cluster_i}" faction="$Faction" multiple="false">
              <match_dock walkable="true"/>
              <match_relation_to faction="faction.player" relation="dock" comparison="ge" />
            </find_station_by_true_owner>
            <do_if value="$TargetStation">
              <break/>
            </do_if>
          </do_all>
        </do_else>
        <!-- Craftable item, ingredients are common station trader's corner items, see stock.xml -->
        <set_value name="$Difficulty" exact="level.easy"/>
        <set_value name="$MissionLevel" exact="5" operation="add"/>
        <set_value name="$DeliveryItem" exact="[ware.inv_finemeal].random"/>
        <set_value name="$DeliveryAmount" min="1" max="3"/>
        <set_value name="$DeliveryRoomTags" exact="[tag.livingroom, tag.generic]"/>
      </actions>
    </library>

    <library name="CalculateResourceCost" purpose="run_actions">
      <params>
        <param name="DeliveryItem"/>
        <param name="DeliveryAmount"/>
      </params>
      <actions>
        <set_value name="$ResourceCost__Result" exact="0Cr"/>
        <!-- reimburse cost of required inventory items -->
        <set_value name="$ResourceCost__Result" exact="(($DeliveryItem.averageprice * $DeliveryAmount) * 2) / (10Cr) * (10Cr)" comment="round"/>
        <return value="$ResourceCost__Result"/>
      </actions>
    </library>

    <!-- Requires: $Faction, Result: $TargetStation, $DeliveryItem, $DeliveryAmount
    Not currently used-->
    <!--<library name="Setup_Smuggle">
      <actions>
        <include_actions ref="Setup_FindStation" comment="input: $Faction, output: $TargetStation"/>
        <set_value name="$DeliveryItem" exact="[ware.inv_agidevice_03, ware.inv_hallucinogenics, ware.inv_harddrug_01].random"/>
        <set_value name="$DeliveryAmount" exact="[1,2,3].random" />
      </actions>
    </library>-->


    <!--GENERIC MISSION VARIANTS-->

    <cue name="Force_Generic_Var_1" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <signal_cue cue="md.GenericMissions.RemoveAllOffers" />
        <do_all exact="30">
          <signal_cue_instantly cue="GenerateGenericMission" param="table[$Sector = player.sector, $MissionVariant = 1, $DebugChance = 100]"/>
        </do_all>
      </actions>
      <force name="GM_BringItems_Var_1" />
    </cue>

    <!--event.param = table[
    $Sector,
    $ReportSignalCue (Optional. Cue to be signalled when something happens which could be of interest to the calling cue. Saves values to ReportSignalCue.$FeedbackValue and ReportSignalCue.$EndFeedbackValue)
    $MissionVariant (Optional),
    $RemoveOnSectorChange (Optional, defaults to true)
    $DebugChance (Optional)]-->
    <cue name="GenerateGenericMission" instantiate="true" namespace="this" version="2">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$Sector"           exact="event.param.$Sector"/>
        <set_value name="$ReportSignalCue"  exact="@event.param.$ReportSignalCue"/>
        <set_value name="$MissionVariant"   exact="@event.param.$MissionVariant"/>
        <do_if value="event.param.$RemoveOnSectorChange?">
          <set_value name="$RemoveOnSectorChange" exact="event.param.$RemoveOnSectorChange"/>
        </do_if>
        <do_else>
          <set_value name="$RemoveOnSectorChange" exact="true"/>
        </do_else>

        <set_value name="$DebugChance"      exact="@event.param.$DebugChance"/>
        <set_value name="$ReportSignalCue.$GM_Wrapper" exact="this"/>

        <set_value name="$FeedbackManager" exact="FeedbackValueManager"/>
        <assert value="$FeedbackManager.$FeedbackValues.$MISSION_NO_VARIANT?" text="'Required error code does not exist. Was the FeedbackValueManager not updated for stand-alone missions? [Owen/Roger]'"/>

        <debug_text text="'Attempting to generate a generic mission'" chance="$DebugChance"/>
      </actions>
      <patch sinceversion="2" state="complete">
        <do_if value="$ReportSignalCue.exists">
          <set_value name="$ReportSignalCue.$GM_Wrapper" exact="this"/>
        </do_if>
        <do_else>
          <debug_text text="'cancelling dead GM instance'" filter="savegame"/>
          <cancel_cue cue="this"/>
        </do_else>
      </patch>
      <cues>
        <cue name="GenerateGenericMission_SelectVariant">
          <actions>
            <set_value name="$ValidVariants" exact="[]"/>

            <!--Set up some common variables first so that the variants don't have to do things multiple times-->

            <!--Find potential offer stations in the sector-->
            <find_station name="$PotentialOfferStations" excluded="md.GenericMissions.Manager.$ExcludedOfferObjects" space="$Sector" multiple="true">
              <match owner="md.GenericMissions.Manager.$DefaultExcludedOfferFactions" negate="true"/>
              <match_relation_to object="player.entity" comparison="not" relation="enemy" />
            </find_station>

            <do_if value="$PotentialOfferStations.count">

              <do_if value="$MissionVariant">
                <!--A specific MissionVariant ID was requested-->
                <debug_text text="'Checking if requested ' + $MissionVariant + ' can be spawned'" chance="$DebugChance"/>
                <do_if value="$MissionVariant == 1">
                  <signal_cue_instantly cue="GenerateGenericMission_Variant_1"/>
                </do_if>
                <do_else>
                  <assert value="false" text="'Unknown $MissionVariant ID ' + $MissionVariant + ' [Owen]'"/>
                </do_else>
              </do_if>
              <do_else>
                <!--Attempt to a mission variant at random-->
                <signal_cue_instantly cue="GenerateGenericMission_Variant_1"/>
              </do_else>
            </do_if>

            <do_if value="$ValidVariants.count">
              <signal_cue cue="$ValidVariants.random"/>
            </do_if>
            <do_else>
              <do_if value="$ReportSignalCue">
                <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_NO_VARIANT.clone"/>
                <set_value name="$FeedbackData.$ID" exact="'$MISSION_NO_VARIANT'"/>
                <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="No mission variant possible"/>
                <signal_cue_instantly cue="$ReportSignalCue"/>
              </do_if>
              <cancel_cue cue="GenerateGenericMission"/>
            </do_else>
          </actions>
        </cue>

        <cue name="GenerateGenericMission_Variant_1" namespace="this">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <!--this uses its own namespace so grab the shared data from GenerateGenericMission-->
            <set_value name="$Sector" exact="GenerateGenericMission.$Sector"/>
            <set_value name="$DebugChance" exact="GenerateGenericMission.$DebugChance"/>
            <set_value name="$OfferStations" exact="GenerateGenericMission.$PotentialOfferStations.clone"/>
            <shuffle_list list="$OfferStations"/>

            <set_value name="$Valid" exact="false"/>
            <set_value name="$MissionLevel" exact="1"/>
            <set_value name="$Difficulty" exact="level.veryeasy"/>
            <set_value name="$Station" exact="$OfferStations.random"/>
            <set_value name="$Faction" exact="$Station.owner"/>
            <set_value name="$TargetStation" exact="null"/>
            <set_value name="$DeliveryItem" exact="null"/>
            <set_value name="$DeliveryAmount" exact="0"/>
            <set_value name="$OwnedAmount" exact="0"/>

            <!-- Select Mission Variant for page 30135 -->
            <set_value name="$ValidOffsets" exact="[2000, 2100, 2200, 2300, 2400, 3000]"/>

            <do_if value="md.$SplitFactions.indexof.{$Faction}">
              <append_list_elements name="$ValidOffsets" other="[2500, 2600]"/>
            </do_if>
            <do_if value="md.$TerranFactions.indexof.{$Faction}">
              <append_list_elements name="$ValidOffsets" other="[4000, 4100]"/>
            </do_if>
            <do_if value="md.$DLCBoronFactions.indexof.{$Faction}">
              <append_list_elements name="$ValidOffsets" other="[5000, 5100, 5200]"/>
            </do_if>

            <!-- SelectMissionVariant library (weighted choice and $lastoffertime tracking) -->
            <run_actions ref="md.GenericMissions.SelectMissionVariant" result="$TextOffset_Table">
              <param name="StaticGMCue"    value="md.GM_BringItems.GenerateGenericMission"/>
              <param name="ValidOffsets"   value="table[{30135} = $ValidOffsets]"/>
            </run_actions>
            <remove_value name="$ValidOffsets" comment="prevent accidental usage to select a different offset"/>
            <set_value name="$Page"         exact="$TextOffset_Table.keys.last"/>
            <set_value name="$TextOffset"   exact="$TextOffset_Table.{$Page}"/>

            <do_if value="$TextOffset == 2000">
              <include_actions ref="Setup_Production_MiningEquipment"/>
            </do_if>
            <do_elseif value="$TextOffset == 2100">
              <include_actions ref="Setup_Production_Explosives"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 2200">
              <include_actions ref="Setup_Production_Spices"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 2300">
              <include_actions ref="Setup_Production_WaterPurification"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 2400">
              <include_actions ref="Setup_Production_Herbices"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 2500">
              <include_actions ref="Setup_Production_MiningEquipment"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 2600">
              <include_actions ref="Setup_Production_Explosives"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 3000">
              <include_actions ref="Setup_ExquisiteFood"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 4000">
              <include_actions ref="Setup_Production_MiningEquipment"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 4100">
              <include_actions ref="Setup_ExquisiteFood"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 5000">
              <include_actions ref="Setup_Production_WaterPurification"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 5100">
              <include_actions ref="Setup_ExquisiteFood"/>
            </do_elseif>
            <do_elseif value="$TextOffset == 5200">
              <include_actions ref="Setup_Production_MiningEquipment"/>
            </do_elseif>

            <do_if value="$TargetStation and $DeliveryItem and $DeliveryAmount">
              <do_if value="not @$DeliveryRoomTags.count">
                <set_value name="$DeliveryRoomTags" exact="[tag.bar]"/>
              </do_if>
              <get_room_definition macro="$DeliveryRoomMacro" tags="$DeliveryRoomTags" race="$TargetStation.trueowner.primaryrace"/>

              <run_actions ref="md.LIB_Generic.DetermineCorridorForRoom" result="$CorridorDefinition">
                <param name="RoomMacro" value="$DeliveryRoomMacro"/>
                <param name="Race"      value="$TargetStation.trueowner.primaryrace"/>
              </run_actions>
              <set_value name="$DeliveryCorridorMacro" exact="$CorridorDefinition.{1}"/>
              <set_value name="$DeliveryDoors" exact="$CorridorDefinition.{2}"/>

              <do_if value="$DeliveryCorridorMacro and $DeliveryRoomMacro">
                <set_value name="$Valid" exact="true"/>
                <set_value name="$DeliveryInteriorName" exact="$DeliveryRoomMacro.name" />
                <run_actions ref="md.LIB_Generic.SectorDifficultyBalance" result="$Difficulty">
                  <param name="MissionTargetSector" value="$TargetStation.sector"/>
                  <param name="Difficulty" value="$Difficulty"/>
                </run_actions>
              </do_if>
              <do_if value="$DeliveryItem.isinventory">
                <set_value name="$OwnedAmount" exact="player.entity.inventory.{$DeliveryItem}.count"/>
              </do_if>
            </do_if>

            <do_if value="$Valid">
              <append_to_list name="GenerateGenericMission.$ValidVariants" exact="this"/>
            </do_if>
            <do_else>
              <cancel_cue cue="this"/>
            </do_else>
          </actions>
          <cues>
            <cue name="GenerateGenericMission_Variant_1_Trigger" version="2">
              <conditions>
                <event_cue_signalled cue="parent"/>
              </conditions>
              <actions>
                <get_character_definition reference="$CasualDefinition" faction="$Faction" tags="tag.casual"/>
                <do_any>
                  <set_value name="$ClientTag" exact="tag.crew" weight="10"/>
                  <set_value name="$ClientTag" exact="tag.casual" weight="if $CasualDefinition then 1 else 0"/>
                </do_any>
                <create_cue_actor cue="GenerateGenericMission_Variant_1_Trigger" name="$MissionActor">
                  <select faction="$Faction" tags="$ClientTag"/>
                  <owner exact="$Faction"/>
                </create_cue_actor>
                <remove_value name="$ClientTag"/>
                <remove_value name="$CasualDefinition"/>
                <set_entity_traits entity="$MissionActor" missionactor="true" customhandler="true"/>
                <set_entity_type entity="$MissionActor" type="entitytype.crowd"/>
              </actions>
              <patch sinceversion="2" state="complete">
                <set_value name="GenerateGenericMission_Variant_1_Ref.$PlaceNPC" exact="true"/>
                <set_value name="GenerateGenericMission_Variant_1_Ref.$PatchNPCPosition" exact="true"/>
              </patch>
              <cues>
                <cue name="GenerateGenericMission_Variant_1_Ref" ref="Start">
                  <param name="OfferObject"   value="$Station"/>
                  <param name="MissionLevel"  value="$MissionLevel"/>
                  <param name="Difficulty"    value="$Difficulty"/>

                  <!--Mission offer-->
                  <param name="RemoveOnSectorChange" value="@GenerateGenericMission.$RemoveOnSectorChange"/>
                  <param name="BBSSpace" value="$Sector"/>

                  <!--Mission text-->
                  <param name="Page"          value="$Page"/>
                  <param name="TextOffset"    value="$TextOffset"/>

                  <!--Mission specific params-->
                  <param name="DeliveryNPC"           value="$MissionActor" />
                  <param name="DeliveryStation"       value="$TargetStation" />
                  <param name="DeliveryItem"          value="$DeliveryItem" />
                  <param name="DeliveryAmount"        value="$DeliveryAmount" />
                  <param name="OwnedAmount"           value="$OwnedAmount"/>
                  <param name="PlaceNPC"              value="true"/>

                  <param name="DeliveryRoomMacro"     value="$DeliveryRoomMacro" />
                  <param name="DeliveryCorridorMacro" value="$DeliveryCorridorMacro" />
                  <param name="DeliveryDoors"         value="$DeliveryDoors" />
                  <param name="DeliveryInteriorName"  value="$DeliveryInteriorName" />

                  <param name="ReportSignalCue"     value="@GenerateGenericMission.$ReportSignalCue"/>
                  <param name="DebugChance"         value="@GenerateGenericMission.$DebugChance"/>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>
      </cues>
    </cue>

    <!--============
        ~~ MASTER EVALUATION LIBRARY ~~
        ================-->
    <library name="Dynamic_Mission_Eval" purpose="run_actions">
      <params>
        <param name="Label" default="'$defaultnext'"/>
        <param name="ChainDefinitionTable"/>
        <param name="OutcomeTable" default="table[$success = '$defaultnext']" comment="Table of outcomes. Key: GM $FeedbackValues ID or 'type' strings ($ prepended). Value: Label string to next dynamic mission section."/>
        <param name="DebugChance" default="0"/>

        <param name="ItemWareKey"/>
        <param name="AcceptOnItemObjectCollection" default="true" comment="Accept the mission when the player collects the item, otherwise active from the moment of spawning"/>

        <!--Parameters to create the dynamic interior which will hold the item.-->
        <param name="CreatedItemInteriorKey" default="null" comment="Key to save the created interior to."/>
        <param name="CreatedItemInteriorObjectKey" default="null" comment="Object to create the interior on"/>
        <param name="CreatedItemInteriorRoom" default="null" comment="Room macro or tag to generate a suitable room"/>
        <param name="CreatedItemInteriorCorridor" default="null" comment="Room macro or tag to generate the corridor"/>

        <!--Item creation and placement parameters-->
        <param name="ItemHolderKey" comment="Macro or component of class lockbox, crate or floating collectablewares container"/>
        <param name="ItemPlacementRule" default="null" comment="
               Lockbox/Collectablewares case:       Space position list: [$component, $offset(defaults to 0,0,0)]
               ---------
               Room crate case:                     Room crate slot OR,
                                                    room/walkablemodule/defensible/dynamicinterior component/key in which to find a crate slot OR,
                                                    list [room/walkablemodule/defensible/dynamicinterior component/key, roomtag] in which to find a crate slot.
                                                    note: If $CreatedItemInteriorKey was provided, the same key should be referenced"/>

        <!--Parameters to create the dynamic interior which will hold the delivery NPC.-->
        <param name="CreatedNPCInteriorKey" default="null" comment="Key to save the created interior to."/>
        <param name="CreatedNPCInteriorObjectKey" default="null" comment="Object to create the interior on"/>
        <param name="CreatedNPCInteriorRoom" default="null" comment="Room macro or tag to generate a suitable room"/>
        <param name="CreatedNPCInteriorCorridor" default="null" comment="Room macro or tag to generate the corridor"/>

        <!--Delivery NPC parameters-->
        <param name="DeliveryNPCKey" default="null" comment="Table key to client data. If the value evaluates to 'generating' then the NPC is set to be created before this mission spawns."/>
        <param name="DeliveryNPCPlacementRule" default="null" comment="
               Existing NPC case:                   null = do nothing. No other cases currently supported.
               ----------
               Other cases to place created NPC:    Room NPC slot OR,
                                                    room/walkablemodule/defensible/dynamicinterior component/key in which to find a NPC slot OR,
                                                    OR [room/walkablemodule/defensible/dynamicinterior component/key, roomtag]
                                                    note: If $CreatedItemInteriorKey was provided, the same key should be referenced"/>
      </params>
      <actions>
        <include_actions ref="md.GMC_Dynamic.Get_Branch_Sources"/>

        <do_for_each name="$BranchSource" in="$BranchSources">
          <set_value name="$ChainDefinitionTable.$ConstructingDefinitionRef" exact="$BranchSource"/>
          <set_value name="$MissionValTable" exact="$BranchSource.$MissionValTable"/>

          <!--====================
          ~~ Check item ware via $ItemWareKey ~~
          ========================-->
          <set_value name="$ItemWare" exact="@$MissionValTable.{$ItemWareKey}"/>
          <do_if value="not @$ItemWare.isinventory">
            <debug_text text="'Ware ' + $ItemWare + ' is not an inventory item'" filter="error"/>
            <return value="false"/>
          </do_if>

          <!--Validate $CreatedItemInteriorKey-->
          <do_if value="$CreatedItemInteriorKey">
            <!--<set_value name="$ThisDefinition.$Outcomes" exact="table[$valid = table[$Label = '$defaultnext', $Definition = table[$MissionValTable = $MissionValTable]]]"/>-->
            <!--<append_to_list name="$ChainDefinitionTable.$BranchRegister.{$Label}" exact="$TargetDefinition.$ParentSource"/>-->
            <run_actions ref="md.GMC_Dynamic.Generate_Interior_Creation_Helper" result="$Successful">
              <param name="ChainDefinitionTable"    value="$ChainDefinitionTable" comment="Will receive result table"/>
              <param name="IsInternalLibrary"       value="true"/>
              <param name="DebugChance"             value="$DebugChance"/>
              <param name="InteriorKey"             value="$CreatedItemInteriorKey"/>
              <param name="InteriorObjectKey"       value="$CreatedItemInteriorObjectKey"/>
              <param name="InteriorRoom"            value="$CreatedItemInteriorRoom"/>
              <param name="InteriorCorridor"        value="$CreatedItemInteriorCorridor"/>
            </run_actions>
            <do_if value="not $Successful">
              <debug_text text="'Failed to parse parameters to create interior for the item'" filter="error"/>
              <return value="false"/>
            </do_if>
          </do_if>

          <!--Validate $CreatedNPCInteriorKey-->
          <do_if value="$CreatedNPCInteriorKey">
            <!--<set_value name="$ThisDefinition.$Outcomes" exact="table[$valid = table[$Label = '$defaultnext', $Definition = table[$MissionValTable = $MissionValTable]]]"/>-->
            <!--<do_if value="not $ChainDefinitionTable.$BranchRegister.$defaultnext?">
              <set_value name="$ChainDefinitionTable.$BranchRegister.$defaultnext" exact="[]"/>
            </do_if>
            <append_to_list name="$ChainDefinitionTable.$BranchRegister.$defaultnext" exact="$ThisSource"/>-->
            <!--<assert value="$ChainDefinitionTable.$BranchRegister.$defaultnext.count == 1" text="'sfdaf'"/>-->
            <run_actions ref="md.GMC_Dynamic.Generate_Interior_Creation_Helper" result="$Successful">
              <param name="ChainDefinitionTable"    value="$ChainDefinitionTable" comment="Will receive result table"/>
              <param name="IsInternalLibrary"       value="true"/>
              <param name="DebugChance"             value="$DebugChance"/>
              <param name="InteriorKey"             value="$CreatedNPCInteriorKey"/>
              <param name="InteriorObjectKey"       value="$CreatedNPCInteriorObjectKey"/>
              <param name="InteriorRoom"            value="$CreatedNPCInteriorRoom"/>
              <param name="InteriorCorridor"        value="$CreatedNPCInteriorCorridor"/>
            </run_actions>
            <do_if value="not $Successful">
              <debug_text text="'Failed to parse parameters to create interior for the NPC'" filter="error"/>
              <return value="false"/>
            </do_if>
          </do_if>

          <!--====================
          ~~ Check item holder via $ItemHolderKey ~~
          ========================-->
          <set_value name="$ItemHolderType" exact="null"/>
          <set_value name="$ItemHolder" exact="$MissionValTable.{$ItemHolderKey}"/>
          <do_if value="$ItemHolder">
            <!--Place item in existing component-->
            <do_if value="typeof $ItemHolder == datatype.component">
              <do_if value="$ItemHolder.isclass.[class.lockbox, class.collectablewares]">
                <set_value name="$ItemHolderType" exact="'space collectable'"/>
                <do_if value="$CreatedItemInteriorKey">
                  <debug_text text="'Non-critical error. Interior for the item has been specified but the item holder is a floating object of class ' + $ItemHolder.class" filter="error"/>
                </do_if>
              </do_if>
              <do_elseif value="$ItemHolder.isclass.crate">
                <set_value name="$ItemHolderType" exact="'room crate'"/>
              </do_elseif>
              <do_else>
                <debug_text text="$ItemHolder + ' ' + $ItemHolder.knownname + ' is not a supported class to place the ware into'" filter="error"/>
                <return value="false"/>
              </do_else>
            </do_if>

            <do_elseif value="typeof $ItemHolder == datatype.macro">
              <do_if value="$ItemHolder.isclass.[class.lockbox, class.collectablewares]">
                <set_value name="$ItemHolderType" exact="'space collectable'"/>
                <do_if value="$CreatedItemInteriorKey">
                  <debug_text text="'Non-critical error. Interior for the item has been specified but the item holder is a floating object of class ' + $ItemHolder.class" filter="error"/>
                </do_if>
              </do_if>
              <do_elseif value="$ItemHolder.isclass.crate">
                <set_value name="$ItemHolderType" exact="'room crate'"/>
              </do_elseif>
              <do_else>
                <debug_text text="'Macro ' + $ItemHolder + ' is not supported class to place the ware into'" filter="error"/>
                <return value="false"/>
              </do_else>
            </do_elseif>

            <do_else>
              <debug_text text="'Unknown $ItemHolder case ' + $ItemHolder" filter="error"/>
              <return value="false"/>
            </do_else>

          </do_if>
          <do_else>
            <debug_text text="'Unable to retrieve item holder data from key ' + $ItemHolderKey" filter="error"/>
            <return value="false"/>
          </do_else>

          <!--====================
          ~~ Check item holder placement via $ItemPlacementRule ~~
          ========================-->
          <do_if value="$ItemPlacementRule">
            <do_if value="typeof $ItemHolder == datatype.component">
              <debug_text text="'Non-critical error. $ItemPlacementRule was provided for a component. Not supported, it will instead stay where it is. $ItemPlacementRule: ' + $ItemPlacementRule" filter="error"/>
            </do_if>
            <do_elseif value="$ItemHolderType == 'space collectable'">
              <!--Placing space collectables e.g. lockbox and collectablewares-->
              <do_if value="typeof $ItemPlacementRule == datatype.list and typeof $ItemPlacementRule.{2} == position and
                   (typeof $ItemPlacementRule.{1} == datatype.component or typeof $MissionValTable.{$ItemPlacementRule.{1}} == datatype.component)">
                <!--Valid-->
              </do_if>
              <do_else>
                <debug_text text="'$ItemPlacementRule is not a list of a component and position: ' + $ItemPlacementRule" filter="error"/>
                <return value="false"/>
              </do_else>
            </do_elseif>
            <do_elseif value="$ItemHolderType == 'room crate'">
              <!--Placing room crates-->
              <do_if value="typeof $ItemPlacementRule == datatype.componentslot">
                <do_if value="$CreatedItemInteriorKey">
                  <debug_text text="'Non-critical error. $ItemPlacementRule references component slot ' + $ItemPlacementRule + ' while a new interior was created for item placement.'" filter="error"/>
                </do_if>
              </do_if>
              <do_else>
                <do_if value="typeof $ItemPlacementRule == datatype.list">
                  <do_if value="typeof $ItemPlacementRule.{2} != datatype.tag">
                    <debug_text text="'$ItemPlacementRule second element should be a tag ' + $ItemPlacementRule" filter="error"/>
                    <return value="false"/>
                  </do_if>
                  <do_elseif value="typeof $ItemPlacementRule.{1} == datatype.component">
                    <set_value name="$PlacementObject" exact="$ItemPlacementRule.{1}"/>
                  </do_elseif>
                  <do_else>
                    <set_value name="$PlacementObject" exact="$MissionValTable.{$ItemPlacementRule.{1}}" comment="read as table key"/>
                  </do_else>
                </do_if>
                <do_elseif value="typeof $ItemPlacementRule == datatype.component">
                  <set_value name="$PlacementObject" exact="$ItemPlacementRule"/>
                </do_elseif>
                <do_else>
                  <set_value name="$PlacementObject" exact="$MissionValTable.{$ItemPlacementRule}" comment="read as table key"/>
                </do_else>
                <do_if value="$PlacementObject == 'generating'">
                  <!--Item placement object is to be generated. Assume it will be fine.-->
                </do_if>
                <do_elseif value="typeof $PlacementObject == datatype.component">
                  <do_if value="not $PlacementObject.isclass.[class.room, class.walkablemodule, class.defensible, class.navcontext]">
                    <debug_text text="'$ItemPlacementRule resolves to a component of an incompatible class ' + $PlacementObject + ' ' + $PlacementObject.knownname + ' ' + $PlacementObject.class" filter="error"/>
                    <return value="false"/>
                  </do_if>
                  <!--TODO @Owen find_crate_slot support for more classes such as defensible and dynamicinterior-->
                  <do_elseif value="$PlacementObject.isclass.[class.room, class.walkablemodule]">
                    <do_if value="typeof $ItemPlacementRule == datatype.list">
                      <find_crate_slot name="$CrateSlot" object="$PlacementObject" tags="$ItemPlacementRule.{2}"/>
                    </do_if>
                    <do_else>
                      <find_crate_slot name="$CrateSlot" object="$PlacementObject"/>
                    </do_else>
                    <!--TODO @Owen potential race condition if something else is finding free crate slots-->
                    <do_if value="not $CrateSlot">
                      <debug_text text="'$ItemPlacementRule component ' + $PlacementObject + ' ' + $PlacementObject.knownname + ' does not have a free crate slot'" chance="$DebugChance"/>
                      <return value="false"/>
                    </do_if>
                  </do_elseif>
                </do_elseif>
              </do_else>
            </do_elseif>
          </do_if>
          <do_elseif value="typeof $ItemHolder != datatype.component or not $ItemHolder.exists">
            <debug_text text="'$ItemPlacementRule is not defined and the $ItemHolder is not an existing component.'" filter="error"/>
          </do_elseif>

          <!--Check DeliveryNPC parameters-->
          <set_value name="$DeliveryNPC" exact="$MissionValTable.{$DeliveryNPCKey}"/>
          <do_if value="$DeliveryNPC">
            <do_if value="$DeliveryNPC == 'generating'">
              <debug_text text="'$DeliveryNPC is set to be generated'" chance="$DebugChance"/>
            </do_if>
            <do_elseif value="not @$DeliveryNPC.isclass.npc">
              <debug_text text="'$DeliveryNPC ' + $DeliveryNPC + ' is not set to be generated, nor is an existing NPC component'" filter="error"/>
              <return value="false"/>
            </do_elseif>
          </do_if>
          <do_else>
            <debug_text text="'Invalid $DeliveryNPC for key ' + $DeliveryNPCKey" filter="error"/>
            <return value="false"/>
          </do_else>

          <!--TODO @Owen validate $DeliveryNPCPlacementRule-->

          <!--Finalisation. Construct the mission instance param table.-->

          <!--Build the $Params table which will be passed to the instance so it can lookup the data from from $MissionValTable on spawning-->
          <set_value name="$ChainDefinitionTable.$ConstructingDefinitionRef.$StaticMissionCue"     exact="Item_Pickup_Start"/>
          <set_value name="$ChainDefinitionTable.$ConstructingDefinitionRef.$Params"               exact="table[
                                                                       $ItemWareKey = $ItemWareKey,
                                                                       $AcceptOnItemObjectCollection = $AcceptOnItemObjectCollection,
                                                                       $ItemHolderKey = $ItemHolderKey,
                                                                       $ItemPlacementRule = $ItemPlacementRule,
                                                                       $DeliveryNPCKey = $DeliveryNPCKey,
                                                                       $DeliveryNPCPlacementRule = $DeliveryNPCPlacementRule]"/>

          <include_actions ref="md.GMC_Dynamic.Set_Up_Outcome_Branches"/>
        </do_for_each>

        <return value="true"/>

      </actions>
    </library>

    <cue name="Item_Pickup_Start" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$Parameters" exact="event.param.$instanceparams"/>
        <set_value name="$MissionValTable" exact="event.param.$missionvaltable"/>
        <debug_text text="'$Parameters ' + $Parameters"/>
        <debug_text text="'$MissionValTable ' + $MissionValTable"/>

        <set_value name="$DeliveryNPC" exact="$MissionValTable.{$Parameters.$DeliveryNPCKey}"/>
        <set_value name="$Client" exact="$DeliveryNPC"/>
        <!--<get_room_definition macro="$DeliveryCorridorMacro" doors="$DeliveryDoors" race="$Client.owner.primaryrace" tags="tag.corridor" />
        <get_room_definition macro="$DeliveryRoomMacro" tags="tag.bar" />
        <set_value name="$DeliveryInteriorName" exact="readtext.{20007}.{1031}" />
        <find_station name="$DeliveryStation" space="player.sector"/>-->

        <do_if value="$Parameters.$DeliveryNPCPlacementRule">
          <!--TODO @Owen support other cases-->
          <do_if value="typeof $Parameters.$DeliveryNPCPlacementRule == datatype.list">
            <do_if value="typeof $Parameters.$DeliveryNPCPlacementRule.{1} == datatype.component">
              <set_value name="$NPCPlacementRuleObject" exact="$Parameters.$DeliveryNPCPlacementRule.{1}" comment="Already resolved to a component so use it."/>
            </do_if>
            <do_else>
              <set_value name="$NPCPlacementRuleObject" exact="$MissionValTable.{$Parameters.$DeliveryNPCPlacementRule.{1}}" comment="Attempt to resolve from the $MissionValTable."/>
            </do_else>
            <debug_text text="'$NPCPlacementRuleObject ' + $NPCPlacementRuleObject"/>
            <find_npc_slot name="$NPCSlot" object="$NPCPlacementRuleObject" tags="$Parameters.$DeliveryNPCPlacementRule.{2}"/>
            <do_if value="$NPCSlot">
              <add_actor_to_room actor="$DeliveryNPC" slot="$NPCSlot"/>
            </do_if>
            <do_else>
              <debug_text text="'Unable to find slot to place NPC. ' + $Parameters.$DeliveryNPCPlacementRule" filter="error"/>
            </do_else>
          </do_if>
        </do_if>

        <!--Parse the $ItemPlacementRule parameter so all keys are instead resolved to the value from the $MissionValTable-->
        <do_if value="typeof $Parameters.$ItemPlacementRule == datatype.list">
          <!--If a list the first element is the component. The second may be a position or tag, but that is already resolved.-->
          <do_if value="typeof $Parameters.$ItemPlacementRule.{1} == datatype.component">
            <set_value name="$ItemPlacementRuleObject" exact="$Parameters.$ItemPlacementRule.{1}" comment="Already resolved to a component so use it."/>
          </do_if>
          <do_else>
            <set_value name="$ItemPlacementRuleObject" exact="$MissionValTable.{$Parameters.$ItemPlacementRule.{1}}" comment="Attempt to resolve from the $MissionValTable."/>
          </do_else>
          <set_value name="$ItemHolderPlacementDef" exact="[$ItemPlacementRuleObject, $Parameters.$ItemPlacementRule.{2}]"/>
        </do_if>
        <do_elseif value="typeof $Parameters.$ItemPlacementRule == datatype.component">
          <set_value name="$ItemHolderPlacementDef" exact="$Parameters.$ItemPlacementRule"/>
        </do_elseif>
        <do_else>
          <set_value name="$ItemHolderPlacementDef" exact="$MissionValTable.{$Parameters.$ItemPlacementRule}"/>
        </do_else>
      </actions>
      <cues>
        <cue name="Item_Pickup_GM_Ref" ref="md.GM_BringItems.Start">
          <param name="Client" value="$Client"/>
          <param name="MissionCue" value="$MissionValTable.$ChainInstance"/>

          <!--TODO @Owen-->
          <param name="MissionLevel" value="1"/>
          <param name="Difficulty" value="level.veryeasy"/>

          <!--Offer location and conversation-->
          <param name="WithoutOffer" value="true"/>
          <param name="AcceptOnItemObjectCollection" value="$Parameters.$AcceptOnItemObjectCollection"/>

          <!--Mission text TODO @Owen-->
          <param name="Page"      value="30135"/>
          <param name="TextOffset" value="4000"/>

          <!--Mission specific params-->
          <param name="DeliveryNPC"         value="$MissionValTable.{$Parameters.$DeliveryNPCKey}"/>
          <param name="DeliveryStation"     value="$DeliveryNPC.object" />
          <param name="DeliveryItem"        value="$MissionValTable.{$Parameters.$ItemWareKey}" />

          <param name="ItemHolder"          value="$MissionValTable.{$Parameters.$ItemHolderKey}"/>
          <param name="HolderPlacementDef"  value="$ItemHolderPlacementDef"/>

          <param name="PlaceNPC"            value="false" />

          <param name="ReportSignalCue" value="$MissionValTable.$ChainMissionReportCue"/>
          <param name="CancelOfferCue" value="null"/>
          <param name="ForceCleanup" value="null"/>
          <param name="DebugChance" value="100"/>
        </cue>
      </cues>
    </cue>

  </cues>
</mdscript>
