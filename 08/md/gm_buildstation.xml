<?xml version="1.0" encoding="utf-8"?>
<mdscript name="GM_BuildStation" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">
  <cues>

    <!--Base Mission information-->
    <!--
      Generic Mission name:    Build specified station - intended for Master Missions
      Primary 'missiontype':   missiontype.deliver
      Page: 30120 + war subscription
      Notes:
      - This GM offers a mission to build a station according to specifications $StationSpecs, which on completion can be transferred to the requesting faction.
      - When passing in $builtclasses (=ship classes to be built), you can specify what ships this station should be able to build. When asking for S/M ships, be sure to either ask 
        for only S, only M, or the exact same amount of S/M. Since you can construct only S/M Fabs, asking for a different amount of S and M would be very confusing for players.
    -->

    <!-- Variant Table -->
    <cue name="TextOffsets" namespace="this">
      <actions>
        <set_value name="$Cue" exact="md.GM_BuildStation.GenerateGenericMission"/>
        <append_to_list name="md.GenericMissions.Manager.$StaticGMCues" exact="$Cue" create="true" unique="true"/>
        <set_value name="$Cue.$TextOffsets" exact="table[]" comment="$Cue.$TextOffsets.{$Page}.{$TextOffset}"/>
        <set_value name="$Cue.$TextOffsets.{30120}"
                   exact="table[ {1000} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {1100} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {1500} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {1600} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {1700} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2000} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2100} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2200} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2300} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2400} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {2500} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {3000} = table[$lastoffertime = 0s, $offercounter = 0],
                                 {3100} = table[$lastoffertime = 0s, $offercounter = 0]]"/>
      </actions>
    </cue>

    <!--
      The Feedback Manager contains a table of feedback values related to this Generic Mission. 
		  This table is 'const' during the mission (the table itself doesn't change anymore after inialization)
	    There are several maintypes of feedback:
        event:    Something which happens during a mission but does not cause it to end e.g. the mission being accepted
        removed:  The mission offer was removed before acceptance
        success:  The mission was successfully completed by the player
        failure:  The player failed the mission
        error:    Something went wrong with the mission set-up or during the mission
    -->
    <cue name="FeedbackValueManager" namespace="this" version="3">
      <actions>
        <set_value name="$FeedbackValues" exact="table[
                   $MISSION_GENERATED           = table[$type = 'event',    $text = 'Mission variation generated successfully'],
                   $MISSION_ACCEPTED            = table[$type = 'event',    $text = 'Mission accepted'],
                   $MISSION_NO_VARIANT          = table[$type = 'event',    $text = 'No mission variant currently possible'],
                   
                   $OFFER_REMOVED               = table[$type = 'removed',  $text = 'Offer removed'],
                   $DECLINED_OFFER              = table[$type = 'removed',  $text = 'Player declined Event Offer'],
                   $EVENT_OFFER_TIMEOUT         = table[$type = 'removed',  $text = 'Event Offer timeout'],
                   $SIGNAL_LEAK_REMOVED         = table[$type = 'removed',  $text = 'Signal leak offer removed'],
                   
                   $MISSION_SUCCEEDED           = table[$type = 'success',  $text = 'Mission succeeded'],
                   
                   $MISSION_ABORTED             = table[$type = 'failure',  $text = 'Mission aborted by player'],
                   $FORCED_CLEANUP              = table[$type = 'failure',  $text = 'Forced to end from outside'],
                   $MISSION_TIMEOUT             = table[$type = 'failure',  $text = 'Mission timeout'],
                   $BUILD_RML_FAILED            = table[$type = 'failure',  $text = 'RML_BuildStation failed'],
                   
                   $NO_VALID_CLIENT_OWNER       = table[$type = 'error',    $text = 'No valid ClientOwner parameter provided'],
                   $INVALID_OFFER_TYPE          = table[$type = 'error',    $text = 'No offer parameters were valid'],
                   $NO_TEXT_OFFSET              = table[$type = 'error',    $text = 'No TextOffset set'],
                   $INVALID_LOCATION_PARAM      = table[$type = 'error',    $text = 'Invalid StationLocation param'],
                   $INVALID_PLOTSIZE_PARAM      = table[$type = 'error',    $text = 'Invalid Plotsize param'],
                   $INVALID_STATIONSPECS_PARAM  = table[$type = 'error',    $text = 'Invalid StationSpecs param'],
                   $INVALID_FACTION_PARAM       = table[$type = 'error',    $text = 'Invalid Faction param'],
                   $INVALID_FORCE_CLEANUP       = table[$type = 'error',    $text = 'ForceCleanup cue invalid'],
                   $OFFERED_RECENTLY            = table[$type = 'error',    $text = 'Factory build mission offered recently']
                   ]"/>
      </actions>
      <patch sinceversion="3">
        <!--To patch new feedback values, increment 'version' and 'sinceversion' number-->
        <force_cue cue="FeedbackValueManager"/>
      </patch>
    </cue>

    <!--Required variables: $Page & $TextOffset (and any below substitute_text values)
    If text is to be substituted for a new text variant, people should feel free to add the substitution below. Alternatively, pass in an overriding text in the $TextTable param-->
    <library name="GenerateTextTable">
      <actions>
        <!-- Register unknown TextOffsets to the TextOffsets table -->
        <run_actions ref="md.GenericMissions.RegisterMissionVariant">
          <param name="StaticGMCue" value="md.GM_BuildStation.GenerateGenericMission"/>
          <param name="Page"        value="$Page"/>
          <param name="TextOffset"  value="$TextOffset"/>
        </run_actions>

        <!--Text page indexes $TextOffset + #
        1 = $TextTable.$missionname
        2 = $TextTable.$description
        3 = $TextTable.$objective1 (deprecated)
        4 = $TextTable.$objective2
        5 = $TextTable.$objective3
        6 = $TextTable.$objective4 (deprecated)
        -->
        <set_value name="$TextTable.$missionname" exact="readtext.{$Page}.{$TextOffset + 1}" chance="if $TextTable.$missionname? then 0 else 100"/>
        <!--set_value name="$TextTable.$description" exact="readtext.{$Page}.{$TextOffset + 2}" chance="if $TextTable.$description? then 0 else 100"/-->
        <!--<set_value name="$TextTable.$objective1"   exact="readtext.{$Page}.{$TextOffset + 3}" chance="if $TextTable.$objective1? then 0 else 100"/>-->
        <set_value name="$TextTable.$objective2"   exact="readtext.{$Page}.{$TextOffset + 4}" chance="if $TextTable.$objective2? then 0 else 100"/>
        <set_value name="$TextTable.$objective3"   exact="readtext.{$Page}.{$TextOffset + 5}" chance="if $TextTable.$objective3? then 0 else 100"/>
        <!--set_value name="$TextTable.$objective4"   exact="readtext.{$Page}.{$TextOffset + 6}" chance="if $TextTable.$objective4? then 0 else 100"/-->

        <run_actions ref="ConstructRequirementsText" result="$RequirementsText">
          <param name="PlotSector"              value="$PlotSector" />
          <param name="PlotSize"                value="$PlotSize" />
          <param name="StationSpecs"            value="$StationSpecs" />
          <param name="DestinationDBString"     value="readtext.{$Page}.{$TextOffset + 7}" />
        </run_actions>

        <set_value name="$TextTable.$description" exact="readtext.{$Page}.{$TextOffset + 2}" chance="if $TextTable.$description? then 0 else 100"/>
        <set_value name="$TextTable.$description" exact="$TextTable.$description + '\n\n' + $RequirementsText"/>

        <!-- Add the estimated minimum cost of the build -->
        <set_value name="$TextTable.$description" exact="$TextTable.$description + '\n\n' + {30120,302} + {1001,120} + ' ' + $ResourceCost__Result.formatted.default + ' ' + {1001,101}"/>

        <do_if value="$DefenceStation">
          <set_value name="$TextTable.$description" exact="$TextTable.$description + '\n\n' + {30120, 300}"/>
        </do_if>

        <set_value name="$TextTable.$description" exact="$TextTable.$description + '\n\n' + {30120, 301}" comment="Reward multiplier explanation"/>

        <run_actions ref="md.LIB_Generic.GenerateTextTable_BriefingWarning_Call" result="$TextTable.$description">
          <param name="BriefingText" value="$TextTable.$description"/>
          <param name="TargetSpace" value="$PlotSector"/>
        </run_actions>

      </actions>
    </library>

    <!--Text Construction moved to seperate libraries to allow precise text generation for plot purposes-->
    <library name="ConstructRequirementsText" purpose="run_actions">
      <params>
        <param name="PlotSector"/>
        <param name="PlotSize"/>
        <param name="StationSpecs"/>
        <param name="DestinationDBString"/>
      </params>
      <actions>

        <run_actions ref="GeneratePlotSizeText" result="$PlotSizeText">
          <param name="PlotSize" value="$PlotSize"/>
        </run_actions>

        <run_actions ref="GenerateDestinationString" result="$DestinationString">
          <param name="PlotSector"          value="$PlotSector"/>
          <param name="DestinationDBString" value="$DestinationDBString" />
        </run_actions>

        <run_actions ref="GenerateConstructsText" result="$ConstructsText">
          <param name="StationSpecs" value="$StationSpecs"/>
        </run_actions>

        <run_actions ref="GenerateProductionsText" result="$ProductionsText">
          <param name="StationSpecs" value="$StationSpecs"/>
        </run_actions>

        <run_actions ref="GenerateBuiltClassesText" result="$BuiltClassesText">
          <param name="StationSpecs" value="$StationSpecs"/>
        </run_actions>

        <run_actions ref="GenerateStorageText" result="$StorageText">
          <param name="StationSpecs" value="$StationSpecs"/>
        </run_actions>

        <run_actions ref="AssembleRequirementsText" result="$RequirementsText">
          <param name="ConstructsText"    value="$ConstructsText"/>
          <param name="ProductionsText"   value="$ProductionsText"/>
          <param name="BuiltClassesText"  value="$BuiltClassesText"/>
          <param name="StorageText"       value="$StorageText"/>
          <param name="PlotSizeText"      value="$PlotSizeText"/>
          <param name="DestinationString" value="$DestinationString"/>
        </run_actions>

        <return value="$RequirementsText"/>
      </actions>
    </library>

    <library name="GeneratePlotSizeText" purpose="run_actions">
      <params>
        <param name="PlotSize"/>
      </params>
      <actions>
        <set_value name="$PlotSizeText" exact="''"/>

        <do_if value="($PlotSize.x gt 1km) or ($PlotSize.y gt 1km) or ($PlotSize.z gt 1km)" comment="don't show, if default/minimum plot-size (1x1x1km)">
          <substitute_text text="$PlotSizeText" source="{30004, 2010}" comment="Minimum plot size: $X$ x $Y$ x $Z$ km">
            <replace string="'$X$'"     with="$PlotSize.x / 1000.0"/>
            <replace string="'$Y$'"     with="$PlotSize.y / 1000.0"/>
            <replace string="'$Z$'"     with="$PlotSize.z / 1000.0"/>
          </substitute_text>
        </do_if>
        <return value="$PlotSizeText"/>
      </actions>
    </library>

    <library name="GenerateDestinationString" purpose="run_actions">
      <params>
        <param name="PlotSector"/>
        <param name="DestinationDBString"/>
      </params>
      <actions>
        <substitute_text text="$DestinationString" source="$DestinationDBString">
          <replace string="'$DESTINATION$'"     with="$PlotSector.knownname"/>
        </substitute_text>
        <return value="$DestinationString"/>
      </actions>
    </library>

    <library name="GenerateConstructsText" purpose="run_actions">
      <params>
        <param name="StationSpecs"/>
      </params>
      <actions>
        <set_value name="$ConstructsText" exact="null" comment="Required constructs:"/>

        <set_value name="this.$UsedNames" exact="[]"/>
        <do_if value="$StationSpecs.$containedmacros? and $StationSpecs.$containedmacros.count">
          <do_all exact="$StationSpecs.$containedmacros.count" counter="$gtt_i">
            <set_value name="this.$MacroDef" exact="$StationSpecs.$containedmacros.{$gtt_i}"/>
            <do_if value="this.$MacroDef.{1} gt 0" comment="Check that the definition wants a positive amount">
              <assert value="typeof this.$MacroDef.{2} == datatype.macro" text="'Invalid macro definition. ' + this.$MacroDef.{2} + ' is not a macro.'"/>
              <do_if value="typeof this.$MacroDef.{2} == datatype.macro">
                <do_if value="$ConstructsText">
                  <set_value name="$ConstructsText" exact="$ConstructsText + ','"/>
                </do_if>
                <do_else>
                  <set_value name="$ConstructsText" exact="{30004, 2001}"/>
                </do_else>
                <set_value name="$ConstructsText" exact="$ConstructsText + ' ' + this.$MacroDef.{1} + ' x ' + this.$MacroDef.{2}.name"/>
                <assert value="not this.$UsedNames.indexof.{this.$MacroDef.{2}.name}" text="'A macro with name ' + this.$MacroDef.{2}.name + ' was already used as a build specification for this mission. Avoid specifiying macros which share names. [Owen]'"/>
                <append_to_list name="this.$UsedNames" exact="this.$MacroDef.{2}.name"/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>

        <do_if value="$StationSpecs.$containedclasses? and $StationSpecs.$containedclasses.count">
          <do_all exact="$StationSpecs.$containedclasses.count" counter="$gtt_i">
            <set_value name="this.$ClassDef" exact="$StationSpecs.$containedclasses.{$gtt_i}"/>
            <do_if value="this.$ClassDef.{1} gt 0" comment="Check that the definition wants a positive amount">
              <assert value="typeof this.$ClassDef.{2} == datatype.class" text="'Invalid class definition. ' + this.$ClassDef.{2} + ' is not a class.'"/>
              <do_if value="typeof this.$ClassDef.{2} == datatype.class">
                <do_if value="$ConstructsText">
                  <set_value name="$ConstructsText" exact="$ConstructsText + ','"/>
                </do_if>
                <do_else>
                  <set_value name="$ConstructsText" exact="{30004, 2001}"/>
                </do_else>
                <do_if value="this.$ClassDef.{1} == 1">
                  <!--Singular-->
                  <set_value name="$ConstructsText" exact="$ConstructsText + ' ' + this.$ClassDef.{1} + ' x ' + this.$ClassDef.{3}"/>
                </do_if>
                <do_else>
                  <!--Multiple-->
                  <set_value name="$ConstructsText" exact="$ConstructsText + ' ' + this.$ClassDef.{1} + ' x ' + this.$ClassDef.{4}"/>
                </do_else>
              </do_if>
            </do_if>
          </do_all>
        </do_if>

        <return value="$ConstructsText"/>
      </actions>
    </library>

    <library name="GenerateProductionsText" purpose="run_actions">
      <params>
        <param name="StationSpecs"/>
      </params>
      <actions>
        <set_value name="$ProductionsText" exact="null" comment="Productions:"/>

        <do_if value="$StationSpecs.$products? and $StationSpecs.$products.count">
          <do_all exact="$StationSpecs.$products.count" counter="$gtt_i">
            <set_value name="this.$ProductDef" exact="$StationSpecs.$products.{$gtt_i}"/>
            <do_if value="this.$ProductDef.{1} gt 0" comment="Check that the definition wants a positive amount">
              <assert value="typeof this.$ProductDef.{2} == datatype.ware" text="'Invalid product definition. ' + this.$ProductDef.{2} + ' is not a ware.'"/>
              <do_if value="typeof this.$ProductDef.{2} == datatype.ware">
                <do_if value="$ProductionsText">
                  <set_value name="$ProductionsText" exact="$ProductionsText + ','"/>
                </do_if>
                <do_else>
                  <set_value name="$ProductionsText" exact="{30004, 2002}"/>
                </do_else>
                <set_value name="$ProductionsText" exact="$ProductionsText + ' ' + this.$ProductDef.{1} + ' x ' + this.$ProductDef.{2}.name"/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        <return value="$ProductionsText"/>
      </actions>
    </library>

    <library name="GenerateBuiltClassesText" purpose="run_actions">
      <params>
        <param name="StationSpecs"/>
      </params>
      <actions>
        <set_value name="$BuiltClassesText" exact="null"/>

        <do_if value="$StationSpecs.$builtclasses? and $StationSpecs.$builtclasses.count">
          <do_all exact="$StationSpecs.$builtclasses.count" counter="$gtt_i">
            <set_value name="this.$ProductDef" exact="$StationSpecs.$builtclasses.{$gtt_i}"/>
            <do_if value="this.$ProductDef.{1} gt 0" comment="Check that the definition wants a positive amount">
              <assert value="typeof this.$ProductDef.{2} == datatype.class" text="'Invalid product definition. ' + this.$ProductDef.{2} + ' is not a class.'"/>
              <do_if value="typeof this.$ProductDef.{2} == datatype.class">
                <do_if value="$BuiltClassesText">
                  <set_value name="$BuiltClassesText" exact="$BuiltClassesText + ','"/>
                </do_if>
                <do_else>
                  <set_value name="$BuiltClassesText" exact="{30004, 2006}" comment="Capacity for Ship Production:"/>
                </do_else>
                <do_if value="this.$ProductDef.{2} == class.ship_xs">
                  <set_value name="$BuiltClassesText" exact="$BuiltClassesText + ' ' + this.$ProductDef.{1} + ' x ' + {1001,52}"/>
                </do_if>
                <do_elseif value="this.$ProductDef.{2} == class.ship_s">
                  <set_value name="$BuiltClassesText" exact="$BuiltClassesText + ' ' + this.$ProductDef.{1} + ' x ' + {1001,51}"/>
                </do_elseif>
                <do_elseif value="this.$ProductDef.{2} == class.ship_m">
                  <set_value name="$BuiltClassesText" exact="$BuiltClassesText + ' ' + this.$ProductDef.{1} + ' x ' + {1001,50}"/>
                </do_elseif>
                <do_elseif value="this.$ProductDef.{2} == class.ship_l">
                  <set_value name="$BuiltClassesText" exact="$BuiltClassesText + ' ' + this.$ProductDef.{1} + ' x ' + {1001,49}"/>
                </do_elseif>
                <do_elseif value="this.$ProductDef.{2} == class.ship_xl">
                  <set_value name="$BuiltClassesText" exact="$BuiltClassesText + ' ' + this.$ProductDef.{1} + ' x ' + {1001,48}"/>
                </do_elseif>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        <return value="$BuiltClassesText"/>
      </actions>
    </library>

    <library name="GenerateStorageText" purpose="run_actions">
      <params>
        <param name="StationSpecs"/>
      </params>
      <actions>
        <set_value name="$StorageText" exact="null"/>

        <do_if value="$StationSpecs.$solidstorage? and (typeof $StationSpecs.$solidstorage).isnumeric and $StationSpecs.$solidstorage gt 0">
          <set_value name="$StorageText" exact="{30004, 2003} + ' ' + $StationSpecs.$solidstorage"/>
        </do_if>

        <do_if value="$StationSpecs.$containerstorage? and (typeof $StationSpecs.$containerstorage).isnumeric and $StationSpecs.$containerstorage gt 0">
          <do_if value="$StorageText">
            <set_value name="$StorageText" exact="$StorageText + '\n'"/>
          </do_if>
          <do_else>
            <set_value name="$StorageText" exact="''"/>
          </do_else>
          <set_value name="$StorageText" exact="$StorageText + {30004, 2004} + ' ' + $StationSpecs.$containerstorage"/>
        </do_if>

        <do_if value="$StationSpecs.$liquidstorage? and (typeof $StationSpecs.$liquidstorage).isnumeric and $StationSpecs.$liquidstorage gt 0">
          <do_if value="$StorageText">
            <set_value name="$StorageText" exact="$StorageText + '\n'"/>
          </do_if>
          <do_else>
            <set_value name="$StorageText" exact="''"/>
          </do_else>
          <set_value name="$StorageText" exact="$StorageText + {30004, 2005} + ' ' + $StationSpecs.$liquidstorage"/>
        </do_if>
        <return value="$StorageText"/>
      </actions>
    </library>

    <library name="AssembleRequirementsText" purpose="run_actions">
      <params>
        <param name="ConstructsText"  default="null"/>
        <param name="ProductionsText" default="null"/>
        <param name="BuiltClassesText" default="null"/>
        <param name="StorageText"     default="null"/>
        <param name="PlotSizeText"    />
        <param name="DestinationString"/>
      </params>
      <actions>
        <set_value name="$RequirementsText" exact="$DestinationString + '\n' + $PlotSizeText"/>

        <do_if value="$ConstructsText">
          <set_value name="$RequirementsText" exact="$RequirementsText + '\n' + $ConstructsText"/>
        </do_if>

        <do_if value="$ProductionsText">
          <do_if value="$RequirementsText">
            <set_value name="$RequirementsText" exact="$RequirementsText + '\n'"/>
          </do_if>
          <do_else>
            <set_value name="$RequirementsText" exact="''"/>
          </do_else>
          <set_value name="$RequirementsText" exact="$RequirementsText + $ProductionsText"/>
        </do_if>

        <do_if value="$BuiltClassesText">
          <do_if value="$RequirementsText">
            <set_value name="$RequirementsText" exact="$RequirementsText + '\n'"/>
          </do_if>
          <do_else>
            <set_value name="$RequirementsText" exact="''"/>
          </do_else>
          <set_value name="$RequirementsText" exact="$RequirementsText + $BuiltClassesText"/>
        </do_if>

        <do_if value="$StorageText">
          <do_if value="$RequirementsText">
            <set_value name="$RequirementsText" exact="$RequirementsText + '\n'"/>
          </do_if>
          <do_else>
            <set_value name="$RequirementsText" exact="''"/>
          </do_else>
          <set_value name="$RequirementsText" exact="$RequirementsText + $StorageText"/>
        </do_if>
        <return value="$RequirementsText"/>
      </actions>
    </library>

    <library name="GenerateRewardMultiplierText" purpose="run_actions">
      <params>
        <param name="RewardMultiplier"/>
        <param name="RewardCapMultiplier"/>
        <param name="RewardCapCr"/>
      </params>
      <actions>
        <substitute_text text="$RewardMultiplierText" source="{30120,400}">
          <replace string="'$PERCENT$'" with="($RewardMultiplier - 1) * 100"/>
          <replace string="'$CREDITS$'"  with="$RewardCapCr.formatted.default"/>
        </substitute_text>

        <return value="$RewardMultiplierText"/>
      </actions>
    </library>

    <library name="GenerateVoiceTable">
      <actions>
        <run_actions ref="md.LIB_Generic.GenerateGenericVoiceTable" result="$VoiceTable">
          <param name="VoiceTable" value="$VoiceTable"/>
        </run_actions>
      </actions>
    </library>

    <library name="Start" version="5">
      <params>
        <!-- Generic Parameters -->
        <param name="OfferObject" default="null" comment="The object on which this mission is based e.g. A Ship / Station / Signal Leak. Only needed for missions with a physical location."/>
        <param name="Client" default="null" comment="Pre-existing client"/>
        <param name="ClientOwner" default="null" comment="Overriding owner for reward calculation or creation of $Client if not provided. Defaults to $OfferObject owner if able"/>
        <param name="MissionCue" default="null" comment="Cue the mission is attached to. Defaults to Start (this)."/>
        <param name="MissionThread" default="null" comment="Mission thread for the offer and mission"/>

        <param name="GenerateReward" default="true" comment="If RewardCr or RewardNotoriety are invalid, generate them?"/>
        <param name="RewardCr" default="null" comment="If the reward for this mission is credits, the number of credits should be set to this variable." />
        <param name="RewardObj" default="null" comment="If the reward for this mission is not credits, and is an object, it should be set to this variable." />
        <param name="RewardNotoriety" default="null"/>
        <param name="RewardText" default="null"  comment="Any text needed to define the reward for this mission - may be used in conjunction with $RewardCr and $RewardObj." />
        <param name="MissionDuration" default="null"/>
        <param name="MissionType" default="missiontype.build" comment="Variations can override mission type if required"/>
        <param name="MissionLevel"/>
        <param name="Difficulty"/>

        <!--Offer location and conversation-->
        <param name="WithoutOffer" default="false" comment="Do not create a mission offer. Either run immediatly or wait for WithoutOfferWaitCue"/>
        <param name="WithoutOfferWaitCue" default="null" comment="Do not create a mission offer but wait for this cue to be completed before running the mission"/>
        <param name="DeclineButton" default="true" comment="Have a decline button instead of a back button in the offer conversation"/>
        <param name="EventOffer" default="false" comment="Is the mission offered directly to the player with an interactive event"/>
        <param name="ConversationOffer" default="false" comment="When $EventOffer is false, should this offer be through a conversation with the $Client. Otherwise, offer at mission location"/>
        <param name="ConversationTriggerCue" default="null" comment="If provided, when this cue is signalled, start the mission offer conversation."/>
        <param name="OfferMaxDistance" default="null"/>
        <param name="HideFromBBS" default="false" comment="Hide this offer from the BBS? Show only through locations or special conversation handling."/>
        <param name="RemoveOnSectorChange" default="true"/>
        <param name="OfferDistance" default="50km" comment="Distance to the offer location before it becomes visible on the map or BBS (unless otherwise hidden)"/>

        <!--BBS only params-->
        <param name="BBSObject" default="null"/>
        <param name="BBSDistance" default="null"/>
        <param name="BBSTimeoutMin" default="null"/>
        <param name="BBSTimeoutMax" default="null"/>
        <param name="BBSSpace"      default="null"/>

        <!--Mission text-->
        <param name="Page"        comment="Allows a different text page to be used instead of the generic one. Text IDs must be mapped similarly."/>
        <param name="TextOffset"  comment="The text offset for this variant's text on the page.
               Each variant starts at a different offset, but the entries[] within that offset have to match for all variants."/>
        <param name="TextTable" default="table[]" comment="Table, usually populated by the mission, to store the texts by an identifier key e.g. $missionname = 'Kill Bala Gi'
               Check library 'GenerateTextTable' for identifier keys. Pass in a table with such an entry to override the text usually generated from the $Page and $TextOffset"/>
        <param name="VoiceTable" default="table[]" comment="Table, usually populated by the mission, keys can have a value of 0 (=stay silent)"/>

        <!-- Optional mission setup overrides -->
        <param name="PlotSector"                                        comment="Where to claim the plot"/>
        <param name="PlotOffset"                                        comment="Where to claim the plot"/>
        <param name="PlotRange"       default="10km"                    comment="How far away from PlotLocation do we accept"/>
        <param name="PlotSize"        default="vector.[4km, 4km, 4km]"  comment="How large should the plot be in x/y/z ("/>
        <param name="Faction"                                           comment="The faction which asked us to build a station"/>
        <param name="DefenceStation"  default="false"                   comment="Additional briefing text related to requiring an administrative module, in case of a station intended for claiming space."/>
        <param name="StationSpecs"                                      comment="Table containing the specifications of the station:"/>
        <param name="RewardMultiplier"    default="1.5"                 comment="Actual station value gets multiplied by this after the transfer"/>
        <param name="RewardCapMultiplier" default="2"                   comment="Predicted station value gets multiplied by this to create the reward cap"/>
        <!--StationSpecs table: Contains lists of specifications under keys:
        $products = [ [wantedamount, productware] ]
        $containedmacros = [ [wantedamount, containedmacro] ]
        $containedclasses = [ [wantedamount, containedclass, singuartext, pluraltext] ]
        $solidstorage = <int>
        $containerstorage = <int>
        $liquidstorage = <int>
        
        e.g. table[ $products = [[2, ware.energycells], [1, ware.foodrations]], $containedmacros = [[1, macro.storage_tel_m_container_01_macro], [2, macro.storage_arg_m_container_01_macro]], $containedclasses = [[5, class.turret, 'Turret', 'Turrets']], $containerstorage = 123 ]
        ***WARNING***
        When specifying $containedmacros, do not use macros which may share names with other macros e.g. Solid Storage M. In general, $containedmacros should only be used for very specific situations-->

        <!--Result variables-->
        <param name="ResultTable" default="null" comment="Result keys:
               $BuiltStation = (component) The built station"/>

        <param name="ReportSignalCue" default="null" comment="Cue to be signalled when something happens which could be of interest to the calling cue. Saves values to ReportSignalCue.$FeedbackValue and ReportSignalCue.$EndFeedbackValue"/>
        <param name="CancelOfferCue" default="null" comment="Cue which when completed will force this missions offer to be removed and cleaned up. No effect if mission has been accepted."/>
        <param name="ForceCleanup" default="null" comment="Cue to force a cleanup from outside when completed"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <!--Feedback value setup-->
        <set_value name="$Feedback" exact="null"/>
        <set_value name="$FeedbackManager" exact="md.GM_BuildStation.FeedbackValueManager"/>

        <assert value="$WithoutOffer or not $MissionCue or (not $MissionCue.hasmission and not $MissionCue.hasmissionoffer)"
                text="'Mission is set to create an offer but provided MissionCue: ' + $MissionCue + ' already has an offer or is a running mission [Owen]'"/>

        <!--Param validation-->
        <do_if value="not $WithoutOffer">
          <!--Optional variables (at least one should exist): $OfferObject, (bool)$HideFromBBS, (bool)$ConversationOffer, (bool)$EventOffer
          Result variables:
          $OfferType = 'signalleak' OR 'objectbased' OR 'eventoffer' OR 'conversationoffer'
          $AllowOfferEvent = Will an event offering this event be also fired immediatly?-->
          <include_actions ref="md.GenericMissions.GetOfferType"/>
          <do_if value="not $OfferType">
            <set_value name="$Feedback" exact="'$INVALID_OFFER_TYPE'"/>
          </do_if>
        </do_if>

        <do_if value="@$StationSpecs.$products.count">
          <do_for_each name="$WareData" in="$StationSpecs.$products" comment="there should only always be one ware, but anticipate future">
            <run_actions ref="GetIsOkToOfferMission" result="$IsOkToOffer">
              <param name="Faction" value="$Faction" />
              <param name="Sector" value="$PlotSector" />
              <param name="Ware" value="$WareData.{2}" comment="[number, ware]" />
            </run_actions>
            <do_if value="not $IsOkToOffer">
              <set_value name="$Feedback" exact="'$OFFERED_RECENTLY'" />
              <break />
            </do_if>
          </do_for_each>
        </do_if>

        <do_if value="$DefenceStation and not $Faction.willclaimspace">
          <!-- faction like scaleplate don't claim space, so it's very unusual if they'd request a defense-station which also claims space. -->
          <assert value="false" text="'Requesting defense station for faction which does not claim space?!'"/>
        </do_if>

        <do_if value="not $Feedback">
          <do_if value="not $TextOffset">
            <set_value name="$Feedback" exact="'$NO_TEXT_OFFSET'"/>
          </do_if>
          <do_else>
            <do_if value="$Client">
              <set_value name="$PreexistingClient"/>
            </do_if>
            <do_if value="not $ClientOwner">
              <set_value name="$ClientOwner" exact="if $Client then $Client.owner else @$OfferObject.owner"/>
              <assert value="$ClientOwner" text="'No valid $ClientOwner [Owen]'"/>
            </do_if>

            <do_if value="not $ClientOwner">
              <set_value name="$Feedback" exact="'$NO_VALID_CLIENT_OWNER'"/>
            </do_if>
            <do_else>
              <!--Mission specific param checks-->
              <do_if value="not $PlotSector.isclass.space">
                <set_value name="$Feedback" exact="'$INVALID_LOCATION_PARAM'"/>
              </do_if>
              <do_elseif value="$PlotRange le 0m">
                <set_value name="$Feedback" exact="'$INVALID_PLOTSIZE_PARAM'"/>
              </do_elseif>
              <do_elseif value="typeof $StationSpecs != datatype.table or $StationSpecs.keys.count == 0">
                <set_value name="$Feedback" exact="'$INVALID_STATIONSPECS_PARAM'"/>
              </do_elseif>
              <do_elseif value="typeof $Faction != datatype.faction">
                <set_value name="$Feedback" exact="'$INVALID_FACTION_PARAM'"/>
              </do_elseif>
            </do_else>
          </do_else>
        </do_if>
      </actions>
      <patch sinceversion="2">
        <set_value name="$DefenceStation" exact="false"/>
      </patch>
      <patch sinceversion="3">
        <set_value name="$RewardMultiplier" exact="1.5"/>
        <set_value name="$RewardCapMultiplier" exact="2"/>
      </patch>
      <patch sinceversion="4">
        <set_value name="$VoiceTable" exact="table[]"/>
      </patch>
      <patch sinceversion="5">
        <run_actions ref="md.LIB_Generic.GenerateGenericVoiceTable" result="$VoiceTable">
          <param name="VoiceTable" value="$VoiceTable"/>
        </run_actions>
      </patch>
      <cues>
        <cue name="Do_Not_Start_Mission" onfail="cancel">
          <conditions>
            <check_value value="$Feedback"/>
          </conditions>
          <actions>
            <signal_cue cue="CleanUp"/>
          </actions>
        </cue>

        <cue name="Do_Start_Mission" onfail="cancel">
          <conditions>
            <check_value value="not $Feedback"/>
          </conditions>
          <actions>
            <do_if value="not $MissionCue">
              <set_value name="$MissionCue" exact="Start"/>
            </do_if>

            <do_if value="not $PreexistingClient?">
              <!-- No pre-existing client, create a temporary client for this mission -->
              <!-- This auto-assigns a 'matching' text-page using the metadata (id=0) specified in the text-files. Speak commands for this actor will then refer to the selected text-page-->
              <!-- Possibly we'll need to add additional filters (in case some topics aren't supported by all generic text-pages) -->
              <create_cue_actor cue="Start" name="$Client" comment="temporary cue-actor will be cleaned up in the Cleanup-cue, see destroy_object on $Client">
                <select faction="$ClientOwner" tags="tag.crew"/>
                <owner exact="$ClientOwner"/>
              </create_cue_actor>
            </do_if>

            <set_value name="$CutsceneObject" exact="null"/>

            <!-- Determine the reward (credits/object/notoriety) -->
            <do_if value="$GenerateReward">
              <include_actions ref="md.LIB_Reward_Balancing.Allocate_RewardWeight" comment="input: $Difficulty, $ClientOwner; output: $RewardCreditsWeight, $RewardModWeight, $RewardSeminarWeight"/>
              <do_if value="not $RewardCr" weight="$RewardCreditsWeight">
                <run_actions ref="CalculateResourceCostCr" result="$ResourceCost__Result">
                  <param name="PlotSize" value="$PlotSize"/>
                  <param name="StationSpecs" value="$StationSpecs"/>
                  <param name="DefenceStation" value="$DefenceStation"/>
                </run_actions>
                <set_value name="$RewardCapCr" exact="(($ResourceCost__Result)f * $RewardCapMultiplier)ct"/>
                <run_actions ref="GenerateRewardMultiplierText" result="$RewardText">
                  <param name="RewardMultiplier"    value="$RewardMultiplier"/>
                  <param name="RewardCapMultiplier" value="$RewardCapMultiplier"/>
                  <param name="RewardCapCr"         value="$RewardCapCr"/>
                </run_actions>
              </do_if>
              <do_if value="not $RewardObj">
                <run_actions ref="md.LIB_Reward_Balancing.DetermineAdditionalReward" result="$AdditionalReward">
                  <param name="RewardModWeight" value="$RewardModWeight"/>
                  <param name="RewardSeminarWeight" value="$RewardSeminarWeight"/>
                </run_actions>
                <do_if value="$AdditionalReward != null">
                  <set_value name="$RewardObj" exact="$AdditionalReward"/>
                  <do_if value="$RewardText">
                    <set_value name="$RewardText" exact="$RewardText + '\n' + $RewardObj.name"/>
                  </do_if>
                  <do_else>
                    <set_value name="$RewardText" exact="$RewardObj.name"/>
                  </do_else>
                </do_if>
              </do_if>

              <do_if value="not $RewardNotoriety">
                <signal_cue_instantly cue="md.LIB_Reward_Balancing.Reward_Notoriety" param="[Start, $Difficulty, $MissionLevel, $ClientOwner]"/>
                <set_value name="$RewardNotoriety" exact="$Reward_Notoriety__Result"/>
              </do_if>
            </do_if>

            <include_actions ref="GenerateTextTable"/>
            <include_actions ref="GenerateVoiceTable"/>

            <do_if value="$ReportSignalCue">
              <!--Signal the $ReportSignalCue that the mission has been successfully generated-->
              <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_GENERATED.clone"/>
              <set_value name="$FeedbackData.$ID" exact="'$MISSION_GENERATED'"/>
              <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="Mission variation generated successfully"/>
              <signal_cue_instantly cue="$ReportSignalCue" param="table[$Name = $TextTable.$missionname, $Cue = $MissionCue, $Reward = $RewardCr, $RewardText = $RewardText]"/>
            </do_if>

            <do_if value="@$StationSpecs.$products.count">
              <do_for_each name="$StationSpecs_Products" in="$StationSpecs.$products">
                <run_actions ref="RegisterMission">
                  <param name="Faction" value="$Faction" />
                  <param name="Sector" value="$PlotSector" />
                  <param name="Ware" value="$StationSpecs_Products.{2}" comment="[number, ware]" />
                  <param name="Mission" value="namespace" />
                </run_actions>
              </do_for_each>
            </do_if>
          </actions>
          <cues>

            <!--***MISSION OFFER***-->
            <cue name="With_Offer" onfail="cancel" version="2">
              <conditions>
                <check_value value="$WithoutOffer" exact="false"/>
              </conditions>
              <patch sinceversion="2" state="complete">
                <do_if value="MissionAccepted.state == cuestate.waiting">
                  <update_offer cue="$MissionCue">
                    <briefing replace="true">
                      <objective step="1" action="objective.buy" text="$TextTable.$objective2" object="$PlotSector" encyclopedia="$PlotSector"/>
                      <objective step="2" action="objective.build_station" text="$TextTable.$objective3"/>
                    </briefing>
                  </update_offer>
                </do_if>
              </patch>
              <cues>
                <!--Cue which creates the offer, when signalled. To be signalled from the GenericMissions.OfferMission library, referenced below-->
                <cue name="CreateOffer" instantiate="true" comment="instanced to prevent cleanup">
                  <conditions>
                    <event_cue_signalled/>
                    <check_value value="not @$OfferCreated"/>
                  </conditions>
                  <actions>
                    <do_if value="not @$OfferCreated">
                      <!-- Briefing details -->
                      <create_offer cue="$MissionCue" location="$OfferObject" distance="$OfferDistance" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" actor="$Client"
                                  faction="$ClientOwner" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText" duration="$MissionDuration" hidden="$HideFromBBS" space="$BBSSpace">
                        <briefing comment="duplicated, see MissionAccepted!">
                          <objective step="1" action="objective.buy" text="$TextTable.$objective2" object="$PlotSector" encyclopedia="$PlotSector" />
                          <objective step="2" action="objective.build_station" text="$TextTable.$objective3"/>
                          <!--objective step="4" action="objective.deliver" text="$TextTable.$objective3"/-->
                        </briefing>
                      </create_offer>
                      <!-- Offers might be outside the $OfferDistance (default 50km) and not seen by players but still count up -->
                      <run_actions ref="md.GenericMissions.UpdateTextOffsetsTable">
                        <param name="StaticGMCue" value="md.GM_BuildStation.GenerateGenericMission"/>
                        <param name="Page"        value="$Page"/>
                        <param name="TextOffset"  value="$TextOffset"/>
                      </run_actions>
                    </do_if>
                    <set_value name="$OfferCreated" exact="true"/>
                  </actions>
                </cue>

                <!--The majority of the offer logic is within this library. The parameters we pass down below, specify in which way this mission is going to be offered to the player (i.e. BBS, Signal-Leak, ...)
                Some of the mission specific handling is still contained in this file but triggered via the library via a signal e.g. setting up the briefing details via the 'CreateOffer' cue above.-->
                <cue name="Offer_Management" ref="md.GenericMissions.OfferMission">
                  <param name="OfferType"     value="$OfferType"/>
                  <param name="OfferCue"      value="$MissionCue"/>
                  <param name="CleanupCue"    value="Offer_End"/>
                  <param name="BriefingSetupCue" value="CreateOffer"/>
                  <param name="MissionName"   value="$TextTable.$missionname"/>
                  <param name="CancelOfferCue" value="$CancelOfferCue"/>

                  <!--Object based params (offered by Station/Ship/Signal-leak)-->
                  <param name="TimeoutMin"  value="8min" comment="Minimum time the offer remains valid"/>
                  <param name="TimeoutMax"  value="12min"/>
                  <param name="MaxDistance" value="$OfferMaxDistance"/>
                  <param name="RemoveOnSectorChange" value="$RemoveOnSectorChange"/>

                  <!--Object and Signal Leak based params-->
                  <param name="OfferObject" value="$OfferObject"/>

                  <!--BBS based offers-->
                  <param name="BBSObject"     value="@$BBSObject"/>
                  <param name="BBSDistance"   value="@$BBSDistance"/>
                  <param name="BBSTimeoutMin" value="@$BBSTimeoutMin"/>
                  <param name="BBSTimeoutMax" value="@$BBSTimeoutMax"/>

                  <!--Conversation event offers-->
                  <param name="AllowOfferEvent" value="$AllowOfferEvent"/>
                  <param name="ConversationTriggerCue" value="$ConversationTriggerCue"/>

                  <!--Client-->
                  <param name="Client"                 value="$Client"/>
                  <param name="VoiceTable"             value="$VoiceTable"/>

                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <!--Cue signalled when the offer library is finished-->
                <cue name="Offer_End">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <debug_text text="this.$Feedback.$ID"/>
                    <do_if value="this.$Feedback.$ID == '$accepted_offer'">
                      <signal_cue cue="MissionAccepted"/>
                    </do_if>
                    <do_elseif value="this.$Feedback.$ID == '$DECLINED_OFFER'">
                      <set_value name="$Feedback" exact="'$DECLINED_OFFER'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$OFFER_REMOVED'">
                      <set_value name="$Feedback" exact="'$OFFER_REMOVED'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$SIGNAL_LEAK_REMOVED'">
                      <set_value name="$Feedback" exact="'$SIGNAL_LEAK_REMOVED'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$EVENT_OFFER_TIMEOUT'">
                      <set_value name="$Feedback" exact="'$EVENT_OFFER_TIMEOUT'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                  </actions>
                </cue>
              </cues>
            </cue>

            <!--These cues handle the cases where a mission is automatically accepted on creation-->
            <cue name="Without_Offer" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer"/>
                <check_value value="not $WithoutOfferWaitCue"/>
              </conditions>
              <actions>
                <signal_cue cue="MissionAccepted" />
              </actions>
            </cue>

            <cue name="Without_Offer_Wait_Cue" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer"/>
                <check_value value="$WithoutOfferWaitCue"/>
              </conditions>
              <cues>
                <cue name="Without_Offer_Wait_Cue_Completed">
                  <conditions>
                    <check_any>
                      <event_cue_completed cue="$WithoutOfferWaitCue"/>
                      <check_all>
                        <event_cue_signalled cue="$WithoutOfferWaitCue"/>
                        <check_value value="event.param == $MissionCue"/>
                      </check_all>
                    </check_any>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="MissionAccepted" />
                  </actions>
                </cue>
              </cues>
            </cue>

            <!--These cues handle the briefing presentations e.g. Holomap or cutscene render targets (depending on the mission)
            note: play_cutscene action should not be in the actions of the cue with a event_briefing_submission_selected condition. It must be delayed-->
            <cue name="BriefingStarted">
              <conditions>
                <check_any>
                  <event_briefing_started cue="$MissionCue"/>
                  <event_briefing_submission_selected cue="$MissionCue"/>
                </check_any>
              </conditions>
              <actions>
                <set_value name="$RenderTarget" exact="event.param.{1}"/>
                <set_value name="$StartBriefingCutscene"/>
                <set_value name="$stationindex" exact="1"/>
                <debug_text text="'Briefing started'" chance="$DebugChance"/>
              </actions>
              <cues>
                <cue name="DisplayCutscene" onfail="cancel">
                  <conditions>
                    <check_value value="$StartBriefingCutscene?"/>
                  </conditions>
                  <actions>
                    <do_if value="$CutsceneObject != null">
                      <set_value name="$BriefingCutsceneStarted"/>
                      <set_value name="$CutsceneKey" exact="'OrbitIndefinitely'"/>
                      <play_cutscene key="$CutsceneKey" rendertarget="$RenderTarget">
                        <param name="targetobject" object="$CutsceneObject"/>
                      </play_cutscene>
                    </do_if>
                    <do_else>
                      <set_value name="$MapTarget" exact="$PlotSector"/>
                      <do_if value="not $HoloMap?">
                        <add_holomap name="$HoloMap" rendertarget="$RenderTarget"/>
                      </do_if>
                      <signal_cue cue="HoloMap_Trigger"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="HoloMap_Trigger">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <cues>
                    <cue name="HolomapRef" ref="md.LIB_HolomapTarget.Start">
                      <param name="EndSignalCue" value="HolomapEnd"/>

                      <param name="HoloMap" value="$HoloMap" />
                      <param name="Components" value="[player.entity, $PlotSector]"/>
                      <param name="ShowUnknown" value="false"/>
                      <param name="PanTime" value="5s"/>
                      <param name="ZoomTime" value="2s"/>
                      <param name="IsReplay" value="true"/>
                      <param name="SkipComponentPath" value="true"/>
                      <param name="verbosedebugchance" value="0"/>
                    </cue>
                    <cue name="HolomapEnd">
                      <conditions>
                        <event_cue_signalled/>
                      </conditions>
                      <actions>
                        <debug_text text="'Holomap animation end'" chance="$DebugChance"/>
                      </actions>
                      <cues>
                        <cue name="PlayBriefingCutscene" onfail="cancel">
                          <actions>
                            <do_if value="$HoloMap?">
                              <remove_holomap />
                              <remove_value name="$HoloMap"/>
                            </do_if>
                          </actions>
                        </cue>
                      </cues>
                    </cue>
                  </cues>
                </cue>

                <cue name="BriefingStopped">
                  <conditions>
                    <check_any>
                      <event_briefing_cancelled cue="$MissionCue"/>
                      <event_briefing_submission_unselected cue="$MissionCue"/>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="$BriefingCutsceneStarted?">
                      <!--Temp value. This is used to identify if a cutscene for this mission is still playing.-->
                      <remove_value name="$BriefingCutsceneStarted"/>
                      <remove_value name="$MapTarget"/>
                      <stop_cutscene key="$CutsceneKey"/>
                    </do_if>

                    <do_if value="$HoloMap?">
                      <remove_holomap />
                      <remove_value name="$HoloMap"/>
                    </do_if>

                    <debug_text text="'Briefing canceled'" chance="$DebugChance"/>
                    <reset_cue cue="BriefingStarted"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <!--This cue creates the mission itself, either from scratch or via an existing mission offer-->
            <cue name="MissionAccepted" version="2">
              <conditions>
                <event_cue_signalled />
              </conditions>
              <actions>
                <debug_text text="'Mission accepted!'" chance="$DebugChance"/>
                <set_value name="stat.missions_accepted" operation="add"/>

                <do_if value="$WithoutOffer">
                  <!--$MissionCue may already be a mission cue passed in as a parameter-->
                  <do_if value="not $MissionCue.hasmission">
                    <do_if value="$MissionThread">
                      <create_mission cue="$MissionCue" missionthread="$MissionThread" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" faction="$ClientOwner" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText"/>
                    </do_if>
                    <do_else>
                      <create_mission cue="$MissionCue" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" faction="$ClientOwner" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText"/>
                    </do_else>
                  </do_if>

                  <update_mission cue="$MissionCue">
                    <briefing comment="duplicated, see CreateOffer!">
                      <objective step="1" action="objective.buy" text="$TextTable.$objective2" encyclopedia="$PlotSector"/>
                      <objective step="2" action="objective.build_station" text="$TextTable.$objective3"/>
                      <!--objective step="4" action="objective.deliver" text="$TextTable.$objective4"/-->
                    </briefing>
                  </update_mission>
                </do_if>
                <do_else>
                  <!--Copy data from the offer, then remove it-->
                  <do_if value="$MissionThread">
                    <create_mission cue="$MissionCue" offercue="$MissionCue" missionthread="$MissionThread"/>
                  </do_if>
                  <do_else>
                    <create_mission cue="$MissionCue" offercue="$MissionCue"/>
                  </do_else>
                  <remove_offer cue="$MissionCue"/>
                  <cancel_cue cue="With_Offer"/>
                </do_else>

                <do_if value="$ReportSignalCue">
                  <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_ACCEPTED.clone"/>
                  <set_value name="$FeedbackData.$ID" exact="'$MISSION_ACCEPTED'"/>
                  <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="Mission accepted"/>
                  <signal_cue_instantly cue="$ReportSignalCue"/>
                </do_if>

                <signal_cue_instantly cue="md.GenericMissions.GenericAcceptLogbookEntry" param="[$TextTable.$missionname, $Client, $ClientOwner]"/>
              </actions>
              <patch sinceversion="2" state="complete">
                <update_mission cue="$MissionCue">
                  <briefing replace="true">
                    <objective step="1" action="objective.buy" text="$TextTable.$objective2" encyclopedia="$PlotSector"/>
                    <objective step="2" action="objective.build_station" text="$TextTable.$objective3"/>
                  </briefing>
                </update_mission>
              </patch>
              <cues>
                <cue name="ActivateImmediately" onfail="cancel">
                  <conditions>
                    <check_value value="not $MissionThread"/>
                  </conditions>
                  <actions>
                    <signal_cue cue="ActivateMission"/>
                  </actions>
                </cue>

                <cue name="ActivateOnCondition" onfail="cancel">
                  <conditions>
                    <check_value value="$MissionThread"/>
                  </conditions>
                  <actions>
                    <do_if value="$MissionThread.canactivatesubmission.{$MissionCue}">
                      <signal_cue cue="ActivateMission"/>
                      <cancel_cue cue="ActivateOnCondition"/>
                    </do_if>
                  </actions>
                  <cues>
                    <!--TODO @Owen add an event for when a submission has been removed from the thread-->
                    <cue name="CheckMissionThreadState" checkinterval="1s">
                      <conditions>
                        <check_value value="$MissionThread.canactivatesubmission.{$MissionCue}"/>
                      </conditions>
                      <actions>
                        <signal_cue cue="ActivateMission"/>
                        <cancel_cue cue="ActivateOnCondition"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="ActivateMission">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <do_if value="$MissionDuration">
                      <update_mission cue="$MissionCue" endtime="player.age + $MissionDuration"/>
                    </do_if>
                  </actions>
                  <cues>

                    <cue name="Aborted_V2">
                      <conditions>
                        <event_mission_aborted cue="$MissionCue"/>
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="md.GenericMissions.GenericAbortLogbookEntry" param="[$TextTable.$missionname, $Client]"/>

                        <set_value name="$Feedback" exact="'$MISSION_ABORTED'"/>
                        <remove_mission cue="$MissionCue" type="aborted"/>
                        <signal_cue cue="CleanUp" />
                      </actions>
                    </cue>

                    <!--We removed the usage of RML_FlyTo which used to signal ReachedLocation.
                    Due to it potentially being instantiated, we check to see if an instance has set $Patch_InstanceRunning. If not, signal it.-->
                    <cue name="ReachedLocation_Signal" onfail="cancel">
                      <conditions>
                        <check_value value="not @$Patch_InstanceRunning"/>
                      </conditions>
                      <actions>
                        <signal_cue cue="ReachedLocation"/>
                      </actions>
                    </cue>

                    <!--NOTE: This shouldn't need to be instantiated but do not change due to savegame compatibility.-->
                    <cue name="ReachedLocation" instantiate="true" version="2">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <set_value name="$StartStep" exact="1"/>
                      </actions>
                      <patch sinceversion="2" state="complete">
                        <set_value name="$Patch_InstanceRunning" exact="true"/>
                      </patch>
                      <cues>
                        <cue name="ClaimPlot_Trigger" onfail="cancel">
                          <conditions>
                            <cue_is_waiting cue="ClaimPlot_Done"/>
                          </conditions>
                          <actions>
                            <!--Triggers in two cases. A fresh run of the mission or when ReachedLocation was patched to version 2 and the RML_ClaimPlot call was restructured.-->
                            <debug_text text="'Signalling ClaimPlot cue: ' + ClaimPlot" filter="savegame" chance="if @$Patch_InstanceRunning then 100 else 0"/>
                            <signal_cue cue="ClaimPlot"/>
                          </actions>
                        </cue>

                        <cue name="ClaimPlot">
                          <conditions>
                            <event_cue_signalled/>
                          </conditions>
                          <cues>
                            <cue name="ClaimPlot_Ref_V2" ref="md.RML_ClaimPlot.ClaimPlot">
                              <!-- always pass these -->
                              <param name="EndSignalCue" value="ClaimPlot_Done" comment="RML returns $StationBuilt in this cue"/>
                              <param name="MissionCue" value="$MissionCue"/>
                              <param name="StartStep" value="$StartStep" comment="Briefing step to start the mission on"/>
                              <param name="UpdateBriefing" value="true" comment="Update the briefing objective step when the objective is updated"/>
                              <param name="DebugChance" value="$DebugChance"/>
                              <!-- mission-related parameters -->
                              <param name="Faction"           value="$Faction"/>
                              <param name="PlotSector"        value="$PlotSector"/>
                              <param name="PlotOffset"        value="$PlotOffset"/>
                              <param name="PlotRange"         value="$PlotRange"/>
                              <param name="PlotSize"          value="$PlotSize"/>
                              <param name="ObjectiveText"     value="$TextTable.$objective2"/>
                            </cue>

                            <cue name="ClaimPlot_KeepAlive">
                              <conditions>
                                <event_cue_signalled/>
                              </conditions>
                            </cue>
                          </cues>
                        </cue>

                        <!--TODO @Roger @Owen correct the feedback values of the different RMLs used in this mission. Handle errors or failure cases-->

                        <cue name="ClaimPlot_Done">
                          <conditions>
                            <event_cue_signalled/>
                          </conditions>
                          <actions>
                            <set_value name="$StartStep"      exact="2"/>
                            <set_value name="$CutsceneObject" exact="ClaimPlot_Done.$StationBuilt" />
                            <set_value name="$RML_Result_Table" exact="table[]"/>
                            <!--Reset ClaimPlot so that is can be signalled again if the station becomes invalid-->
                            <reset_cue cue="ClaimPlot"/>
                          </actions>
                          <cues>
                            <!-- Trigger the RML, which will check the win/lose conditions and report back -->
                            <cue name="BuildStation_Ref" ref="md.RML_BuildStation.BuildStation">
                              <!-- always pass these -->
                              <param name="EndSignalCue" value="MissionEnded"/>
                              <param name="MissionCue" value="$MissionCue"/>
                              <param name="StartStep" value="$StartStep" comment="Briefing step to start the mission on"/>
                              <param name="UpdateBriefing" value="true" comment="Update the briefing objective step when the objective is updated"/>
                              <param name="DebugChance" value="$DebugChance"/>
                              <!-- mission-related parameters -->
                              <param name="Faction"           value="$Faction"/>
                              <param name="Station"           value="ClaimPlot_Done.$StationBuilt"/>
                              <param name="StationSpecs"      value="$StationSpecs"/>
                              <param name="PlotSector"        value="$PlotSector"/>
                              <param name="PlotOffset"        value="$PlotOffset"/>
                              <param name="PlotRange"         value="$PlotRange"/>
                              <param name="PlotSize"          value="$PlotSize"/>
                              <param name="ObjectiveText"     value="$TextTable.$objective3"/>
                              <param name="ResultTable"       value="$RML_Result_Table"/>
                              <param name="DefenceStation"    value="$DefenceStation"/>
                            </cue>

                            <cue name="BuildStation_Reset" instantiate="true">
                              <conditions>
                                <event_cue_signalled cue="Start"/>
                                <check_value value="event.param == 'reset_buildstation'"/>
                              </conditions>
                              <actions>
                                <reset_cue cue="BuildStation_Ref"/>
                              </actions>
                            </cue>

                            <cue name="MissionEnded">
                              <!-- Handle the end-feedback (usually originating from the RML used above) -->
                              <conditions>
                                <event_cue_signalled/>
                              </conditions>
                              <actions>
                                <!--Station plot was moved - restart the claim plot objective-->
                                <do_if value="MissionEnded.$EndFeedbackValue" exact="-3">
                                  <set_value name="$StartStep" exact="1"/>
                                  <set_value name="ClaimPlot_Done.$StationBuilt" exact="null"/>
                                  <signal_cue cue="ClaimPlot"/>
                                  <reset_cue cue="ClaimPlot_Done"/>
                                </do_if>

                                <!-- Failure case -->
                                <do_elseif value="MissionEnded.$EndFeedbackValue" max="0">
                                  <debug_text text="'This mission has failed. RML Feedback: ' + MissionEnded.$EndFeedbackValue" chance="$DebugChance"/>
                                  <set_value name="$Feedback" exact="'$BUILD_RML_FAILED'"/>
                                  <speak actor="$Client" line="$VoiceTable.$MissionFailed" comment="(failed mission)" chance="if $VoiceTable.$MissionFailed == 0 then 0 else 100" />
                                  <signal_cue_instantly cue="md.GenericMissions.GenericFailLogbookEntry" param="[$TextTable.$missionname, $Client, @MissionEnded.$EndFeedbackText]"/>

                                  <remove_mission cue="$MissionCue" type="failed" reason="@MissionEnded.$EndFeedbackText"/>
                                  <signal_cue cue="CleanUp" />
                                </do_elseif>

                                <!-- Success case -->
                                <do_else>
                                  <do_if value="$ResultTable">
                                    <set_value name="$ResultTable.$BuiltStation" exact="@$RML_Result_Table.$BuiltStation"/>
                                  </do_if>
                                  <!--TODO: Partial success-->
                                  <debug_text text="'This mission has ended. RML Feedback: ' + MissionEnded.$EndFeedbackValue" chance="$DebugChance"/>
                                  <do_if value="$RewardNotoriety and $ClientOwner">
                                    <debug_text text="'Relation was: ' + player.entity.relationto.{$ClientOwner}" chance="$DebugChance"/>
                                    <add_faction_relation faction="faction.player" otherfaction="$ClientOwner" value="$RewardNotoriety" reason="relationchangereason.missioncompleted" />
                                    <debug_text text="'Relation is now: ' + player.entity.relationto.{$ClientOwner}" chance="$DebugChance"/>
                                  </do_if>

                                  <do_if value="$RewardCapCr?">
                                    <set_value name="$PaidBuildPlotCr" exact="this.$StationBuilt.paidbuildplot.payment"/>
                                    <set_value name="$StationValueCr" exact="this.$StationBuilt.value"/>
                                    <debug_text text="'$RewardCapCr: ' + $RewardCapCr.formatted.default + ', $PaidBuildPlotCr: ' + $PaidBuildPlotCr.formatted.default + ', $StationValueCr: ' + $StationValueCr.formatted.default" chance="$DebugChance"/>

                                    <set_value name="$RewardCr" exact="(($PaidBuildPlotCr + $StationValueCr)f * $RewardMultiplier)ct"/>
                                    <debug_text text="'Total reward: ' + $RewardCr" chance="$DebugChance"/>
                                    <do_if value="$RewardCr gt $RewardCapCr">
                                      <debug_text text="'Reward capped to: ' + $RewardCapCr.formatted.default" chance="$DebugChance"/>
                                      <set_value name="$RewardCr" exact="$RewardCapCr"/>
                                    </do_if>
                                    <reward_player money="$RewardCr"/>
                                  </do_if>
                                  <!-- If $RewardCr was set in the GM params, simply give that amount to the player without modifying it -->
                                  <do_elseif value="$RewardCr">
                                    <reward_player money="$RewardCr"/>
                                  </do_elseif>

                                  <do_if value="$RewardObj">
                                    <do_if value="$RewardObj.isinventory">
                                      <add_inventory entity="player.entity" ware="$RewardObj" />
                                      <show_notification text="[{1015,100}, '', $RewardText]" sound="notification_achievement" comment="Item received" />
                                    </do_if>
                                  </do_if>
                                  <set_value name="stat.missions_completed" operation="add"/>
                                  <set_value name="$Feedback" exact="'$MISSION_SUCCEEDED'"/>
                                  <speak actor="$Client" line="$VoiceTable.$MissionSuccess" comment="(successful mission)" chance="if $VoiceTable.$MissionSuccess == 0 then 0 else 100" />
                                  <signal_cue_instantly cue="md.GenericMissions.GenericCompleteLogbookEntry" param="[$TextTable.$missionname, $Client, null, $RewardCr]"/>

                                  <run_actions ref="md.GenericMissions.UpdateTextOffsetsTable_completedcounter">
                                    <param name="StaticGMCue" value="md.GM_BuildStation.GenerateGenericMission"/>
                                    <param name="Page"        value="$Page"/>
                                    <param name="TextOffset"  value="$TextOffset"/>
                                  </run_actions>

                                  <remove_mission cue="$MissionCue" type="completed" activate="next" />

                                  <do_if value="@$StationSpecs.$products.count">
                                    <do_for_each name="$StationSpecs_Products" in="$StationSpecs.$products">
                                      <run_actions ref="RegisterMission" comment="updates the time. prevents the same factory from being offered again too soon.">
                                        <param name="Faction" value="$Faction" />
                                        <param name="Sector" value="$PlotSector" />
                                        <param name="Ware" value="$StationSpecs_Products.{2}" comment="[number, ware]" />
                                        <param name="Mission" value="namespace" />
                                      </run_actions>
                                    </do_for_each>
                                  </do_if>

                                  <signal_cue cue="CleanUp" />
                                </do_else>
                              </actions>
                            </cue>
                          </cues>
                        </cue>

                        <cue name="MissionTimeout" onfail="cancel">
                          <conditions>
                            <check_value value="typeof $MissionDuration == datatype.time"/>
                            <check_value value="$MissionDuration" min="1s"/>
                          </conditions>
                          <delay exact="$MissionDuration"/>
                          <actions>
                            <signal_cue_instantly cue="md.GenericMissions.GenericTimeoutLogbookEntry" param="[$TextTable.$missionname, $Client]"/>

                            <remove_mission cue="$MissionCue" type="failed"/>
                            <set_value name="$Feedback" exact="'$MISSION_TIMEOUT'"/>
                            <signal_cue_instantly cue="CleanUp" />
                          </actions>
                        </cue>
                      </cues>
                    </cue>

                  </cues>
                </cue>
              </cues>
            </cue>

            <!-- Currently only as special handling for HOP and PAR, who may unify and become TRI in the Paranid story. -->
            <cue name="FactionDeactivated" instantiate="true">
              <conditions>
                <check_any>
                  <check_all>
                    <event_faction_deactivated faction="$ClientOwner"/>
                    <check_value value="($ClientOwner == faction.paranid) or ($ClientOwner == faction.holyorder)"/>
                    <check_value value="faction.trinity.isactive"/>
                  </check_all>
                  <check_all>
                    <event_faction_deactivated faction="$Faction"/>
                    <check_value value="($Faction == faction.paranid) or ($Faction == faction.holyorder)"/>
                    <check_value value="faction.trinity.isactive"/>
                  </check_all>
                  <event_cue_signalled/>
                </check_any>
              </conditions>
              <actions>
                <set_value name="$ClientOwner" exact="faction.trinity"/>
                <set_value name="$Faction" exact="faction.trinity"/>

                <do_if value="$MissionCue.hasmissionoffer">
                  <update_offer cue="$MissionCue" faction="$ClientOwner"/>
                </do_if>
                <do_elseif value="$MissionCue.hasmission">
                  <update_mission cue="$MissionCue" faction="$ClientOwner"/>
                </do_elseif>

                <!-- Workaround. ReachedLocation instantiates, so we can't easily access the states of the cues below it. -->
                <do_if value="@$StartStep == 2" comment="Variable is created in ReachedLocation and may not exist.">
                  <signal_cue_instantly cue="Start" param="'reset_buildstation'"/>
                </do_if>
              </actions>
            </cue>

            <cue name="FactionDeactivated_Patch" onfail="cancel">
              <conditions>
                <check_any>
                  <check_all>
                    <check_value value="($ClientOwner == faction.paranid) or ($ClientOwner == faction.holyorder)"/>
                    <check_value value="not $ClientOwner.isactive"/>
                    <check_value value="faction.trinity.isactive"/>
                  </check_all>
                  <check_all>
                    <check_value value="($Faction == faction.paranid) or ($Faction == faction.holyorder)"/>
                    <check_value value="not $Faction.isactive"/>
                    <check_value value="faction.trinity.isactive"/>
                  </check_all>
                </check_any>
              </conditions>
              <actions>
                <signal_cue cue="FactionDeactivated"/>
              </actions>
            </cue>

          </cues>
        </cue>

        <cue name="ForceCleanup" onfail="cancel">
          <conditions>
            <check_value value="$ForceCleanup"/>
          </conditions>
          <actions>
            <do_if value="not $ForceCleanup.exists">
              <set_value name="$Feedback" exact="'$INVALID_FORCE_CLEANUP'"/>
              <signal_cue_instantly cue="CleanUp"/>
            </do_if>
          </actions>
          <cues>
            <cue name="ForceCleanup_Wait">
              <conditions>
                <check_any>
                  <event_cue_completed cue="$ForceCleanup"/>
                  <check_all>
                    <event_cue_signalled cue="$ForceCleanup"/>
                    <check_value value="event.param == $MissionCue"/>
                  </check_all>
                </check_any>
              </conditions>
              <actions>
                <set_value name="$Feedback" exact="'$FORCED_CLEANUP'"/>
                <signal_cue_instantly cue="CleanUp"/>
              </actions>
            </cue>
          </cues>
        </cue>

        <cue name="CleanUp">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <!--Temp value. This is used to identify if a cutscene for this mission is still playing.-->
            <do_if value="$BriefingCutsceneStarted?">
              <remove_value name="$BriefingCutsceneStarted"/>
              <stop_cutscene key="$CutsceneKey"/>

              <do_if value="@$CutsceneCluster.exists">
                <destroy_object object="$CutsceneCluster"/>
              </do_if>
              <do_if value="$CutsceneShip.exists">
                <destroy_object object="$CutsceneShip"/>
              </do_if>
            </do_if>
            <do_if value="$HoloMap?">
              <remove_holomap />
              <remove_value name="$HoloMap"/>
            </do_if>


            <!--***Cleanup objects***-->

            <!--No .exists check here as $Client may not be connected to gamegraph-->
            <do_if value="$Client.isclass.npc and (not $PreexistingClient?)">
              <destroy_object object="$Client" comment="cleanup the client we created with create_cue_actor"/>
            </do_if>

            <!--***Evaluate result***-->

            <do_if value="$DebugChance or $ReportSignalCue">
              <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.{$Feedback}.clone"/>
              <do_if value="$FeedbackData">
                <set_value name="$FeedbackData.$ID" exact="$Feedback"/>
                <debug_text text="'Mission ended with reason: ' + $FeedbackData.$type + ' - ' + $FeedbackData.$text" chance="$DebugChance"/>
              </do_if>
              <do_else>
                <set_value name="$FeedbackData" exact="table[$ID = 'error_unknown', $type = 'error', $text = 'This is an unknown error']" comment="feedback = id, type and error-text from the above FeedbackValues-table"/>
                <assert value="false" text="'Mission ended with unknown case: ' + $Feedback + ' [Owen]'" break="1"/>
              </do_else>

              <do_if value="$ReportSignalCue" comment ="The cue which called us">
                <set_value name="$ReportSignalCue.$EndFeedbackValue" exact="$FeedbackData" comment="return feedback-data to calling cue"/>
                <signal_cue cue="$ReportSignalCue"/>
              </do_if>
            </do_if>

            <cancel_cue cue="Start"/>
          </actions>
        </cue>

      </cues>
    </library>

    <!-- MISSION SETUP HELPERS -->

    <library name="CalculateResourceCostCr" purpose="run_actions">
      <params>
        <param name="PlotSize"/>
        <param name="StationSpecs"/>
        <param name="DefenceStation" default="false"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <set_value name="$EquipmentCount" exact="0"/>
        <set_value name="$DefenceModuleCount" exact="0"/>

        <!-- Station plot -->
        <set_value name="$PlotSizeKm3" exact="(($PlotSize.x)/1000 * ($PlotSize.y)/1000 * ($PlotSize.z)/1000)f" comment="Known engine limitation: units remain in meters so cast them away"/>
        <set_value name="$StationPlotCr" exact="$PlotSizeKm3 * (20000)Cr"/>
        <debug_text text="'RewardPlot:' + $StationPlotCr + ' for ' + $PlotSizeKm3 + 'km^3'" chance="$DebugChance"/>

        <!-- Builder fee -->
        <set_value name="$BuilderCr" exact="50000Cr"/>
        <debug_text text="'Builder costs ' + $BuilderCr" chance="$DebugChance"/>

        <!-- Specifically requested macros -->
        <do_if value="$StationSpecs.$containedmacros? and $StationSpecs.$containedmacros.count">
          <set_value name="$MacroCr" exact="0Cr"/>
          <do_for_each in="$StationSpecs.$containedmacros" name="$macro">
            <run_actions ref="GetDefPriceCr" result="$DefPrice">
              <param name="Def" value="$macro.{2}"/>
            </run_actions>
            <debug_text text="'Macro ' + $macro.{2}.knownname + ' costs ' + $DefPrice" chance="$DebugChance"/>
            <set_value name="$MacroCr" exact="$MacroCr + $DefPrice * $macro.{1}"/>
          </do_for_each>

          <debug_text text="'Specifically requested macros cost ' + $MacroCr + ' in total.'" chance="$DebugChance"/>
        </do_if>

        <!-- Requested classes -->
        <do_if value="$StationSpecs.$containedclasses? and $StationSpecs.$containedclasses.count">
          <do_for_each in="$StationSpecs.$containedclasses" name="$class">
            <!-- Defence modules -->
            <do_if value="$class.{2} == class.defencemodule">
              <set_value name="$DefenceModuleCount" exact="$class.{1}" comment="Remember for equipment cost calculation"/>
            </do_if>

            <!-- Dock areas -->
            <do_elseif value="$class.{2} == class.dockarea">
              <get_module_definition macro="$ViableDefs" tags="[tag.dockarea, tag.module]" set="'factory'" multiple="true"/>
              <remove_from_list name="$ViableDefs" exact="macro.dockarea_arg_m_02_tradestation_01_macro" comment="Expensive dock that the player can't build"/>
              <debug_text text="'Viable dock modules: ' + $ViableDefs" chance="$DebugChance"/>
              <run_actions ref="GetMostExpensiveDefinition" result="$MostExpensiveDef">
                <param name="ViableDefs" value="$ViableDefs"/>
              </run_actions>

              <set_value name="$DockModuleCr" exact="$MostExpensiveDef.{2} * $class.{1}" comment="Multiply by requested amount"/>
              <debug_text text="$class.{1} + ' ' + $MostExpensiveDef.{1} +  ' cost ' + $DockModuleCr + ' in total.'" chance="$DebugChance"/>
            </do_elseif>

            <!-- Piers -->
            <do_elseif value="$class.{2} == class.pier">
              <get_module_definition macro="$ViableDefs" tags="[tag.pier, tag.module]" set="'factory'" multiple="true"/>
              <debug_text text="'Viable pier modules: ' + $ViableDefs" chance="$DebugChance"/>
              <run_actions ref="GetMostExpensiveDefinition" result="$MostExpensiveDef">
                <param name="ViableDefs" value="$ViableDefs"/>
              </run_actions>

              <set_value name="$PierModuleCr" exact="$MostExpensiveDef.{2} * $class.{1}" comment="Multiply by requested amount"/>
              <debug_text text="$class.{1} + ' ' + $MostExpensiveDef.{1} +  ' cost ' + $PierModuleCr + ' in total.'" chance="$DebugChance"/>
            </do_elseif>

            <!-- Equipment -->
            <do_elseif value="[class.turret, class.missileturret, class.shieldgenerator].indexof.{$class.{2}}">
              <set_value name="$EquipmentCount" exact="$EquipmentCount + $class.{1}" comment="Remember for equipment cost calculation"/>
              <debug_text text="'Added ' + $class.{1} + 'x ' + $class.{2} + '. Equipment count: ' + $EquipmentCount" chance="$DebugChance"/>
            </do_elseif>
          </do_for_each>
        </do_if>

        <!-- Calculate defence module cost including equipment -->
        <do_if value="$EquipmentCount">
          <!-- Get price of the most expensive defence module -->
          <get_module_definition macro="$ViableDefs" tags="[tag.defence, tag.module]" set="'factory'" multiple="true"/>
          <debug_text text="'Viable defence modules for equipment cost calculation: ' + $ViableDefs" chance="$DebugChance"/>
          <run_actions ref="GetMostExpensiveDefinition" result="$MostExpensiveDef">
            <param name="ViableDefs" value="$ViableDefs"/>
          </run_actions>

          <!-- Get price of a defence module max loadout -->
          <set_value name="$MaxLoadoutCr" exact="0Cr"/>
          <generate_loadout result="$MostExpensiveLoadout" macro="macro.station_gen_factory_base_01_macro" module="$MostExpensiveDef.{1}" level="1.0"/>
          <do_for_each in="$MostExpensiveLoadout.{1}.wares.list" name="$Def">
            <run_actions ref="GetDefPriceCr" result="$DefPrice">
              <param name="Def" value="$Def"/>
            </run_actions>
            <set_value name="$MaxLoadoutCr" exact="$MaxLoadoutCr + $DefPrice"/>
          </do_for_each>

          <!-- Determine required amount of defence modules to fit all equipment -->
          <set_value name="$RequiredDefenceModuleCount" exact="($EquipmentCount / $MostExpensiveLoadout.{1}.wares.count)i"/>
          <do_if value="$RequiredDefenceModuleCount lt 1">
            <set_value name="$RequiredDefenceModuleCount" exact="1"/>
          </do_if>

          <!-- Compare with existing amount, if any -->
          <set_value name="$FinalDefenceModuleCount" exact="[$DefenceModuleCount, $RequiredDefenceModuleCount].max"/>

          <!-- Calculate total cost of defence modules and equipment -->
          <set_value name="$DefenceModuleCr" exact="$FinalDefenceModuleCount * ($MostExpensiveDef.{2} + $MaxLoadoutCr)"/>
          <debug_text text="'Mission asks for ' + $EquipmentCount + ' pieces of equipment and ' + $DefenceModuleCount + ' defence modules.
                                \nA defence module holds ' + $MostExpensiveLoadout.{1}.wares.count + ' pieces of equipment each.
                                \nA full loadout costs ' + $MaxLoadoutCr + ' and the defence module itself costs ' + $MostExpensiveDef.{2} + '.
                                \n' + $FinalDefenceModuleCount + ' fully equipped ' + $MostExpensiveDef.{1} +  ' cost ' + $DefenceModuleCr + ' in total.'" chance="$DebugChance"/>
        </do_if>

        <!-- Requested products -->
        <do_if value="$StationSpecs.$products? and $StationSpecs.$products.count">
          <do_for_each in="$StationSpecs.$products" name="$product">
            <get_module_definition macro="$ViableDefs" ware="$product.{2}" set="'factory'" multiple="true"/>
            <debug_text text="'Viable production modules for ' + $product.{2} + ': ' + $ViableDefs" chance="$DebugChance"/>
            <run_actions ref="GetMostExpensiveDefinition" result="$MostExpensiveDef">
              <param name="ViableDefs" value="$ViableDefs"/>
            </run_actions>

            <set_value name="$ProductionModuleCr" exact="$MostExpensiveDef.{2} * $product.{1}" comment="Multiply by requested amount"/>
            <debug_text text="$product.{1} + ' ' + $MostExpensiveDef +  ' cost ' + $ProductionModuleCr + ' in total.'" chance="$DebugChance"/>
          </do_for_each>
        </do_if>

        <!-- Solid storage -->
        <do_if value="$StationSpecs.$solidstorage? and (typeof $StationSpecs.$solidstorage).isnumeric and $StationSpecs.$solidstorage gt 0">
          <run_actions ref="GetMostExpensiveStoragePriceCr" result="$SolidStorageModuleSetup">
            <param name="StorageTag" value="tag.solid"/>
            <param name="StorageAmount" value="$StationSpecs.$solidstorage"/>
          </run_actions>

          <debug_text text="'Solid storage costs ' + $SolidStorageModuleSetup.{1} + ' in total. Selected modules: ' + $SolidStorageModuleSetup.{2}" chance="$DebugChance"/>
          <set_value name="$SolidStorageCr" exact="$SolidStorageModuleSetup.{2}"/>
        </do_if>

        <!-- Liquid storage -->
        <do_if value="$StationSpecs.$liquidstorage? and (typeof $StationSpecs.$liquidstorage).isnumeric and $StationSpecs.$liquidstorage gt 0">
          <run_actions ref="GetMostExpensiveStoragePriceCr" result="$LiquidStorageModuleSetup">
            <param name="StorageTag" value="tag.liquid"/>
            <param name="StorageAmount" value="$StationSpecs.$liquidstorage"/>
          </run_actions>

          <debug_text text="'Liquid storage costs ' + $LiquidStorageModuleSetup.{1} + ' in total. Selected modules: ' + $LiquidStorageModuleSetup.{2}" chance="$DebugChance"/>
          <set_value name="$LiquidStorageCr" exact="$LiquidStorageModuleSetup.{2}"/>
        </do_if>

        <!-- Container storage -->
        <do_if value="$StationSpecs.$containerstorage? and (typeof $StationSpecs.$containerstorage).isnumeric and $StationSpecs.$containerstorage gt 0">
          <run_actions ref="GetMostExpensiveStoragePriceCr" result="$ContainerStorageModuleSetup">
            <param name="StorageTag" value="tag.container"/>
            <param name="StorageAmount" value="$StationSpecs.$containerstorage"/>
          </run_actions>

          <debug_text text="'Container storage costs ' + $ContainerStorageModuleSetup.{2} + ' in total. Selected modules: ' + $ContainerStorageModuleSetup.{1}" chance="$DebugChance"/>
          <set_value name="$ContainerStorageCr" exact="$ContainerStorageModuleSetup.{2}"/>
        </do_if>

        <!-- If it's supposed to be a defence station, add the cost for a module that can claim space -->
        <do_if value="$DefenceStation">
          <get_module_definition macro="$ViableDefs" tags="[tag.claim]" set="'factory'" multiple="true"/>
          <remove_from_list name="$ViableDefs" exact="macro.defence_par_claim_story_01_macro" comment="Story-exclusive macro that costs too much and skews the result"/>
          <debug_text text="'Viable ownership claiming modules: ' + $ViableDefs" chance="$DebugChance"/>
          <run_actions ref="GetMostExpensiveDefinition" result="$MostExpensiveDef">
            <param name="ViableDefs" value="$ViableDefs"/>
          </run_actions>

          <set_value name="$AdminModuleCr" exact="$MostExpensiveDef.{2}" comment="Multiply by requested amount"/>
          <debug_text text="'Ownership claiming module (' + $MostExpensiveDef.{1} + ') costs ' + $MostExpensiveDef.{2}" chance="$DebugChance"/>
        </do_if>

        <set_value name="$ResourceCost" exact="((@$StationPlotCr
                                                   + $BuilderCr
                                                   + @$MacroCr
                                                   + @$DefenceModuleCr + @$DockModuleCr + @$PierModuleCr
                                                   + @$ProductionModuleCr
                                                   + @$SolidStorageCr + @$LiquidStorageCr + @$ContainerStorageCr
                                                   + @$AdminModuleCr) / (1000Cr)) * (1000Cr)" comment="round"/>
        <debug_text text="'Total worst case station construction cost: ' + $ResourceCost" chance="$DebugChance"/>

        <return value="$ResourceCost"/>
      </actions>
    </library>

    <library name="GetMostExpensiveDefinition" purpose="run_actions">
      <params>
        <param name="ViableDefs"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <debug_text text="'GetMostExpensiveDefinition called with ViableDefs ' + $ViableDefs" chance="$DebugChance"/>

        <create_list name="$MostExpensiveDef"/>
        <set_value name="$MostExpensiveDefPrice" exact="0ct"/>
        <do_for_each in="$ViableDefs" name="$Def">
          <run_actions ref="GetDefPriceCr" result="$DefPrice">
            <param name="Def" value="$Def"/>
          </run_actions>
          <do_if value="$DefPrice gt $MostExpensiveDefPrice">
            <set_value name="$SelectedDef" exact="$Def"/>
            <set_value name="$MostExpensiveDefPrice" exact="$DefPrice"/>
          </do_if>
        </do_for_each>

        <create_list name="$MostExpensiveDef"/>
        <append_to_list name="$MostExpensiveDef" exact="$SelectedDef"/>
        <append_to_list name="$MostExpensiveDef" exact="$MostExpensiveDefPrice"/>
        <return value="$MostExpensiveDef"/>
      </actions>
    </library>

    <library name="GetDefPriceCr" purpose="run_actions">
      <params>
        <param name="Def"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <debug_text text="'GetDefPriceCr called with Def ' + $Def" chance="$DebugChance"/>

        <set_value name="$DefPrice" exact="0ct"/>
        <do_if value="typeof $Def == datatype.macro">
          <set_value name="$Def" exact="$Def.ware"/>
        </do_if>
        <set_value name="$DefResourcesTable" exact="$Def.resources.table"/>
        <do_for_each in="$DefResourcesTable" name="$Resource">
          <set_value name="$DefPrice" exact="$DefPrice + $Resource.averageprice * $DefResourcesTable.{$Resource}"/>
        </do_for_each>
        <return value="$DefPrice"/>
      </actions>
    </library>

    <library name="GetMostExpensiveStoragePriceCr" purpose="run_actions">
      <params>
        <param name="StorageTag"/>
        <param name="StorageAmount"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <debug_text text="'GetMostExpensiveStoragePriceCr called with StorageTag ' + $StorageTag + ' and $StorageAmount ' + $StorageAmount" chance="$DebugChance"/>

        <get_module_definition macro="$ViableDefs" tags="[tag.storage, tag.module]" set="'factory'" multiple="true"/>
        <set_value name="$StorageAmounts" exact="table[]" comment="Create table containing a list of all modules for each storage amount."/>
        <do_for_each in="$ViableDefs" name="$Def">
          <do_if value="$Def.cargo.capacity.{$StorageTag}">
            <do_if value="@$StorageAmounts.{$Def.cargo.capacity.{$StorageTag}}.count">
              <append_to_list name="$StorageAmounts.{$Def.cargo.capacity.{$StorageTag}}" exact="$Def"/>
            </do_if>
            <do_else>
              <set_value name="$StorageAmounts.{$Def.cargo.capacity.{$StorageTag}}" exact="[$Def]"/>
            </do_else>
          </do_if>
        </do_for_each>

        <set_value name="$ViableDefs" exact="[]" comment="Create list containing the most expensive module for each storage amount."/>
        <do_for_each in="$StorageAmounts" name="$CurrentAmount" comment="Select most expensive module for each amount">
          <run_actions ref="GetMostExpensiveDefinition" result="$CurrentAmountMostExpensiveDef">
            <param name="ViableDefs" value="$StorageAmounts.{$CurrentAmount}"/>
          </run_actions>
          <append_to_list name="$ViableDefs" exact="$CurrentAmountMostExpensiveDef.{1}"/>
        </do_for_each>
        <debug_text text="'Viable storage modules, one per amount: ' + $ViableDefs" chance="$DebugChance"/>

        <sort_list list="$ViableDefs" sortbyvalue="loop.element.cargo.capacity.{$StorageTag}"/>
        <set_value name="$StorageRemaining" exact="$StorageAmount"/>
        <create_list name="$SelectedModules"/>
        <do_while value="($StorageRemaining gt 0) and $ViableDefs.count">
          <do_for_each in="$ViableDefs" name="$Def">
            <do_if value="$Def.cargo.capacity.{$StorageTag} ge $StorageRemaining">
              <append_to_list name="$SelectedModules" exact="$Def"/>
              <set_value name="$StorageRemaining" exact="$StorageRemaining - $Def.cargo.capacity.{$StorageTag}"/>
              <break/>
            </do_if>
            <do_else>
              <set_value name="$Safety" operation="add"/>
              <do_if value="$Safety ge 50">
                <break/>
              </do_if>
            </do_else>
          </do_for_each>
          <do_if value="@$Safety ge 50">
            <break/>
          </do_if>
        </do_while>

        <set_value name="$StoragePrice" exact="0ct"/>
        <do_for_each in="$SelectedModules" name="$Def">
          <run_actions ref="GetDefPriceCr" result="$DefPrice">
            <param name="Def" value="$Def"/>
          </run_actions>
          <set_value name="$StoragePrice" exact="$StoragePrice + $DefPrice"/>
        </do_for_each>

        <create_list name="$StorageModuleSetup"/>
        <append_to_list name="$StorageModuleSetup" exact="$SelectedModules"/>
        <append_to_list name="$StorageModuleSetup" exact="$StoragePrice"/>
        <return value="$StorageModuleSetup"/>
      </actions>
    </library>

    <!-- input: $TargetSector, $Faction output: $StationSpecs, $PlotOffset, $PlotRange, $PlotSize -->
    <library name="Setup_BuildMilitary">
      <actions>
        <do_if value="$TargetSector">
          <!-- try and find a location near a gate -->
          <find_object name="$Gates" class="class.gate" active="true" space="player.sector" multiple="true"/>
          <do_if value="$Gates.count">
            <set_value name="$RandomGate" exact="$Gates.random"/>
            <create_position name="$TargetOffset" space="$TargetSector" object="$RandomGate" min="10km" max="20km"/>
            <get_safe_pos result="$PlotOffset" sector="$TargetSector" x="$TargetOffset.x" y="$RandomGate.position.y" z="$TargetOffset.z" radius="10km" allowyaxis="false" max="15km"/>
          </do_if>
          <do_else>
            <create_position name="$TargetOffset" max="300km" comment="fallback"/>
            <get_safe_pos result="$PlotOffset" sector="$TargetSector" x="$TargetOffset.x" y="[-5000m, -2500m, 0m, 2500m, 5000m].random" radius="10km" allowyaxis="false" z="$TargetOffset.z" max="15km"/>
          </do_else>

          <do_any>
            <include_actions ref="Setup_Build_Station_Requirements_Defence_Platform_1" weight="65"/>
            <include_actions ref="Setup_Build_Station_Requirements_Defence_Platform_2" weight="35"/>
            <!-- The biggest defence platform is currently only used by x4ep1_war_subscriptions -->
          </do_any>

          <debug_text text="'Selected ' + $TargetSector + ' ' + $TargetSector.knownname + ' to be the sector to build the station in'" chance="$DebugChance"/>
        </do_if>
      </actions>
    </library>

    <!-- input: -; output: $StationSpecs, $PlotRange, $PlotSize; also used by x4ep1_war_subscriptions -->
    <library name="Setup_Build_Station_Requirements_Defence_Platform_1">
      <actions>
        <set_value name="$PlotRange"     exact="10km"/>
        <set_value name="$PlotSize"      exact="vector.[[4km,5km,6km].random,[4km,5km,6km].random,[4km,5km,6km].random]"/>

        <set_value name="$StationSpecs" exact="table[
              $containedclasses = [
                  [[    3].random,          class.defencemodule,   {30120,101}, {30120,102}],
                  [[    1].random,          class.dockarea,        {30120,103}, {30120,104}],
                  [[    1].random,          class.pier,            {30120,111}, {30120,112}],
                  [[    1].random,          class.radar,           {30120,113}, {30120,114}],
                  [[16,20,24,28,32].random, class.turret,          {30120,105}, {30120,106}],
                  [[4,6,8].random,          class.shieldgenerator, {30120,109}, {30120,110}],
              ],
            ]"/>
      </actions>
    </library>

    <!-- input: -; output: $StationSpecs, $PlotRange, $PlotSize; also used by x4ep1_war_subscriptions -->
    <library name="Setup_Build_Station_Requirements_Defence_Platform_2">
      <actions>
        <set_value name="$PlotRange"     exact="15km"/>
        <set_value name="$PlotSize"      exact="vector.[[5km,6km,7km].random,[5km,6km,7km].random,[5km,6km,7km].random]"/>

        <set_value name="$StationSpecs" exact="table[
              $containedclasses = [
                  [[  4,5].random,        class.defencemodule,   {30120,101}, {30120,102}],
                  [[    1].random,        class.dockarea,        {30120,103}, {30120,104}],
                  [[    1].random,        class.pier,            {30120,111}, {30120,112}],
                  [[    1].random,        class.radar,           {30120,113}, {30120,114}],
                  [[24,32,40,48].random,  class.turret,          {30120,105}, {30120,106}],
                  [[6,8,10,12,14].random, class.shieldgenerator, {30120,109}, {30120,110}],
              ],
            ]"/>
      </actions>
    </library>

    <!-- input: -; output: $StationSpecs, $PlotRange, $PlotSize; used by x4ep1_war_subscriptions -->
    <library name="Setup_Build_Station_Requirements_Defence_Platform_3">
      <actions>
        <set_value name="$PlotRange"     exact="20km"/>
        <set_value name="$PlotSize"      exact="vector.[[6km,7km,8km].random,[6km,7km,8km].random,[6km,7km,8km].random]"/>

        <set_value name="$StationSpecs" exact="table[
              $containedclasses = [
                  [[  6,7].random,           class.defencemodule,   {30120,101}, {30120,102}],
                  [[  1,2].random,           class.dockarea,        {30120,103}, {30120,104}],
                  [[  1,2].random,           class.pier,            {30120,111}, {30120,112}],
                  [[  1].random,             class.radar,           {30120,113}, {30120,114}],
                  [[20,28,36,40].random,     class.turret,          {30120,105}, {30120,106}],
                  [[20,28,36,40].random,     class.missileturret,   {30120,107}, {30120,108}],
                  [[10,16,20].random,        class.shieldgenerator, {30120,109}, {30120,110}],
              ],
            ]"/>
      </actions>
    </library>

    <!-- input: $TargetSector, $Faction output: $StationSpecs, $PlotOffset, $PlotRange, $PlotSize, might modify $TextOffset -->
    <library name="Setup_BuildFactory">
      <actions>
        <do_if value="$TargetSector">
          <!-- configure a factory -->
          <create_position name="$TargetOffset" max="300km"/>
          <get_safe_pos result="$PlotOffset" sector="$TargetSector" x="$TargetOffset.x" y="[-5000m, -2500m, 0, 2500m, 5000m].random" z="$TargetOffset.z" allowyaxis="false" includeplotbox="true" radius="25km"  max="15km" comment="not to far off y=0"/>
          <set_value name="$PlotRange"     exact="10km"/>
          <set_value name="$PlotSize"      exact="vector.[[4km,5km].random,[2km,3km,4km].random,[4km,5km,6km].random]"/>

          <!-- old version -->
          <do_any chance="0">
            <!-- energycells/ore->refined-metals -->
            <do_all comment="refined-metals">
              <!-- IMPORTANT: Do not change the do_all comment without also changing the corresponding patch code, otherwise the DLC setup variations will break -->
              <do_if value="[faction.teladi, faction.ministry].indexof.{$Faction}">
                <set_value name="$ware" exact="ware.teladianium"/>
              </do_if>
              <do_elseif value="md.$TerranFactions.indexof.{$Faction}">

              </do_elseif>
              <do_else>
                <set_value name="$ware" exact="ware.refinedmetals"/>
              </do_else>
              <do_if value="$ware?">
                <set_value name="$StationSpecs" exact="table[
                $containedclasses = [ [ 1, class.dockarea,        {30120,103}, {30120,104}] ],
                $products = [[2, $ware]],
                $containerstorage = [15000, 35000, 70000].random,
                $solidstorage = [20000, 50000, 75000].random,
                ]"/>
              </do_if>
              <set_value name="$TextOffset" exact="2200" comment="High-Quality Metal Needed"/>
            </do_all>
            <!-- energycells/graphene/teladianium|refined-metals->hullparts -->
            <do_all comment="hullparts">
              <!-- IMPORTANT: Do not change the do_all comment without also changing the corresponding patch code, otherwise the DLC setup variations will break -->
              <do_if value="md.$TerranFactions.indexof.{$Faction}">

              </do_if>
              <do_else>
                <set_value name="$ware" exact="ware.hullparts"/>
              </do_else>
              <do_if value="$ware?">
                <set_value name="$StationSpecs" exact="table[
                $containedclasses = [ [ 1, class.dockarea,        {30120,103}, {30120,104}] ],
                $products = [[1, $ware]],
                $containerstorage = [20000, 400000, 60000].random,
                ]"/>
              </do_if>
              <set_value name="$TextOffset" exact="2300" comment="Ship-Building Material Shortages"/>
            </do_all>
            <!-- energycells/helium->superfluid-coolant, energycells/methane->graphene -->
            <do_all comment="graphene">
              <!-- IMPORTANT: Do not change the do_all comment without also changing the corresponding patch code, otherwise the DLC setup variations will break -->
              <do_if value="md.$TerranFactions.indexof.{$Faction}">

              </do_if>
              <do_else>
                <set_value name="$ware1" exact="ware.graphene"/>
                <set_value name="$ware2" exact="ware.superfluidcoolant"/>
              </do_else>
              <do_if value="$ware?">
                <set_value name="$StationSpecs" exact="table[
                $containedclasses = [ [ 1, class.dockarea,        {30120,103}, {30120,104}] ],
                $products = [[1, $ware1], [1, $ware2]],
                $liquidstorage = [22000, 40000, 79000].random,
                $containerstorage = [23000, 44000, 76000].random,
                ]"/>
              </do_if>
            </do_all>
            <!-- energycells/silicon-wafers->smart-chips -->
            <do_all>
              <do_all chance="if (not md.$TerranFactions.indexof.{$Faction}) then 100 else 0" comment="Text explicitly references smart chips, which the Terrans do not produce">
                <set_value name="$StationSpecs" exact="table[
                $containedclasses = [ [ 1, class.dockarea,        {30120,103}, {30120,104}] ],
                $products = [[1, ware.smartchips]],
                $containerstorage = [9500, 28000, 37500].random,
                ]"/>
                <set_value name="$TextOffset" exact="2400" comment="Low-Grade Smart Chips Flooding the Market"/>
              </do_all>
            </do_all>
            <!-- refinedmetals/energycells/antimattercells->engineparts -->
            <do_all comment="engineparts">
              <!-- IMPORTANT: Do not change the do_all comment without also changing the corresponding patch code, otherwise the DLC setup variations will break -->
              <do_if value="md.$TerranFactions.indexof.{$Faction}">

              </do_if>
              <do_else>
                <set_value name="$ware" exact="ware.engineparts"/>
              </do_else>
              <do_if value="$ware?">
                <set_value name="$StationSpecs" exact="table[
                $containedclasses = [ [ 1, class.dockarea,        {30120,103}, {30120,104}] ],
                $products = [[1, $ware]],
                $containerstorage = [50000, 85000, 120000].random,
                ]"/>
              </do_if>
              <set_value name="$TextOffset" exact="2300" comment="Ship-Building Material Shortages"/>
            </do_all>

          </do_any>

          <!-- new version -->
          <run_actions ref="md.FactionLogic_Economy.GetProductionIssue" result="$InsufficientWares">
            <param name="Faction" value="$Faction" />
            <param name="Sector" value="$TargetSector" />
          </run_actions>
          <do_if value="$InsufficientWares.count">
            <debug_text text="'$InsufficientWares: %s'.[$InsufficientWares]" chance="$DebugChance" />
            <do_for_each name="$InsufficientWare" in="$InsufficientWares" comment="wares in descending order by $SectorValue.">
              <run_actions ref="GetIsOkToOfferMission" result="$IsOkToOffer"
                comment="returns false if there's already an offer in the sector or if the player has an active mission with the same ware. note: allows offer if the player's active mission is NOT for the same ware.">
                <param name="Faction" value="$Faction" />
                <param name="Sector" value="$TargetSector" />
                <param name="Ware" value="$InsufficientWare" />
              </run_actions>
              <debug_text text="'%s, $IsOkToOffer: %s'.[$InsufficientWare, $IsOkToOffer]" chance="$DebugChance" />
              <do_if value="$IsOkToOffer">
                <set_value name="$InsufficientWare_IsSolid" exact="$InsufficientWare.hastag.{tag.solid}" />
                <set_value name="$InsufficientWare_IsLiquid" exact="$InsufficientWare.hastag.{tag.liquid}" />
                <set_value name="$InsufficientWare_Resources" exact="$InsufficientWare.raceresources.{$Faction.primaryrace}.list" />
                <do_if value="$InsufficientWare_Resources.count">
                  <do_for_each name="$InsufficientWare_Resource" in="$InsufficientWare_Resources">
                    <set_value name="$InsufficientWare_IsSolid" exact="$InsufficientWare_Resource.hastag.{tag.solid}" />
                    <set_value name="$InsufficientWare_IsLiquid" exact="$InsufficientWare_Resource.hastag.{tag.liquid}" />
                  </do_for_each>
                </do_if>
                <set_value name="$StationSpecs" exact="table[]" />
                <set_value name="$StationSpecs.$containedclasses"   exact="[ [ 1, class.dockarea, {30120,103}, {30120,104}] ]" />
                <set_value name="$StationSpecs.$products"           exact="[[1, $InsufficientWare]]" />
                <set_value name="$StationSpecs.$containerstorage"   exact="[15000, 35000, 70000].random" />
                <do_if value="$InsufficientWare_IsSolid">
                  <set_value name="$StationSpecs.$solidstorage"     exact="[20000, 50000, 75000].random" />
                </do_if>
                <do_if value="$InsufficientWare_IsLiquid">
                  <set_value name="$StationSpecs.$liquidstorage"    exact="[22000, 40000, 79000].random" />
                </do_if>
                <do_if value="$DebugChance == 100">
                  <do_for_each name="$Prop_inTable" valuename="$Value_inTable" in="$StationSpecs">
                    <debug_text text="'%s: %s'.[$Prop_inTable, $Value_inTable]" />
                  </do_for_each>
                </do_if>
                <!-- After we evaluated what wares are needed, have a chance to change change the text offset to be more specific-->
                <set_value name="$ValidOffsets" exact="[$TextOffset]"/>
                <do_if value="$InsufficientWare == ware.refinedmetals">
                  <append_to_list name="$ValidOffsets" exact="2200" comment="High-Quality Metal Needed"/>
                </do_if>
                <do_if value="$InsufficientWare == ware.hullparts or $InsufficientWare == ware.engineparts">
                  <append_to_list name="$ValidOffsets" exact="2300" comment="Ship-Building Material Shortages"/>
                </do_if>
                <do_if value="$InsufficientWare == ware.smartchips">
                  <append_to_list name="$ValidOffsets" exact="2400" comment="Low-Grade Smart Chips Flooding the Market"/>
                </do_if>

                <!-- SelectMissionVariant library (weighted choice and $lastoffertime tracking) -->
                <run_actions ref="md.GenericMissions.SelectMissionVariant" result="$TextOffset_Table">
                  <param name="StaticGMCue"    value="md.GM_BuildStation.GenerateGenericMission"/>
                  <param name="ValidOffsets"   value="table[{30120} = $ValidOffsets]"/>
                </run_actions>
                <remove_value name="$ValidOffsets" comment="prevent accidental usage to select a different offset"/>
                <set_value name="$Page"         exact="$TextOffset_Table.keys.last"/>
                <set_value name="$TextOffset"   exact="$TextOffset_Table.{$Page}"/>

                <set_value name="$DebugChance" exact="0" />
                <break />
              </do_if>
            </do_for_each>
          </do_if>

          <do_if value="@$IsOkToOffer">
            <debug_text text="'Selected ' + $TargetSector + ' ' + $TargetSector.knownname + ' to be the sector to build the station in'" chance="$DebugChance"/>
          </do_if>
        </do_if>
      </actions>
    </library>

    <!-- input: $TargetSector, $Faction output: $StationSpecs, $PlotOffset, $PlotRange, $PlotSize -->
    <library name="Setup_BuildInstallation">
      <actions>
        <!-- use factory, for now -->
        <include_actions ref="Setup_BuildFactory"/>
      </actions>
    </library>




    <!--GENERIC MISSION VARIANTS-->

    <cue name="Force_Generic_Var_1" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <signal_cue cue="md.GenericMissions.RemoveAllOffers" />
        <do_all exact="30">
          <signal_cue_instantly cue="GenerateGenericMission" param="table[$Sector = player.sector, $MissionVariant = 1, $DebugChance = 100]"/>
        </do_all>
      </actions>
      <force name="GM_BuildStation_Var_1" />
    </cue>

    <cue name="Force_Generic_Var_2" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <signal_cue cue="md.GenericMissions.RemoveAllOffers" />
        <do_all exact="30">
          <signal_cue_instantly cue="GenerateGenericMission" param="table[$Sector = player.sector, $MissionVariant = 2, $DebugChance = 100]"/>
        </do_all>
      </actions>
      <force name="GM_BuildStation_Var_2" />
    </cue>

    <cue name="Force_Generic_Var_3" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <signal_cue cue="md.GenericMissions.RemoveAllOffers" />
        <do_all exact="30">
          <signal_cue_instantly cue="GenerateGenericMission" param="table[$Sector = player.sector, $MissionVariant = 3, $DebugChance = 100]"/>
        </do_all>
      </actions>
      <force name="GM_BuildStation_Var_3" />
    </cue>

    <!--event.param = table[
    $Sector,
    $ReportSignalCue (Optional. Cue to be signalled when something happens which could be of interest to the calling cue. Saves values to ReportSignalCue.$FeedbackValue and ReportSignalCue.$EndFeedbackValue)
    $MissionVariant (Optional),
    $RemoveOnSectorChange (Optional, defaults to true)
    $DebugChance (Optional)]-->
    <cue name="GenerateGenericMission" instantiate="true" namespace="this" version="2">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$Sector"           exact="event.param.$Sector"/>
        <set_value name="$ReportSignalCue"  exact="@event.param.$ReportSignalCue"/>
        <set_value name="$MissionVariant"   exact="@event.param.$MissionVariant"/>
        <do_if value="event.param.$RemoveOnSectorChange?">
          <set_value name="$RemoveOnSectorChange" exact="event.param.$RemoveOnSectorChange"/>
        </do_if>
        <do_else>
          <set_value name="$RemoveOnSectorChange" exact="true"/>
        </do_else>

        <set_value name="$DebugChance"      exact="@event.param.$DebugChance"/>
        <set_value name="$ReportSignalCue.$GM_Wrapper" exact="this"/>

        <set_value name="$FeedbackManager" exact="FeedbackValueManager"/>
        <assert value="$FeedbackManager.$FeedbackValues.$MISSION_NO_VARIANT?" text="'Required error code does not exist. Was the FeedbackValueManager not updated for stand-alone missions? [Owen/Roger]'"/>

        <debug_text text="'Attempting to generate a generic mission'" chance="$DebugChance"/>
      </actions>
      <patch sinceversion="2" state="complete">
        <do_if value="$ReportSignalCue.exists">
          <set_value name="$ReportSignalCue.$GM_Wrapper" exact="this"/>
        </do_if>
        <do_else>
          <debug_text text="'cancelling dead GM instance'" filter="savegame"/>
          <cancel_cue cue="this"/>
        </do_else>
      </patch>
      <cues>
        <cue name="GenerateGenericMission_SelectVariant">
          <actions>
            <set_value name="$ValidVariants" exact="[]"/>

            <!--Set up some common variables first so that the variants don't have to do things multiple times-->

            <!--Find potential offer stations in the sector-->
            <find_station name="$PotentialOfferStations" excluded="md.GenericMissions.Manager.$ExcludedOfferObjects" space="$Sector" multiple="true">
              <match owner="md.GenericMissions.Manager.$DefaultExcludedOfferFactions" negate="true"/>
              <match_relation_to object="player.entity" comparison="not" relation="killmilitary" />
            </find_station>

            <do_if value="$PotentialOfferStations.count">

              <do_if value="$MissionVariant">
                <!--A specific MissionVariant ID was requested-->
                <debug_text text="'Checking if requested ' + $MissionVariant + ' can be spawned'" chance="$DebugChance"/>
                <do_if value="$MissionVariant == 1">
                  <signal_cue_instantly cue="GenerateGenericMission_Variant_1"/>
                </do_if>
                <do_elseif value="$MissionVariant == 2">
                  <signal_cue_instantly cue="GenerateGenericMission_Variant_2"/>
                </do_elseif>
                <do_elseif value="$MissionVariant == 3">
                  <signal_cue_instantly cue="GenerateGenericMission_Variant_3"/>
                </do_elseif>
                <do_else>
                  <assert value="false" text="'Unknown $MissionVariant ID ' + $MissionVariant + ' [Owen]'"/>
                </do_else>
              </do_if>
              <do_else>
                <!--Attempt to a mission variant at random-->
                <signal_cue_instantly cue="GenerateGenericMission_Variant_1"/>
                <signal_cue_instantly cue="GenerateGenericMission_Variant_2"/>
                <signal_cue_instantly cue="GenerateGenericMission_Variant_3"/>
              </do_else>
            </do_if>

            <do_if value="$ValidVariants.count">
              <signal_cue cue="$ValidVariants.random"/>
            </do_if>
            <do_else>
              <do_if value="$ReportSignalCue">
                <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_NO_VARIANT.clone"/>
                <set_value name="$FeedbackData.$ID" exact="'$MISSION_NO_VARIANT'"/>
                <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="No mission variant possible"/>
                <signal_cue_instantly cue="$ReportSignalCue"/>
              </do_if>
              <cancel_cue cue="GenerateGenericMission"/>
            </do_else>
          </actions>
        </cue>

        <cue name="GenerateGenericMission_Variant_1" namespace="this" version="2">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <!--this uses its own namespace so grab the shared data from GenerateGenericMission-->
            <set_value name="$Sector" exact="GenerateGenericMission.$Sector"/>
            <set_value name="$DebugChance" exact="GenerateGenericMission.$DebugChance"/>
            <set_value name="$OfferStations" exact="GenerateGenericMission.$PotentialOfferStations.clone"/>
            <shuffle_list list="$OfferStations"/>

            <set_value name="$Valid" exact="false"/>
            <set_value name="$MissionLevel" exact="1"/>
            <set_value name="$Difficulty" exact="level.hard"/>
            <set_value name="$Station" exact="$OfferStations.random"/>
            <set_value name="$Faction" exact="$Station.owner"/>
            <set_value name="$TargetSector" exact="player.sector" comment="TODO: @Owen, @Roger - sensible location"/>
            <set_value name="$StationSpecs" exact="null"/>
            <set_value name="$DefenceStation" exact="$Faction.willclaimspace" comment="Only for factions which want to claim space"/>

            <!-- Select Mission Variant for page 30120 -->
            <set_value name="$ValidOffsets" exact="[1000, 1100]"/>
            <do_if value="md.$SplitPatriarchyFactions.indexof.{$Faction}">
              <append_to_list name="$ValidOffsets" exact="1500"/>
            </do_if>
            <do_if value="md.$SplitFactions.indexof.{$Faction}">
              <append_to_list name="$ValidOffsets" exact="1600"/>
            </do_if>
            <do_if value="md.$TerranEarthFactions.indexof.{$Faction}">
              <append_to_list name="$ValidOffsets" exact="1700"/>
            </do_if>

            <!-- SelectMissionVariant library (weighted choice and $lastoffertime tracking) -->
            <run_actions ref="md.GenericMissions.SelectMissionVariant" result="$TextOffset_Table">
              <param name="StaticGMCue"    value="md.GM_BuildStation.GenerateGenericMission"/>
              <param name="ValidOffsets"   value="table[{30120} = $ValidOffsets]"/>
            </run_actions>
            <remove_value name="$ValidOffsets" comment="prevent accidental usage to select a different offset"/>
            <set_value name="$Page"         exact="$TextOffset_Table.keys.last"/>
            <set_value name="$TextOffset"   exact="$TextOffset_Table.{$Page}"/>

            <include_actions ref="Setup_BuildMilitary"/>

            <do_if value="$StationSpecs">
              <set_value name="$Valid" exact="true"/>
              <run_actions ref="md.LIB_Generic.SectorDifficultyBalance" result="$Difficulty">
                <param name="MissionTargetSector" value="$TargetSector"/>
                <param name="Difficulty" value="$Difficulty"/>
              </run_actions>
            </do_if>

            <do_if value="$Valid">
              <append_to_list name="GenerateGenericMission.$ValidVariants" exact="this"/>
            </do_if>
            <do_else>
              <cancel_cue cue="this"/>
            </do_else>
          </actions>
          <patch sinceversion="2">
            <set_value name="$DefenceStation" exact="true"/>
          </patch>
          <cues>
            <cue name="GenerateGenericMission_Variant_1_Trigger">
              <conditions>
                <event_cue_signalled cue="parent"/>
              </conditions>
              <cues>
                <cue name="GenerateGenericMission_Variant_1_Ref" ref="Start">
                  <param name="OfferObject"   value="$Station"/>
                  <param name="MissionLevel"  value="$MissionLevel"/>
                  <param name="Difficulty"    value="$Difficulty"/>

                  <!--Mission offer-->
                  <param name="RemoveOnSectorChange" value="@GenerateGenericMission.$RemoveOnSectorChange"/>
                  <param name="BBSSpace" value="$Sector"/>

                  <!--Mission text-->
                  <param name="Page"              value="$Page"/>
                  <param name="TextOffset"        value="$TextOffset"/>

                  <!--Mission specific params-->
                  <param name="Faction"           value="$Faction"/>
                  <param name="PlotSector"        value="$TargetSector"/>
                  <param name="PlotOffset"        value="$PlotOffset"/>
                  <param name="PlotRange"         value="$PlotRange"/>
                  <param name="PlotSize"          value="$PlotSize"/>
                  <param name="StationSpecs"      value="$StationSpecs"/>
                  <param name="DefenceStation"    value="$DefenceStation"/>

                  <param name="ReportSignalCue"   value="@GenerateGenericMission.$ReportSignalCue"/>
                  <param name="DebugChance"       value="@GenerateGenericMission.$DebugChance"/>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="GenerateGenericMission_Variant_2" namespace="this">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <!--this uses its own namespace so grab the shared data from GenerateGenericMission-->
            <set_value name="$Sector" exact="GenerateGenericMission.$Sector"/>
            <set_value name="$DebugChance" exact="GenerateGenericMission.$DebugChance"/>
            <set_value name="$OfferStations" exact="GenerateGenericMission.$PotentialOfferStations.clone"/>
            <shuffle_list list="$OfferStations"/>

            <set_value name="$Valid" exact="false"/>
            <set_value name="$MissionLevel" exact="1"/>
            <set_value name="$Difficulty" exact="level.hard"/>
            <set_value name="$Station" exact="$OfferStations.random"/>
            <set_value name="$Faction" exact="$Station.owner"/>
            <set_value name="$TargetSector" exact="player.sector" comment="TODO: @Owen, @Roger - sensible location"/>
            <set_value name="$StationSpecs" exact="null"/>

            <!-- Select Mission Variant for page 30120 -->
            <set_value name="$ValidOffsets" exact="[2000, 2100]"/>
            <do_if value="md.$TerranFactions.count">
              <append_to_list name="$ValidOffsets" exact="2500"/>
            </do_if>

            <!-- SelectMissionVariant library (weighted choice and $lastoffertime tracking) -->
            <run_actions ref="md.GenericMissions.SelectMissionVariant" result="$TextOffset_Table">
              <param name="StaticGMCue"    value="md.GM_BuildStation.GenerateGenericMission"/>
              <param name="ValidOffsets"   value="table[{30120} = $ValidOffsets]"/>
            </run_actions>
            <remove_value name="$ValidOffsets" comment="prevent accidental usage to select a different offset"/>
            <set_value name="$Page"         exact="$TextOffset_Table.keys.last"/>
            <set_value name="$TextOffset"   exact="$TextOffset_Table.{$Page}"/>

            <!-- factory/economic style station (standalone or trade-subscription) -->
            <include_actions ref="Setup_BuildFactory"/>

            <do_if value="$StationSpecs">
              <set_value name="$Valid" exact="true"/>
              <run_actions ref="md.LIB_Generic.SectorDifficultyBalance" result="$Difficulty">
                <param name="MissionTargetSector" value="$TargetSector"/>
                <param name="Difficulty" value="$Difficulty"/>
              </run_actions>
            </do_if>

            <do_if value="$Valid">
              <append_to_list name="GenerateGenericMission.$ValidVariants" exact="this"/>
            </do_if>
            <do_else>
              <cancel_cue cue="this"/>
            </do_else>
          </actions>
          <cues>
            <cue name="GenerateGenericMission_Variant_2_Trigger">
              <conditions>
                <event_cue_signalled cue="parent"/>
              </conditions>
              <cues>
                <cue name="GenerateGenericMission_Variant_2_Ref" ref="Start">
                  <param name="OfferObject"   value="$Station"/>
                  <param name="MissionLevel"  value="$MissionLevel"/>
                  <param name="Difficulty"    value="$Difficulty"/>

                  <!--Mission offer-->
                  <param name="RemoveOnSectorChange" value="@GenerateGenericMission.$RemoveOnSectorChange"/>
                  <param name="BBSSpace" value="$Sector"/>

                  <!--Mission text-->
                  <param name="Page"              value="$Page"/>
                  <param name="TextOffset"        value="$TextOffset"/>

                  <!--Mission specific params-->
                  <param name="Faction"           value="$Faction"/>
                  <param name="PlotSector"        value="$TargetSector"/>
                  <param name="PlotOffset"        value="$PlotOffset"/>
                  <param name="PlotRange"         value="$PlotRange"/>
                  <param name="PlotSize"          value="$PlotSize"/>
                  <param name="StationSpecs"      value="$StationSpecs"/>

                  <param name="ReportSignalCue"   value="@GenerateGenericMission.$ReportSignalCue"/>
                  <param name="DebugChance"       value="@GenerateGenericMission.$DebugChance"/>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="GenerateGenericMission_Variant_3" namespace="this">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <!--this uses its own namespace so grab the shared data from GenerateGenericMission-->
            <set_value name="$Sector" exact="GenerateGenericMission.$Sector"/>
            <set_value name="$DebugChance" exact="GenerateGenericMission.$DebugChance"/>
            <set_value name="$OfferStations" exact="GenerateGenericMission.$PotentialOfferStations.clone"/>
            <shuffle_list list="$OfferStations"/>

            <set_value name="$Valid" exact="false"/>
            <set_value name="$MissionLevel" exact="1"/>
            <set_value name="$Difficulty" exact="level.hard"/>
            <set_value name="$Station" exact="$OfferStations.random"/>
            <set_value name="$Faction" exact="$Station.owner"/>
            <set_value name="$TargetSector" exact="player.sector" comment="TODO: @Owen, @Roger - sensible location"/>
            <set_value name="$StationSpecs" exact="null"/>

            <!-- Select Mission Variant for page 30120 -->
            <set_value name="$ValidOffsets" exact="[3000, 3100]"/>

            <!-- SelectMissionVariant library (weighted choice and $lastoffertime tracking) -->
            <run_actions ref="md.GenericMissions.SelectMissionVariant" result="$TextOffset_Table">
              <param name="StaticGMCue"    value="md.GM_BuildStation.GenerateGenericMission"/>
              <param name="ValidOffsets"   value="table[{30120} = $ValidOffsets]"/>
            </run_actions>
            <remove_value name="$ValidOffsets" comment="prevent accidental usage to select a different offset"/>
            <set_value name="$Page"         exact="$TextOffset_Table.keys.last"/>
            <set_value name="$TextOffset"   exact="$TextOffset_Table.{$Page}"/>

            <include_actions ref="Setup_BuildInstallation"/>

            <do_if value="$StationSpecs">
              <set_value name="$Valid" exact="true"/>
              <run_actions ref="md.LIB_Generic.SectorDifficultyBalance" result="$Difficulty">
                <param name="MissionTargetSector" value="$TargetSector"/>
                <param name="Difficulty" value="$Difficulty"/>
              </run_actions>
            </do_if>

            <do_if value="$Valid">
              <append_to_list name="GenerateGenericMission.$ValidVariants" exact="this"/>
            </do_if>
            <do_else>
              <cancel_cue cue="this"/>
            </do_else>
          </actions>
          <cues>
            <cue name="GenerateGenericMission_Variant_3_Trigger">
              <conditions>
                <event_cue_signalled cue="parent"/>
              </conditions>
              <cues>
                <cue name="GenerateGenericMission_Variant_3_Ref" ref="Start">
                  <param name="OfferObject"   value="$Station"/>
                  <param name="MissionLevel"  value="$MissionLevel"/>
                  <param name="Difficulty"    value="$Difficulty"/>

                  <!--Mission offer-->
                  <param name="RemoveOnSectorChange" value="@GenerateGenericMission.$RemoveOnSectorChange"/>
                  <param name="BBSSpace" value="$Sector"/>

                  <!--Mission text-->
                  <param name="Page"              value="$Page"/>
                  <param name="TextOffset"        value="$TextOffset"/>

                  <!--Mission specific params-->
                  <param name="Faction"           value="$Faction"/>
                  <param name="PlotSector"        value="$TargetSector"/>
                  <param name="PlotOffset"        value="$PlotOffset"/>
                  <param name="PlotRange"         value="$PlotRange"/>
                  <param name="PlotSize"          value="$PlotSize"/>
                  <param name="StationSpecs"      value="$StationSpecs"/>

                  <param name="ReportSignalCue"   value="@GenerateGenericMission.$ReportSignalCue"/>
                  <param name="DebugChance"       value="@GenerateGenericMission.$DebugChance"/>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>
      </cues>
    </cue>

    <cue name="MissionsRegistry">
      <actions>
        <set_value name="$Missions" exact="table[]" />
        <!--
          $Missions = table[
            {$Faction} = table[
              {$Sector} = table[
                {$Ware} = [(time offered), (mission cue)], ...
              ], ...
            ], ...
          ]
        -->
      </actions>
    </cue>

    <!-- register offered factory build mission -->
    <library name="RegisterMission" purpose="run_actions">
      <params>
        <param name="Faction" />
        <param name="Sector" />
        <param name="Ware" />
        <param name="Mission" />
        <param name="DebugChance" default="0" />
      </params>
      <actions>
        <!-- <set_value name="$DebugChance" exact="100" /> -->
        <run_actions ref="CleanMissionRegistry">
          <param name="Faction" value="$Faction" />
          <param name="Sector" value="$Sector" />
        </run_actions>
        <do_if value="not md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}?">
          <set_value name="md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}" exact="table[]" />
        </do_if>
        <do_if value="not md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}?">
          <set_value name="md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}" exact="table[]" />
        </do_if>
        <set_value name="md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}.{$Ware}" exact="[player.age + 2h, $Mission]" />
        <debug_text text="'%s, %s: '.[player.age, $Mission]" chance="$DebugChance" />
      </actions>
    </library>

    <!-- only offer mission if there's no mission and was not offered the last time  -->
    <library name="GetIsOkToOfferMission" purpose="run_actions">
      <params>
        <param name="Faction" />
        <param name="Sector" />
        <param name="Ware" />
        <param name="DebugChance" default="0" />
      </params>
      <actions>
        <!-- <set_value name="$DebugChance" exact="100" /> -->
        <run_actions ref="CleanMissionRegistry">
          <param name="Faction" value="$Faction" />
          <param name="Sector" value="$Sector" />
        </run_actions>
        <set_value name="$IsOk" exact="not @md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}.{$Ware}" />
        <do_if value="$DebugChance == 100">
          <set_value name="$Time_Elapsed" exact="player.age - @md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}.{$Ware}.{1}" />
          <debug_text text="'$Ware: %s, $IsOk: %s, $Time_Elapsed: %s'.[$Ware, $IsOk, $Time_Elapsed]" chance="$DebugChance" />
        </do_if>
        <return value="$IsOk" />
      </actions>
    </library>

    <!-- return mission offers in sector by faction -->
    <library name="GetMissionOffersInSector" purpose="run_actions">
      <params>
        <param name="Faction" />
        <param name="Sector" />
        <param name="DebugChance" default="0" />
      </params>
      <actions>
        <!-- <set_value name="$DebugChance" exact="100" /> -->
        <run_actions ref="CleanMissionRegistry">
          <param name="Faction" value="$Faction" />
          <param name="Sector" value="$Sector" />
        </run_actions>
        <set_value name="$MissionOffers" exact="[]" />
        <do_if value="@md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}.keys.count">
          <do_for_each name="$Ware" valuename="$MissionData" in="md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}">
            <append_to_list name="$MissionOffers" exact="$MissionData.{2}" />
          </do_for_each>
        </do_if>
        <debug_text text="'%s'.[$MissionOffers]" chance="$DebugChance" />
        <return value="$MissionOffers" />
      </actions>
    </library>

    <!-- remove missions for wares that have been offered more than 2h ago -->
    <library name="CleanMissionRegistry" purpose="run_actions">
      <params>
        <param name="Faction" />
        <param name="Sector" />
        <param name="DebugChance" default="0" />
      </params>
      <actions>
        <!-- <set_value name="$DebugChance" exact="100" /> -->
        <do_if value="$Sector">
          <set_value name="$Sectors" exact="[$Sector]" />
        </do_if>
        <do_else>
          <set_value name="$Sectors" exact="@md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.keys.list" />
        </do_else>
        <do_if value="@$Sectors.count">
          <do_for_each name="$Sector" in="$Sectors">
            <debug_text text="'mission wares for %s in %s: %s'.[$Faction, $Sector.knownname, @md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}.keys.list]" chance="$DebugChance" />
            <do_if value="md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}?">
              <do_for_each name="$Ware" valuename="$MissionData" in="md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}">
                <do_if value="(not $MissionData.{2}.exists) and player.age gt @$MissionData.{1}">
                  <remove_value name="md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}.{$Ware}" />
                </do_if>
              </do_for_each>
              <debug_text text="'mission wares for %s in %s (post-clean): %s'.[$Faction, $Sector.knownname, @md.GM_BuildStation.MissionsRegistry.$Missions.{$Faction}.{$Sector}.keys.list]" chance="$DebugChance" />
            </do_if>
          </do_for_each>
        </do_if>
      </actions>
    </library>
  </cues>
</mdscript>
