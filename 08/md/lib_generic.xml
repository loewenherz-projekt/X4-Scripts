<?xml version="1.0" encoding="utf-8"?>
<mdscript name="LIB_Generic" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">
  <cues>

    <!-- This populates $VoiceTable with generic lines. If you want specific lines for your GM variant (see examples below), set them in the variant / text offset selection.
         To change the default line for an entire GM, set it in the library "GenerateVoiceTable" in that GM, right before "GenerateGenericVoiceTable" is called.
         The GM will then call this library, which will only fill in the entries you haven't already set. -->
    <library name="GenerateGenericVoiceTable" purpose="run_actions">
      <params>
        <param name="VoiceTable"    default="table[]" comment="If $VoiceTable is NOT supplied, a new $VoiceTable will be created and returned at the end of the library actions.
                                                               If $VoiceTable is supplied, the original value will be modified, and (somewhat redundantly) also returned at the end of the library actions."/>
        <param name="Difficulty"    default="level.medium"/>
        <param name="MissionThread" default="null"/>
      </params>
      <actions>
        <set_value name="$VoiceTable.$SignalLeakVoiceLine"       exact="1000005" chance="if $VoiceTable.$SignalLeakVoiceLine? then 0 else 100"/>
        <!-- Options for $VoiceTable.$SignalLeakVoiceLine, to be set in the mission variant / text offset selection:
        <t id="1000002">(data leak signal - illegal opportunity)I'm taking a big risk by broadcasting, so if you decode this transmission, keep it to yourself. I have work that needs doing.</t>
        <t id="1000003">(data leak signal - plea for help - intense)Can anyone hear me?! Hello?! I'm not supposed to be broadcasting but I need help! Please! I need help!</t>
        <t id="1000004">(data leak signal - plea for help - intense)Can anyone hear me?! I need help! Please, if you can hear this, I need help!</t>
        <t id="1000005">(data leak signal - plea for help)Hey! I know this is unconventional, but if you can hear this, I could use some help.</t> -->

        <do_if value="$Difficulty" max="level.easy">
          <set_value name="$VoiceTable.$MissionOffer"            exact="1000102" chance="if $VoiceTable.$MissionOffer? then 0 else 100"/>
        </do_if>
        <do_elseif value="$Difficulty" min="level.hard">
          <set_value name="$VoiceTable.$MissionOffer"            exact="1000103" chance="if $VoiceTable.$MissionOffer? then 0 else 100"/>
        </do_elseif>
        <do_else>
          <set_value name="$VoiceTable.$MissionOffer"            exact="1000101" chance="if $VoiceTable.$MissionOffer? then 0 else 100"/>
        </do_else>
        <!-- Options for $VoiceTable.$MissionOffer, to be set in the mission variant / text offset selection:
        <t id="1000001">(emergency event mission offer)I could really use some help right now.</t>
        <t id="1000101">(player looks at offer - generic)Are you interested in a job?</t>
        <t id="1000102">(player looks at offer - easy difficulty)You shouldn't have any trouble with this.</t>
        <t id="1000103">(player looks at offer - hard difficulty)You'll need your wits about you for this.</t>
        <t id="1000104">(player looks at data leak mission offer - illegal opportunity)You decrypted my signal. Good.</t>
        <t id="1000105">(player looks at illegal mission offer)This could be lucrative for both of us.</t>
        <t id="1000106">(player looks at data leak mission offer - plea for help)I'm glad you found my signal.</t>
        <t id="1000107">(player looks at emergency mission offer or plea for help)I hope you can help!</t> -->

        <set_value name="$VoiceTable.$MissionOfferRepeat"        exact="1000108" chance="if $VoiceTable.$MissionOfferRepeat? then 0 else 100"/>
        <!-- Options for $VoiceTable.$MissionOfferRepeat, to be set in the mission variant / text offset selection:
        <t id="1000108">(player looks at mission offer again - generic)So you're still interested?</t>
        <t id="1000109">(player looks at mission offer again - illegal opportunity)I knew you wouldn't resist.</t>
        <t id="1000110">(player looks at mission offer again - emergency or plea for help)You came back? Does that mean you'll help?</t> -->

        <set_value name="$VoiceTable.$MissionDeclined"           exact="1000201" chance="if $VoiceTable.$MissionDeclined? then 0 else 100"/>
        <!-- Options for $VoiceTable.$MissionDeclined, to be set in the mission variant / text offset selection:
        <t id="1000201">(player declines mission offer)Come and find me if you change your mind.</t>
        <t id="1000202">(player declines mission offer - illegal opportunity)Ah... you'll be back. I'm sure.</t>
        <t id="1000203">(player declines mission offer - plea for help)What?! No! Please!</t> -->

        <set_value name="$VoiceTable.$MissionAccepted"           exact="1000204" chance="if $VoiceTable.$MissionAccepted? then 0 else 100"/>
        <!-- Options for $VoiceTable.$MissionAccepted, to be set in the mission variant / text offset selection:
        <t id="1000204">(player accepts mission offer)I knew I could count on you.</t>
        <t id="1000205">(reluctant for player to take mission - particularly hard missions, etc)Alright. If you think you can handle it.</t>
        <t id="1000206">(player accepts illegal opportunity)Smart move. Don't mess this up.</t>
        <t id="1000207">(player accepts plea for help or emergency mission offer)Thank you! Good luck!</t>
        <t id="5020">(inviting player)Come and find me.</t>
        <t id="5021">Sending you information now.</t> -->

        <set_value name="$VoiceTable.$MissionUpdate"             exact="1000301" chance="if $VoiceTable.$MissionUpdate? then 0 else 100"/>
        <!-- Options for $VoiceTable.$MissionUpdate, to be set in the mission variant / text offset selection:
        <t id="1000301">(mission update)There's been a change of plans with the job.</t> -->

        <do_if value="$MissionThread">
          <set_value name="$VoiceTable.$MissionSuccess"          exact="1000404" chance="if $VoiceTable.$MissionSuccess? then 0 else 100"/>
          <set_value name="$VoiceTable.$MissionFailed"           exact="1000405" chance="if $VoiceTable.$MissionFailed? then 0 else 100"/>
        </do_if>
        <do_else>
          <set_value name="$VoiceTable.$MissionSuccess"          exact="1000401" chance="if $VoiceTable.$MissionSuccess? then 0 else 100"/>
          <set_value name="$VoiceTable.$MissionFailed"           exact="1000403" chance="if $VoiceTable.$MissionFailed? then 0 else 100"/>
        </do_else>
        <!-- Options for $VoiceTable.$MissionSuccess and $VoiceTable.$MissionFailed, to be set in the mission variant / text offset selection:
        <t id="1000401">(successful mission)Great work.</t>
        <t id="1000403">(failed mission)I hope you don't think you're being paid for that.</t>
        <t id="1000404">(success in mission chain)We're one step closer to completion.</t>
        <t id="1000405">(failure in mission chain)That didn't go well, but we might still be able to salvage this.</t>
        <t id="2110">(standard thanks)Thank you.</t>
        <t id="2111">(really grateful)Thanks for your help.</t>
        <t id="5022">Here you go.</t> 
        <t id="5023">(reward)Here's a little something as thanks.</t>
        <t id="5024">(chosen reward)Please take one of these as thanks.</t> -->

        <set_value name="$VoiceTable.$MissionSuccessPartial"     exact="1000402" chance="if $VoiceTable.$MissionSuccessPartial? then 0 else 100"/>
        <!-- Options for $VoiceTable.$MissionSuccessPartial, to be set in the mission variant / text offset selection:
        <t id="1000402">(partial success)If that's the best you could do... sure.</t> -->

        <set_value name="$VoiceTable.$MissionAborted"            exact="1000406" chance="if $VoiceTable.$MissionAborted? then 0 else 100"/>
        <!-- Options for $VoiceTable.$MissionAborted, to be set in the mission variant / text offset selection:
        <t id="1000406">(mission aborted by NPC / script failure)Sorry. Looks like your services are no longer required.</t> -->

        <!-- Lines for encounter mission offers (feature doesn't currently exist):
        <t id="1000001">(emergency event mission offer)I could really use some help right now.</t>
        <t id="1000111">(variant)(encounter offer - illegal activity 01 - upcoming raid - call)You want to join raid? Leaving soon.</t>
        <t id="1000112">(variant)(encounter offer - illegal activity 01 - upcoming raid - response)Split come. Fight for glory. Maybe make money too.</t>
        <t id="1000113">(variant)(encounter offer - illegal activity 02 - black marketeer - call)Split want to sell stuff quick. You ready to buy?</t>
        <t id="1000114">(variant)(encounter offer - illegal activity 02 - black marketeer - response)Split buy. Meet on station, usual place.</t>
        <t id="1000115">(variant)(encounter offer - illegal activity 03 - lockbox - call)Package in lockbox. Not far. Split give you coordinates.</t>
        <t id="1000116">(variant)(encounter offer - illegal activity 03 - lockbox - response)Split collect it later.</t> -->

        <return value="$VoiceTable"/>
      </actions>
    </library>

    <library name="GenerateTextTable_BriefingWarning_Call" purpose="run_actions">
      <params>
        <param name="BriefingText"/>
        <param name="TargetSpace"/>
      </params>
      <actions>
        <do_if value="$TargetSpace.exists and $TargetSpace.accesslicence" comment="does this space require an accesslicence?">
          <do_if value="$TargetSpace.accesslicence and not (faction.player.haslicence.{$TargetSpace.accesslicence}.{$TargetSpace.owner})" comment="requires licence and player doesn't have it?">
            <set_value name="$BriefingText" exact="$BriefingText + '\n\n' + {30004,1512}"/>
          </do_if>
        </do_if>
        <do_else>
          <debug_text text="'$TargetSpace=[%s][%s] failed for briefing=[%s]'.[$TargetSpace, if $TargetSpace then $TargetSpace.knownname else '?', $BriefingText]" chance="0"/>
        </do_else>
        <return value="$BriefingText"/>
      </actions>
    </library>

    <!-- input: this.$RewardObject-list, output: this.$RewardText -->
    <library name="GenerateRewardText" purpose="run_actions">
      <params>
        <param name="RewardObject"/>
      </params>
      <actions>
        <set_value name="this.$RewardText" exact="''"/>

        <!-- multiple modparts or multiple ships? -->
        <set_value name="$modpartcount" exact="0"/>
        <set_value name="$shipcount" exact="0"/>
        <do_all exact="this.$RewardObject.count" counter="$ri">
          <do_if value="typeof this.$RewardObject.{1} == datatype.ware">
            <set_value name="$modpartcount" operation="add"/>
          </do_if>
          <do_elseif value="typeof @$Definition.$RewardObject.{1} == datatype.table">
            <do_if value="@$Definition.$RewardObject.{$ri}.$macro and @$Definition.$RewardObject.{$ri}.$loadout">
              <set_value name="$shipcount" operation="add"/>
            </do_if>
          </do_elseif>
        </do_all>

        <!-- multiple xxx reward-text -->
        <do_if value="$shipcount gt 1">
          <set_value name="this.$RewardText" exact="if this.$RewardText == '' then {30002,2002} else this.$RewardText + '\n' + {30002,2002}"/>
        </do_if>
        <do_if value="$modpartcount gt 1">
          <set_value name="this.$RewardText" exact="if this.$RewardText == '' then {30002,2001} else this.$RewardText + '\n' + {30002,2001}"/>
        </do_if>

        <!-- exact reward -->
        <do_all exact="this.$RewardObject.count" counter="$ri">
          <do_if value="typeof this.$RewardObject.{$ri} == datatype.ware">
            <do_if value="this.$RewardObject.{$ri}.ispaintmod">
              <substitute_text text="this.$RewardObjText" source="{30004,10001}" comment="Paint mod: $MODNAME$">
                <replace string="'$MODNAME$'" with="this.$RewardObject.{$ri}.name"/>
              </substitute_text>
              <set_value name="this.$RewardText" exact="if this.$RewardText == '' then this.$RewardObjText else this.$RewardText + '\n' + this.$RewardObjText"/>
            </do_if>
            <do_else>
              <set_value name="this.$RewardText" exact="if this.$RewardText == '' then this.$RewardObject.{$ri}.name else this.$RewardText + '\n' + this.$RewardObject.{$ri}.name"/>
            </do_else>
          </do_if>
          <do_elseif value="typeof this.$RewardObject.{$ri} == datatype.table">
            <do_if value="this.$RewardObject.{$ri}.$macro and this.$RewardObject.{$ri}.$loadout">
              <set_value name="$RewardShipTmp" exact="this.$RewardObject.{$ri}"/>
              <!-- shipname reward-description -->
              <set_value name="this.$RewardText" exact="if this.$RewardText == '' then this.$RewardObject.{$ri}.$macro.name else this.$RewardText + '\n' + this.$RewardObject.{$ri}.$macro.name"/>

              <!-- pilot reward-description -->
              <do_if value="$RewardShipTmp.$pilot">
                <do_if value="$RewardShipTmp.$pilot.{3} ge 12">
                  <set_value name="this.$RewardText" exact="this.$RewardText + '\n- ' + readtext.{20208}.{30101} + readtext.{1001}.{120} + ' ' + readtext.{20208}.{50601}" comment="5* elite"/>
                </do_if>
                <do_elseif value="$RewardShipTmp.$pilot.{3} ge 9">
                  <set_value name="this.$RewardText" exact="this.$RewardText + '\n- ' + readtext.{20208}.{30101} + readtext.{1001}.{120} + ' ' + readtext.{20208}.{50501}" comment="4* veteran"/>
                </do_elseif>
                <do_elseif value="$RewardShipTmp.$pilot.{3} ge 6">
                  <set_value name="this.$RewardText" exact="this.$RewardText + '\n- ' + readtext.{20208}.{30101} + readtext.{1001}.{120} + ' ' + readtext.{20208}.{50301}" comment="3* specialist"/>
                </do_elseif>
                <do_else>
                  <set_value name="this.$RewardText" exact="this.$RewardText + '\n- ' + readtext.{20208}.{30101}"/>
                </do_else>
              </do_if>

              <!-- bulk crew reward-description -->
              <do_if value="$RewardShipTmp.$bulkcrew.{2} == 'argon_military_crew' or $RewardShipTmp.$bulkcrew == 'argon_freighter_crew'">
                <set_value name="this.$RewardText" exact="this.$RewardText + '\n- ' + readtext.{20208}.{20103} + readtext.{1001}.{120} + ' ' + $RewardShipTmp.$bulkcrew.{1} + 'x ' + readtext.{20208}.{50201}"/>
              </do_if>
              <do_elseif value="$RewardShipTmp.$bulkcrew.{2} == 'argon_veteran_military_crew' or $RewardShipTmp.$bulkcrew == 'argon_veteran_freighter_crew'">
                <set_value name="this.$RewardText" exact="this.$RewardText + '\n- ' + readtext.{20208}.{20103} + readtext.{1001}.{120} + ' ' + $RewardShipTmp.$bulkcrew.{1} + 'x ' + readtext.{20208}.{50501}"/>
              </do_elseif>
              <do_elseif value="$RewardShipTmp.$bulkcrew.{2} == 'argon_elite_military_crew' or $RewardShipTmp.$bulkcrew == 'argon_elite_freighter_crew'">
                <set_value name="this.$RewardText" exact="this.$RewardText + '\n- ' + readtext.{20208}.{20103} + readtext.{1001}.{120} + ' ' + $RewardShipTmp.$bulkcrew.{1} + 'x ' + readtext.{20208}.{50601}"/>
              </do_elseif>

              <!-- cargo reward description -->
              <do_all exact="$RewardShipTmp.$cargo.count" counter="$ci" comment="display ware-reward">
                <set_value name="this.$RewardText" exact="this.$RewardText + '\n- ' + $RewardShipTmp.$cargo.{$ci}.{1} + 'x ' + $RewardShipTmp.$cargo.{$ci}.{2}"/>
              </do_all>
              <do_all exact="$RewardShipTmp.$mods.count" counter="$ci" comment="display mod-reward">
                <set_value name="this.$RewardText" exact="this.$RewardText + '\n- ' + $RewardShipTmp.$mods.{$ci}"/>
              </do_all>

              <remove_value name="$RewardShipTmp"/>
            </do_if>
          </do_elseif>
        </do_all>

        <return value="this.$RewardText"/>
      </actions>
    </library>

    <library name="GenerateWareTableRewardText" purpose="run_actions">
      <params>
        <param name="WareTable" comment="Table of wares. Key: ware, Value: amount. Paintmods allowed."/>
      </params>
      <actions>
        <set_value name="$RewardText" exact="null"/>
        <do_for_each name="$Ware" valuename="$Amount" in="$WareTable">
          <do_if value="$Ware.ispaintmod">
            <substitute_text text="$RewardWareText" source="{30004,10001}" comment="Paint mod: $MODNAME$">
              <replace string="'$MODNAME$'" with="$Ware.name"/>
            </substitute_text>
            <do_if value="$Amount gt 1">
              <set_value name="$RewardWareText" exact="$RewardWareText + ' (' + $Amount + ')'"/>
            </do_if>
          </do_if>
          <do_else>
            <substitute_text text="$RewardWareText" source="{30004,1052}">
              <replace string="'$COUNT$'" with="$Amount" />
              <replace string="'$WARENAME$'" with="$Ware.name" />
            </substitute_text>
          </do_else>
          <do_if value="$RewardText">
            <set_value name="$RewardText" exact="$RewardText + ', ' + $RewardWareText"/>
          </do_if>
          <do_else>
            <set_value name="$RewardText" exact="$RewardWareText"/>
          </do_else>
        </do_for_each>
        <return value="$RewardText"/>
      </actions>
    </library>

    <!-- input: $LevelUI; output: $FactionRelation -->
    <library name="CalculateReputation" purpose="run_actions">
      <params>
        <param name="LevelUI"/>
      </params>
      <actions>
        <!-- see https://www.egosoft.com:8444/confluence/display/X/Faction+Relations -->
        <set_value name="$FactionRelationUI"    exact="$LevelUI"/>
        <do_if value="$FactionRelationUI lt 0">
          <set_value name="$FactionRelationUI"  exact="-$FactionRelationUI"/>
        </do_if>

        <!-- calculate relation-value -->
        <do_if value="$FactionRelationUI == 25">
          <set_value name="$FactionRelation" exact="0.32"/>
        </do_if>
        <do_elseif value="$FactionRelationUI == 15">
          <set_value name="$FactionRelation" exact="0.032"/>
        </do_elseif>
        <do_elseif value="$FactionRelationUI == 5">
          <set_value name="$FactionRelation" exact="0.0032"/>
        </do_elseif>
        <do_elseif value="$FactionRelationUI lt 5">
          <set_value name="$FactionRelation" exact="$FactionRelationUI * 0.00064"/>
        </do_elseif>
        <do_else>
          <set_value name="$FactionRelation" exact="10^($FactionRelationUI/10.0)/1000.0"/>
        </do_else>

        <debug_text text="'Level: ' + $LevelUI + ' Reputation: ' + $FactionRelation" chance="$DebugChance"/>

        <return value="$FactionRelation"/>
      </actions>
    </library>

    <!-- input: $Level, $DropLevels; output: $ReputationDrop -->
    <library name="CalculateReputationDrop" purpose="run_actions">
      <params>
        <param name="Level"/>
        <param name="DropLevels"/>
      </params>
      <actions>
        <set_value name="$LevelUI"  exact="$Level"/>
        <run_actions ref="md.LIB_Generic.CalculateReputation" result="$FactionRelationNow" comment="backup, before overwrite">
          <param name="LevelUI" value="$LevelUI"/>
        </run_actions>

        <set_value name="$LevelUI"  exact="[-30, $Level - $DropLevels].max" comment="abs-clamped"/>
        <set_value name="$LevelDrop"  exact="$Level - $DropLevels"/>
        <run_actions ref="md.LIB_Generic.CalculateReputation" result="$FactionRelation">
          <param name="LevelUI" value="$LevelUI"/>
        </run_actions>

        <!-- abs difference to drop down -->
        <do_if value="$Level ge 0 and $LevelDrop lt 0">
          <set_value name="$ReputationDrop"  exact="$FactionRelationNow + $FactionRelation"/>
        </do_if>
        <do_elseif value="($FactionRelationNow - $FactionRelation) gt 0">
          <set_value name="$ReputationDrop"  exact="$FactionRelationNow - $FactionRelation"/>
        </do_elseif>
        <do_else>
          <set_value name="$ReputationDrop"  exact="$FactionRelation - $FactionRelationNow"/>
        </do_else>

        <return value="$ReputationDrop"/>
      </actions>
    </library>

    <!-- Input: $Skills (e.g. table[{skilltype.engineering} = 4, {skilltype.morale} = 3] ), output: $SkillStars (e.g. table[{skilltype.engineering} = Icons, {skilltype.morale} = Icons] )-->
    <library name="GenerateSkillStars" purpose="run_actions">
      <params>
        <param name="Skills"/>
      </params>
      <actions>
        <set_value name="$SkillStars" exact="table[]"/>

        <do_all exact="$Skills.keys.count" counter="$i">
          <set_value name="$SkillsKey" exact="$Skills.keys.{$i}"/>
          <set_value name="$SkillStars.{$SkillsKey}" exact="''"/>
          <set_value name="$SkillStarsKey" exact="$SkillStars.keys.{$i}"/>
          <!-- Full stars -->
          <set_value name="$FullStarsCounter" exact="($Skills.{$SkillsKey} / 3)i"/>
          <do_all exact="$FullStarsCounter">
            <set_value name="$SkillStars.{$SkillStarsKey}" exact="$SkillStars.{$SkillStarsKey} + '\033[menu_star_04]'"/>
          </do_all>
          <!-- 1/3 and 2/3 star -->
          <set_value name="$Frac" exact="$Skills.{$SkillsKey} % 3"/>
          <do_if value="$Frac == 1">
            <set_value name="$SkillStars.{$SkillStarsKey}" exact="$SkillStars.{$SkillStarsKey} + '\033[menu_star_02]'"/>
          </do_if>
          <do_elseif value="$Frac == 2">
            <set_value name="$SkillStars.{$SkillStarsKey}" exact="$SkillStars.{$SkillStarsKey} + '\033[menu_star_03]'"/>
          </do_elseif>
          <!-- Empty stars -->
          <set_value name="$EmptyStarsCounter" exact="0"/>
          <do_while value="($FullStarsCounter + [$Frac,1].min + $EmptyStarsCounter) lt 5">
            <set_value name="$EmptyStarsCounter" operation="add"/>
            <set_value name="$SkillStars.{$SkillStarsKey}" exact="$SkillStars.{$SkillStarsKey} + '\033[menu_star_01]'"/>
          </do_while>
        </do_all>

        <return value="$SkillStars"/>
      </actions>
    </library>

    <!--Saved to $Exlosives. Requires $SelectedTarget, $MinSpawn, $MaxSpawn, $ExplosiveOwner -->
    <library name="PlaceMinefield" purpose="run_actions" comment="Friend/Foe Mines which also track opponents in their 1000 radius up to 1500 distance">
      <params>
        <param name="SelectedTarget"/>
        <param name="MinSpawn"/>
        <param name="MaxSpawn"/>
        <param name="ExplosiveOwner"/>
        <param name="MaxDistance" default="4km"/>
      </params>
      <actions>
        <do_if value="$SelectedTarget.isclass.zone" comment="allow slight deviations since the space is contested by other faction minefields too">
          <set_value name="$Zone" exact="$SelectedTarget"/>
          <set_value name="$X" min="-15km" max="15km"/>
          <set_value name="$Y" min="-3km"  max="3km"/>
          <set_value name="$Z" min="-15km" max="15km"/>
          <set_value name="$Position" exact="position.[$X, $Y, $Z]"/>
        </do_if>
        <do_else>
          <set_value name="$Zone" exact="$SelectedTarget.zone"/>
          <create_position name="$Position" object="$SelectedTarget" space="$Zone"/>
        </do_else>
        <do_all min="$MinSpawn" max="$MaxSpawn" counter="$c">
          <do_if value="$c % 5 == 0"  comment="Increase the distance for greater minefields, + 1km every 5 mines">
            <set_value name="$MaxDistance" exact="$MaxDistance + 1km"/>
          </do_if>
          <create_object groupname="$Explosives" macro="macro.weapon_gen_mine_03_macro" zone="$Zone" owner="$ExplosiveOwner" comment="static mine with tracking and friend-foe detection">
            <safepos max="$MaxDistance" value="$Position"/>
          </create_object>
        </do_all>

        <return value="$Explosives"/>
      </actions>
    </library>

    <!--Saved to $Exlosives. Requires $SelectedTarget, $MinSpawn, $MaxSpawn, $ExplosiveOwner -->
    <library name="PlaceMinefieldIndiscriminative" purpose="run_actions" comment="Mines without FriendFoe Detection">
      <params>
        <param name="SelectedTarget"/>
        <param name="MinSpawn"/>
        <param name="MaxSpawn"/>
        <param name="ExplosiveOwner"/>
      </params>
      <actions>
        <do_if value="$SelectedTarget.isclass.zone" comment="allow slight deviations since the space is contested by other faction minefields too">
          <set_value name="$Zone" exact="$SelectedTarget"/>
          <set_value name="$X" min="-15km" max="15km"/>
          <set_value name="$Y" min="-3km"  max="3km"/>
          <set_value name="$Z" min="-15km" max="15km"/>
          <set_value name="$Position" exact="position.[$X, $Y, $Z]"/>
        </do_if>
        <do_else>
          <set_value name="$Zone" exact="$SelectedTarget.zone"/>
          <create_position name="$Position" object="$SelectedTarget" space="$Zone"/>
        </do_else>
        <do_all min="$MinSpawn" max="$MaxSpawn">
          <do_any>
            <set_value name="$MacroToSpawn" exact="macro.weapon_gen_mine_02_macro" comment="Tracking"/>
            <set_value name="$MacroToSpawn" exact="macro.weapon_gen_mine_01_macro" comment="Stationary"/>
          </do_any>
          <create_object groupname="$Explosives" macro="$MacroToSpawn" zone="$Zone" owner="$ExplosiveOwner">
            <safepos max="5km" value="$Position"/>
          </create_object>
        </do_all>

        <return value="$Explosives"/>
      </actions>
    </library>

    <!--Saved to $Exlosives. Requires $SelectedTarget, $MinSpawn, $MaxSpawn, $ExplosiveOwner -->
    <library name="PlaceRiggedAsteroids" purpose="run_actions">
      <params>
        <param name="SelectedTarget"/>
        <param name="MinSpawn"/>
        <param name="MaxSpawn"/>
        <param name="ExplosiveOwner"/>
      </params>
      <actions>
        <do_if value="$SelectedTarget.isclass.zone" comment="allow slight deviations since the space is contested by other faction minefields too">
          <set_value name="$Zone" exact="$SelectedTarget"/>
          <set_value name="$X" min="-15km" max="15km"/>
          <set_value name="$Y" min="-3km"  max="3km"/>
          <set_value name="$Z" min="-15km" max="15km"/>
          <set_value name="$Position" exact="position.[$X, $Y, $Z]"/>
        </do_if>
        <do_else>
          <set_value name="$Zone" exact="$SelectedTarget.zone"/>
          <create_position name="$Position" object="$SelectedTarget" space="$Zone"/>
        </do_else>
        <do_all min="$MinSpawn" max="$MaxSpawn">
          <create_object groupname="$Explosives" macro="macro.env_ast_ore_m_explosive_03_macro" zone="$Zone" owner="$ExplosiveOwner" comment="rigged asteroid">
            <safepos max="5km" value="$Position"/>
          </create_object>
        </do_all>

        <return value="$Explosives"/>
      </actions>
    </library>

    <!--Saved to $Exlosives. Requires $SelectedTarget, $MinSpawn, $MaxSpawn, $ExplosiveOwner -->
    <library name="PlaceLasertowerfield" purpose="run_actions">
      <params>
        <param name="SelectedTarget"/>
        <param name="MinSpawn"/>
        <param name="MaxSpawn"/>
        <param name="ExplosiveOwner"/>
      </params>
      <actions>
        <create_group groupname="$Explosives"/>

        <do_all min="$MinSpawn" max="$MaxSpawn">
          <do_any>
            <set_value name="$MacroToSpawn" exact="macro.ship_gen_s_lasertower_01_a_macro"/>
            <set_value name="$MacroToSpawn" exact="macro.ship_gen_xs_lasertower_01_a_macro"/>
          </do_any>

          <create_ship groupname="$Explosives" macro="$MacroToSpawn" zone="if $SelectedTarget.isclass.zone then $SelectedTarget else $SelectedTarget.zone">
            <owner exact="$ExplosiveOwner" overridenpc="true"/>
            <pilot>
              <select race="race.drone"/>
            </pilot>
            <safepos max="5km" object="$SelectedTarget"/>
          </create_ship>
        </do_all>

        <!--do_all exact="$Explosives.count" counter="$i">
          <set_object_foe_list object="$Explosives.{$i}" factions="[faction.player, $Faction]" comment="only works for seeker-mines"/>
        </do_all-->

        <return value="$Explosives"/>
      </actions>
    </library>

    <!-- Create a formation of ships, awaiting further orders. -->
    <library name="Spawn_Ship_Formation" purpose="run_actions">
      <params>
        <param name="Faction"/>
        <param name="MissionCue"/>
        <param name="Sector"/>
        <param name="Composition"    comment="See comment below for explanation."/>
        <param name="SpawnPosition"/>
        <param name="Assignment"     default="assignment.defence"/>
        <param name="CommanderActor" default="null"/>
        <param name="IgnoreDangerousRegions" default="false"/>
      </params>
      <actions>
        <!-- First entry is the top level commander. Further entries can be marked as sub-commanders with no amount, and are interpreted as lowest level subordinates if an amount is given.
             The following example results in a commander with 5 direct subordinates, one of which has 2 further subordinates.
                        [ [ macro.ship_arg_s_fighter_01_a_macro, 'toplevelcommander' ],
                          [ macro.ship_arg_s_fighter_01_a_macro, 4 ],
                          [ macro.ship_arg_s_fighter_01_a_macro, 'subcommander' ],
                          [ macro.ship_arg_s_fighter_01_a_macro, 2 ]
                        ] -->
        <do_for_each in="$Composition" name="$ShipDefinition" counter="$a">
          <do_all exact="if (typeof $ShipDefinition.{2}).isnumeric then $ShipDefinition.{2} else 1">
            <do_if value="($ShipDefinition.{2} == 'toplevelcommander') and $CommanderActor">
              <create_ship name="$CurrentShip" groupname="$Ships" macro="$ShipDefinition.{1}" commandeerable="false" capturable="false" missioncue="$MissionCue" sector="$Sector">
                <owner exact="$Faction" overridenpc="true"/>
                <pilot actor="$CommanderActor"/>
                <loadout>
                  <level exact="1.0"/>
                </loadout>
                <safepos value="$SpawnPosition" ignoredangerousregions="$IgnoreDangerousRegions"/>
              </create_ship>
            </do_if>
            <do_else>
              <create_ship name="$CurrentShip" groupname="$Ships" macro="$ShipDefinition.{1}" commandeerable="false" capturable="false" missioncue="$MissionCue" sector="$Sector">
                <owner exact="$Faction" overridenpc="true"/>
                <pilot>
                  <select faction="$Faction" tags="tag.fighterpilot"/>
                </pilot>
                <loadout>
                  <level exact="1.0"/>
                </loadout>
                <safepos value="$SpawnPosition" ignoredangerousregions="$IgnoreDangerousRegions"/>
              </create_ship>
            </do_else>

            <do_if value="$ShipDefinition.{2} == 'toplevelcommander'">
              <set_value name="$TopLevelCommander" exact="$CurrentShip"/>
              <set_value name="$CurrentCommander" exact="$CurrentShip"/>
              <create_order id="'Wait'" object="$CurrentShip" default="true"/>
            </do_if>
            <do_elseif value="$ShipDefinition.{2} == 'subcommander'">
              <set_value name="$CurrentCommander" exact="$CurrentShip"/>
              <create_order id="'AssignCommander'" object="$CurrentShip" immediate="true">
                <param name="commander" value="$TopLevelCommander"/>
                <param name="assignment" value="$Assignment"/>
                <param name="cancelorders" value="true"/>
              </create_order>
            </do_elseif>
            <do_else>
              <create_order id="'AssignCommander'" object="$CurrentShip" immediate="true">
                <param name="commander" value="$CurrentCommander"/>
                <param name="assignment" value="$Assignment"/>
                <param name="cancelorders" value="true"/>
              </create_order>
            </do_else>
          </do_all>
        </do_for_each>

        <set_value name="$ReturnValue" exact="[$TopLevelCommander, $Ships]"/>
        <return value="$ReturnValue"/>
      </actions>
    </library>

    <!-- Fire-and-forget a formation of attacking ships. -->
    <library name="Spawn_Attack_Wave" purpose="run_actions">
      <params>
        <param name="AttackTarget"/>
        <param name="SecondaryTargets" default="null"/>
        <param name="AdditionalTargetGroup" default="null" comment="If this is supplied, the attackers will spread out evenly and not just focus the AttackTarget."/>
        <param name="Faction"/>
        <param name="MissionCue"/>
        <param name="Sector"/>
        <param name="Composition"/>
        <param name="SpawnPosition"/>
        <param name="AllowOtherTargets"     default="true"/>
        <param name="Assignment"            default="assignment.defence"/>
        <param name="IgnoreDangerousRegions" default="false"/>
        <param name="ForcePrimaryTarget"    default="false" comment="If this is true, attacks will attack the primary target even if it's e.g. invulnerable."/>
        <param name="Disable"               default="false"/>
        <param name="DisableTargets"        default="[]"/>
        <param name="DisableHullPercentageThreshold" default="20"/>
      </params>
      <actions>
        <!-- Example of a list:
                        [ [ macro.ship_xen_s_fighter_01_a_macro, 2 ],
                          [ macro.ship_xen_s_fighter_02_a_macro, 1 ] ] -->
        <do_all exact="$Composition.count" counter="$m">
          <do_all exact="$Composition.{$m}.{2}" counter="$a">
            <create_ship name="$CurrentShip" macro="$Composition.{$m}.{1}" commandeerable="false" capturable="false" missioncue="$MissionCue" sector="$Sector">
              <owner exact="$Faction" overridenpc="true"/>
              <pilot>
                <select faction="$Faction" tags="tag.fighterpilot"/>
              </pilot>
              <loadout>
                <level exact="1.0"/>
              </loadout>
              <safepos value="$SpawnPosition" ignoredangerousregions="$IgnoreDangerousRegions"/>
            </create_ship>

            <create_order id="'Wait'" object="$CurrentShip" default="true"/>

            <do_if value="$m == 1 and $a == 1" comment="First ship in the list becomes commander.">
              <set_value name="$WaveCommander" exact="$CurrentShip"/>
              <create_position name="$AttackTargetPosition" space="$Sector" object="$AttackTarget"/>
              <create_order id="'ProtectPosition'" object="$CurrentShip" default="true">
                <param name="destination" value="[$Sector, $AttackTargetPosition]"/>
              </create_order>
              <create_order id="'Attack'" object="$CurrentShip">
                <param name="primarytarget" value="$AttackTarget"/>
                <param name="secondarytargets" value="$SecondaryTargets"/>
                <param name="pursuetargets" value="true"/>
                <param name="checkrelation" value="false"/>
                <param name="allowothertargets" value="$AllowOtherTargets"/>
                <param name="forceprimarytarget" value="$ForcePrimaryTarget"/>
                <param name="disable" value="$Disable"/>
                <param name="disabletargets" value="$DisableTargets"/>
                <param name="disablehullpercentagethreshold" value="$DisableHullPercentageThreshold"/>
              </create_order>
            </do_if>
            <do_elseif value="@$AdditionalTargetGroup.count" comment="If this is supplied, spread out.">
              <create_order id="'ProtectPosition'" object="$CurrentShip" default="true">
                <param name="destination" value="[$Sector, $AttackTargetPosition]"/>
              </create_order>
              <create_order id="'Attack'" object="$CurrentShip">
                <param name="primarytarget" value="$AdditionalTargetGroup.random"/>
                <param name="secondarytargets" value="$SecondaryTargets"/>
                <param name="pursuetargets" value="true"/>
                <param name="checkrelation" value="false"/>
                <param name="allowothertargets" value="$AllowOtherTargets"/>
                <param name="forceprimarytarget" value="$ForcePrimaryTarget"/>
              </create_order>
            </do_elseif>
            <do_else comment="Otherwise, assist the commander.">
              <create_order id="'AssignCommander'" object="$CurrentShip" immediate="true">
                <param name="commander" value="$WaveCommander"/>
                <param name="assignment" value="$Assignment"/>
                <param name="cancelorders" value="true"/>
              </create_order>
            </do_else>

            <add_to_group groupname="$Ships" object="$CurrentShip"/>
          </do_all>
        </do_all>
        <return value="$Ships"/>
      </actions>
    </library>

    <!-- Spawn a Fleet of Ships at ExitGate with a Delay between spawns to imitate ships exiting the gate -->
    <!-- It is advised to create capital ships first so they don't fight for a safe pos and get pushed about ~3km to the side
    CreateFleetAtExitGate
      - Calls CreateShipAtExitGate with delays (i.e. spawn 5 ships with 1s-5s delay inbetween spawns)
      - Calls CreateShipDelayed_SetCommander
      - Signals $SignalCue(s) with $ship as event.param
    CreateShipAtExitGate 
      - Creates the specified ships at $ExitGate
    CreateShipDelayed_SetCommander
      - If there is no commander for the ShipGroup and no ship in the CommanderGroup, puts this ship into CommanderGroup
      - Else assigns this ship as Escort to the CommanderGroup.{1} ship
     -->
    <library name="CreateFleetAtExitGate" purpose="cue_ref">
      <params>
        <param name="Amount"            />
        <param name="ExitGate"                              comment="gate at which the ship will be spawned (500m z offset)"/>
        <param name="Macro"             />
        <param name="Owner"             />
        <param name="Loadout"                               comment="can either be a string or a loadout generated in script"/>
        <param name="Drop"              default="null"/>
        <param name="People"            default="''"        comment="empty string treated as if no people node were set; will not work with person subnodes in people in create_ship"/>
        <param name="PilotTag"          default="tag.pilot" comment="some factions have specialised tags, e.g. 'elitepilot' that can be used to create specific kinds of pilots"/>
        <param name="PilotRace"         default="null"      comment="will default to $Owner.primaryrace"/>
        <param name="SignalCue"                             comment="will be signalled after each ship creation with event.param = $ship; Can be a list of cues"/>
        <param name="Assignment"        default="assignment.defence"/>
        <param name="Formation"         default="formationshape.vshape"/>
        <param name="FormationParam"    default="null"/>
        <param name="DelayInit"         default="0s"/>
        <param name="DelayMin"          default="1s"/>
        <param name="DelayMax"          default="5s"/>
        <param name="DebugChance"       default="0"/>
        <param name="CommanderGroup"    default="null"/>
      </params>
      <cues>

        <cue name="CreateFleetAtExitGate_Init">
          <actions>
            <create_group groupname="$ShipGroup"      comment="group to which all ships (including the commander) will be added"/>
            <do_if value="not $CommanderGroup">
              <create_group groupname="$CommanderGroup" comment="group to which the commander of all ships will be added, initially the first spawned ship"/>
            </do_if>

            <do_all exact="$Amount">
              <signal_cue_instantly cue="CreateShipDelayed" param="$DelayInit"/>
              <set_value name="$DelayInit" operation="add" min="$DelayMin" max="$DelayMax"/>
            </do_all>
          </actions>
        </cue>

        <cue name="CreateShipDelayed" instantiate="true">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <delay exact="event.param"/>
          <actions>
            <run_actions ref="CreateShipAtExitGate" result="$ship">
              <param name="ExitGate"  value="$ExitGate"/>
              <param name="Macro"     value="$Macro"/>
              <param name="Owner"     value="$Owner"/>
              <param name="Loadout"   value="$Loadout"/>
              <param name="Drop"      value="$Drop"/>
              <param name="People"    value="$People"/>
              <param name="PilotTag"  value="$PilotTag"/>
              <param name="PilotRace" value="$PilotRace"/>
            </run_actions>
            <add_to_group object="$ship" groupname="$ShipGroup"/>

            <run_actions ref="CreateShipDelayed_SetCommander" result="$CommanderGroup">
              <param name="Ship"              value="$ship"/>
              <param name="CommanderGroup"    value="$CommanderGroup"/>
              <param name="Assignment"        value="$Assignment"/>
              <param name="ShipGroup"         value="$ShipGroup"/>
              <param name="Formation"         value="$Formation"/>
              <param name="FormationParam"    value="$FormationParam"/>
            </run_actions>

            <set_value name="$ResultTable" exact="table[
                       $ship = $ship,
                       $ShipGroup = $ShipGroup,
                       $CommanderGroup = $CommanderGroup,
                       $ParentCue = parent,
                       $DelayInit = $DelayInit,
                       $ExitGate = $ExitGate
                       ]"/>

            <do_if value="typeof $SignalCue == datatype.cue">
              <signal_cue_instantly cue="$SignalCue" param="$ResultTable"/>
            </do_if>
            <do_elseif value="typeof $SignalCue == datatype.list">
              <do_for_each in="$SignalCue" name="$cue">
                <signal_cue_instantly cue="$cue" param="$ResultTable"/>
              </do_for_each>
            </do_elseif>

            <debug_text text="'Added to group: %s %s %s %s'.[$ship, $ship.knownname, event.param.$Group.count, event.param.$Group]" chance="$DebugChance"/>
          </actions>
        </cue>

      </cues>
    </library>

    <library name="CreateShipDelayed_SetCommander" purpose="run_actions">
      <params>
        <param name="Ship"/>
        <param name="ShipGroup"/>
        <param name="CommanderGroup"/>
        <param name="Assignment"  default="assignment.defence" comment="assignment to the group commander"/>
        <param name="Formation"/>
        <param name="FormationParam"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <!-- Find Commander; If the last one died one could be automatically assigned. -->
        <do_for_each in="$ShipGroup" name="$groupship">
          <do_if value="$groupship.commander">
            <debug_text text="'Commander Found %s'.[$groupship]" chance="$DebugChance"/>
            <add_to_group groupname="$CommanderGroup" object="$groupship.commander"/>
            <break/>
          </do_if>
        </do_for_each>
        <!-- if there is no commander, we are the commander now -->
        <do_if value="not $CommanderGroup.count">
          <debug_text text="'Commander NOT Found %s'.[$groupship]" chance="$DebugChance"/>
          <add_to_group groupname="$CommanderGroup" object="$Ship"/>
        </do_if>
        <!-- else we accept the commander -->
        <do_else>
          <create_order id="'AssignCommander'" object="$Ship" immediate="true">
            <param name="commander"     value="$CommanderGroup.{1}"/>
            <param name="assignment"    value="$Assignment"/>
            <param name="cancelorders"  value="true"/>
          </create_order>
          <create_order object="$Ship" id="'Escort'" default="true">
            <param name="formation"               value="$Formation"/>
            <param name="formationparam"          value="$FormationParam"/>
            <param name="rollformation"           value="true"/>
            <param name="overrideformationskill"  value="true"/>
          </create_order>
        </do_else>
        <return value="$CommanderGroup"/>
      </actions>
    </library>

    <library name="CreateShipAtExitGate" purpose="run_actions">
      <params>
        <param name="ExitGate"/>
        <param name="Macro"/>
        <param name="Owner"/>
        <param name="Loadout" comment="can either be a string  like 'scenario_seek_and_destroy_torpedo' or a loadout generated in script"/>
        <param name="Drop"/>
        <param name="People"            default="''"        comment="empty string treated as if no people node were set; will not work with person subnodes in people in create_ship"/>
        <param name="PilotTag"/>
        <param name="PilotRace"         default="null"      comment="will default to $Owner.primaryrace"/>
      </params>
      <actions>
        <!-- move.gate uses 5km - (this.ship.size / 2.0); we don't have $ship yet so we use ($Macro.boundingbox.max.length * 2) which is the same, but skip the *2/2 -->
        <!-- we use 500m + ship measurement to make sure they are rather close to the gate -->
        <set_value name="$ShipDistanceToGate" exact="500m + $Macro.boundingbox.max.length"/>

        <do_if value="$ExitGate.isaccelerator or $ExitGate.isclass.{class.highwayexitgate}">
          <!-- fixed rotation; fixed exit point -->
          <create_position  name="$Pos" object="$ExitGate" z="$ShipDistanceToGate" space="$ExitGate.sector"/>
          <set_value        name="$Yaw" exact="$ExitGate.rotation.yaw"/>
        </do_if>
        <do_elseif value="$ExitGate.isclass.{class.gate}">
          <!-- Jump Gate might be rotated wrongly, exit towards sector.coreposition -->
          <create_position name="$Pos1" object="$ExitGate" z="$ShipDistanceToGate"  space="$ExitGate.sector"/>
          <create_position name="$Pos2" object="$ExitGate" z="-$ShipDistanceToGate" space="$ExitGate.sector"/>
          <set_value name="$ExitGateYaw"  exact="$ExitGate.rotation.yaw"/>
          <set_value name="$CorePos"    exact="$ExitGate.sector.coreposition"/>

          <set_value name="$GateRotCorrect" exact="$CorePos.distanceto.{$Pos1} lt $CorePos.distanceto.{$Pos2}"/>

          <set_value name="$Pos" exact="if $GateRotCorrect then $Pos1 else $Pos2"/>
          <set_value name="$Yaw" exact="if $GateRotCorrect then $ExitGateYaw else ($ExitGateYaw - 180deg)"/>
        </do_elseif>
        <do_else>
          <set_value name="$HasError"/>
          <debug_text text="'No ship spawned. Only supported for Accelerators, Highwayexitgates and Jump Gates.'"/>
        </do_else>

        <set_value name="$PilotRace" exact="$Owner.primaryrace" chance="if $PilotRace then 0 else 100"/>

        <do_if value="not $HasError?">
          <do_if value="(typeof $Loadout).isstring">
            <create_ship name="$ship" macro="$Macro" sector="$ExitGate.sector"
                         commandeerable="false" capturable="false" missioncue="namespace">
              <owner exact="$Owner" overridenpc="true"/>
              <pilot>
                <select race="$PilotRace" tags="$PilotTag"/>
              </pilot>
              <loadout ref="$Loadout"/>
              <!--<drop ref="drops_scenario_satellite_basic"/>-->
              <people ref="$People"/>
              <safepos value="$Pos" ignored="$ExitGate" />
              <rotation pitch="$ExitGate.rotation.pitch" yaw="$Yaw" roll="$ExitGate.rotation.roll"/>
            </create_ship>
          </do_if>
          <do_elseif value="(typeof $Loadout).isnumeric">
            <create_ship name="$ship" macro="$Macro" sector="$ExitGate.sector"
                         commandeerable="false" capturable="false" missioncue="namespace">
              <owner exact="$Owner" overridenpc="true"/>
              <pilot>
                <select race="$PilotRace" tags="$PilotTag"/>
              </pilot>
              <loadout>
                <level exact="$Loadout"/>
              </loadout>
              <!--<drop ref="drops_scenario_satellite_basic"/>-->
              <people ref="$People"/>
              <safepos value="$Pos" ignored="$ExitGate" />
              <rotation pitch="$ExitGate.rotation.pitch" yaw="$Yaw" roll="$ExitGate.rotation.roll"/>
            </create_ship>
          </do_elseif>
          <do_else>
            <create_ship name="$ship" macro="$Macro" sector="$ExitGate.sector"
                         commandeerable="false" capturable="false" missioncue="namespace">
              <owner exact="$Owner" overridenpc="true"/>
              <pilot>
                <select race="$PilotRace" tags="$PilotTag"/>
              </pilot>
              <loadout loadout="$Loadout"/>
              <!--<drop ref="drops_scenario_satellite_basic"/>-->
              <people ref="$People"/>
              <safepos value="$Pos" ignored="$ExitGate" />
              <rotation pitch="$ExitGate.rotation.pitch" yaw="$Yaw" roll="$ExitGate.rotation.roll"/>
            </create_ship>
          </do_else>
          <do_if value="$Drop">
            <set_drop_object object="$ship" drop="$Drop"/>
          </do_if>

          <!-- Jump In Effects For Gates -->
          <do_if value="$ExitGate.isaccelerator">
            <add_effect object="$ExitGate"  effect="'jump_acceleratoreffect'"/>
          </do_if>
          <do_elseif value="$ExitGate.isclass.{class.gate}">
            <add_effect object="$ExitGate"  effect="'jump_gateeffect'"/>
          </do_elseif>

          <!-- Jump In Effects For Capital Ships -->
          <do_if value="$ship.isclass.ship_l">
            <set_value name="$jumpeffect" exact="'jump_jumpin_capship'"/>
            <set_value name="$warpeffect" exact="'warpteleport'"/>
          </do_if>
          <do_if value="$ship.isclass.ship_xl">
            <set_value name="$jumpeffect" exact="'jump_jumpin_capship_xl'"/>
            <set_value name="$warpeffect" exact="'warpteleport_xl'"/>
          </do_if>
          <do_if value="$jumpeffect?">
            <add_effect object="$ship.zone" effect="$jumpeffect">
              <position value="$ship.position"/>
              <rotation value="$ship.rotation"/>
            </add_effect>
          </do_if>
          <do_if value="$warpeffect?">
            <add_effect object="$ship" effect="$warpeffect"/>
          </do_if>

          <return value="$ship"/>
        </do_if>
        <do_else>
          <return value="null"/>
        </do_else>
      </actions>
    </library>

    <library name="SectorDifficultyBalance" purpose="run_actions">
      <params>
        <param name="Object" default="player.entity"/>
        <param name="MissionTargetSector"/>
        <param name="Difficulty"/>
      </params>
      <actions>
        <set_value name="$SectorOwnerFaction" exact="$MissionTargetSector.owner"/>
        <!-- Find all enemy factions of Object-->
        <get_factions_by_relation result="$LibEnemies" relation="killmilitary" object="$Object"/>

        <!-- Check MissionTarget Faction against list of Enemy Factions-->
        <do_if value="$LibEnemies.indexof.{$SectorOwnerFaction}">
          <do_if value="($Difficulty == level.trivial) or ($Difficulty == level.veryeasy) or ($Difficulty == level.easy)">
            <set_value name="$Difficulty" exact="level.medium"/>
          </do_if>
        </do_if>
        <return value="$Difficulty"/>
      </actions>
    </library>

    <!-- input: $Sector, output: $LocalExitPoints -->
    <library name="FindSectorExitPoints" purpose="run_actions">
      <params>
        <param name="Sector"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <!-- find exits from this sector  -->
        <find_gate name="$LocalExitPoints" active="true" space="$Sector" multiple="true"/>
        <find_highway_entry_gate name="$LocalExitPoints" superhighwaygate="true" active="true" space="$Sector" multiple="true" append="true"/>

        <debug_text text="'LocalExitPoints: ' + $LocalExitPoints" chance="$DebugChance"/>

        <return value="$LocalExitPoints"/>
      </actions>
    </library>

    <!-- input: $Sector, output: $LocalEntryPoints -->
    <library name="FindSectorEntryPoints" purpose="run_actions">
      <params>
        <param name="Sector"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <!-- find entrances into this sector  -->
        <find_gate name="$LocalEntryPoints" active="true" space="$Sector" multiple="true"/>
        <find_highway_exit_gate name="$LocalEntryPoints" superhighwaygate="true" active="true" space="$Sector" multiple="true" append="true"/>

        <debug_text text="'LocalEntryPoints' + $LocalEntryPoints" chance="$DebugChance"/>

        <return value="$LocalEntryPoints"/>
      </actions>
    </library>

    <library name="FindNearestObjectFromList" purpose="run_actions">
      <!-- Expensive DistanceTo which works with objects in different clusters -->
      <!-- INPUT:   $DistanceFrom (default: player.entity), $DistanceToList,
                    $UselocalHighways (true/false, default: false)
           OUTPUT:  $NearestObjectsList, containing $Out_ObjectsByDistance (list, possibly empty), $Out_ClosestObject (object, or null), $Lib_ObjectsWithDistance (table, can be empty) -->
      <params>
        <param name="DistanceFrom"                 default="player.entity"/>
        <param name="DistanceToList"/>
        <param name="UselocalHighways"             default="false"/>
      </params>
      <actions>
        <set_value name="$Lib_ObjectsWithDistance" exact="table[]"/>

        <do_all exact="$DistanceToList.count" counter="$s">
          <set_value name="$DistanceTo"   exact="$DistanceToList.{$s}"/>
          <get_global_path resultdistance="$DistanceTotal" component="$Path_Components" uselocalhighways="$UselocalHighways">
            <start object="$DistanceFrom"/>
            <end object="$DistanceTo"/>
          </get_global_path>
          <do_if value="$DistanceTotal ge 0" comment="ignore distances between disconnected sectors, where DistanceTotal == -1">
            <set_value name="$Lib_ObjectsWithDistance.{$DistanceTo}" exact="$DistanceTotal"/>
          </do_if>
        </do_all>
        <set_value name="$Out_ObjectsByDistance"  exact="$Lib_ObjectsWithDistance.keys.sorted" comment="possibly an empty table"/>
        <do_if value="$Lib_ObjectsWithDistance.keys.count">
          <set_value name="$Out_ClosestObject"      exact="$Out_ObjectsByDistance.{1}"/>
        </do_if>
        <do_else>
          <set_value name="$Out_ClosestObject"      exact="null"/>
        </do_else>
        <set_value name="$NearestObjectsList" exact="[$Out_ObjectsByDistance, $Out_ClosestObject, $Lib_ObjectsWithDistance]"/>

        <return value="$NearestObjectsList"/>
      </actions>
    </library>

    <!-- Returns the nearest station by distance, but using highways it might be faster to reach others
      input: $Faction 
      input optional: $TargetLocation (default: player.entity), $UselocalHighways (default: false)
      output: $SuitableStation
    -->
    <library name="FindNearestStationForFaction" purpose="run_actions">
      <params>
        <param name="Faction"/>
        <param name="TargetLocation" default="player.entity"/>
        <param name="UselocalHighways" default="false"/>
        <param name="Walkable" default="true"/>
        <param name="DockTags" default="[tag.dock_s, tag.dock_m, tag.dock_l, tag.dock_xl]" comment="Any"/>
      </params>
      <actions>
        <set_value name="$SuitableStation"    exact="null"/>
        <run_actions ref="md.LIB_Generic.FindStationsForFactionByDistance" result="$Out_StationsByDistance">
          <param name="Faction" value="$Faction"/>
          <param name="TargetLocation" value="$TargetLocation"/>
          <param name="UselocalHighways" value="$UselocalHighways"/>
          <param name="Walkable" value="$Walkable"/>
          <param name="DockTags" value="$DockTags"/>
        </run_actions>
        <do_if value="$Out_StationsByDistance.count">
          <set_value name="$SuitableStation"    exact="$Out_StationsByDistance.{1}"/>
        </do_if>

        <return value="$SuitableStation"/>
      </actions>
    </library>

    <!-- Returns statiosn by distance, but using highways it might be faster to reach others
      input: $Faction 
      input optional: $TargetLocation (default: player.entity), $UselocalHighways (default: false)
      output: $Out_StationsByDistance
    -->
    <library name="FindStationsForFactionByDistance" purpose="run_actions">
      <params>
        <param name="Faction"/>
        <param name="TargetLocation" default="player.entity"/>
        <param name="UselocalHighways" default="false"/>
        <param name="Walkable" default="true"/>
        <param name="DockTags" default="[tag.dock_s, tag.dock_m, tag.dock_l, tag.dock_xl]" comment="Any"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <set_value name="$SuitableStation"    exact="null"/>
        <set_value name="$Lib_TargetLocation" exact="if $TargetLocation? then $TargetLocation else player.entity"/>
        <set_value name="$UselocalHighways" exact="if $UselocalHighways? then $UselocalHighways else false"/>
        <set_value name="$DebugChance" exact="if $DebugChance? then $DebugChance else 0" comment="avoid errors"/>
        <set_value name="$Out_StationsByDistance" exact="table[]"/>

        <find_station_by_true_owner name="$Lib_SuitableStations" space="player.galaxy" faction="$Faction" multiple="true">
          <!-- One of those stations is the nearest -->
          <match_dock size="$DockTags" walkable="$Walkable"/>
        </find_station_by_true_owner>
        <do_if value="$Lib_SuitableStations.count">

          <!-- Populate $Lib_StationsWithDistance and sort it -->
          <set_value name="$Lib_StationsWithDistance" exact="table[]"/>
          <do_all exact="$Lib_SuitableStations.count" counter="$s">
            <set_value name="$station" exact="$Lib_SuitableStations.{$s}"/>

            <set_value name="$DistanceFrom"     exact="$Lib_TargetLocation"/>
            <set_value name="$DistanceTo"       exact="$station"/>
            <get_global_path resultdistance="$DistanceTotal" component="$Path_Components" uselocalhighways="$UselocalHighways">
              <start object="$DistanceFrom"/>
              <end object="$DistanceTo"/>
            </get_global_path>

            <do_if value="$DistanceTotal ge 0" comment="ignore distances between disconnected sectors, where DistanceTotal == -1">
              <set_value name="$Lib_StationsWithDistance.{$station}" exact="$DistanceTotal"/>
            </do_if>

          </do_all>

          <set_value name="$Out_StationsByDistance" exact="$Lib_StationsWithDistance.keys.sorted"/>
          <do_if value="$Out_StationsByDistance.count">
            <set_value name="$SuitableStation"    exact="$Out_StationsByDistance.{1}"/>
          </do_if>
          <do_else>
            <set_value name="$SuitableStation"    exact="null"/>
          </do_else>

          <remove_value name="$Lib_StationsWithDistance"/>
        </do_if>

        <return value="$Out_StationsByDistance"/>
      </actions>
    </library>

    <!-- input: $Faction, output: $NearestEnemySector -->
    <library name="FindNearestEnemySectorForFaction" purpose="run_actions">
      <params>
        <param name="Faction"/>
        <param name="Anchor" default="player.entity"/>
      </params>
      <actions>
        <!-- Find all enemy factions -->
        <get_factions_by_relation result="$Enemies" relation="enemy" faction="$Faction"/>
        <!-- Search outwards from anchor position -->
        <find_sector_in_range distances="$NearestSectors" object="$Anchor" owner="$Enemies" multiple="true"/>
        <do_if value="$NearestSectors.keys.count">
          <return value="$NearestSectors.keys.sorted.{1}"/>
        </do_if>

        <return value="null"/>
      </actions>
    </library>

    <!-- input: nothing, output: $crystalcluster -->
    <library name="FindCrystalsNearPlayer" purpose="run_actions">
      <actions>
        <create_list name="this.$Ranges"/>
        <append_to_list name="this.$Ranges" exact="[0km,5km]"/>
        <append_to_list name="this.$Ranges" exact="[5km,10km]"/>
        <append_to_list name="this.$Ranges" exact="[10km,25km]"/>

        <!-- find from nearby to further away (if nothing found nearby) -->
        <do_all exact="this.$Ranges.count" counter="$ri">
          <!--debug_text text="'searchrange min=' + this.$Ranges.{$ri}.{1} + ' max=' + this.$Ranges.{$ri}.{2}"/-->
          <find_object groupname="this.$asteroids" class="[class.asteroid]" space="player.sector" multiple="true">
            <match_distance min="this.$Ranges.{$ri}.{1}" max="this.$Ranges.{$ri}.{2}" space="player.sector" object="player.entity"/>
          </find_object>
          <!--debug_text text="this.$asteroids"/-->

          <!-- found asteroids, see if some of these have crystals -->
          <do_all exact="this.$asteroids.count" counter="$ai">
            <find_object_component groupname="$crystalcluster" object="this.$asteroids.{$ai}" class="[class.crystal]" append="true">
            </find_object_component>
            <do_if value="$crystalcluster.count gt 3">
              <break comment="break inner loop"/>
            </do_if>
          </do_all>
          <clear_group group="this.$asteroids"/>
          <do_if value="$crystalcluster.count gt 3" comment="break outer loop">
            <break/>
          </do_if>
        </do_all>

        <!-- remove down to more reasonable amount-->
        <do_while value="$crystalcluster.count gt 2">
          <remove_from_group group="$crystalcluster" object="$crystalcluster.{$crystalcluster.count}"/>
        </do_while>
        <!--debug_text text="'Crystalclusters: ' + $crystalcluster.count"/-->

        <return value="$crystalcluster"/>
      </actions>
    </library>

    <library name="GetGravidarObscuringSectorPosition" purpose="run_actions">
      <params>
        <param name="Sector"/>
        <param name="SafeposRadius" default="null"/>
        <param name="CoreSizeFactor" default="1.0f"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <set_value name="$Result" exact="null"/>
        <do_if value="$Sector.hasgravidarobscuringregion">
          <do_all exact="3">
            <create_position name="$AnchorPos" value="$Sector.coreposition" max="$Sector.coresize * $CoreSizeFactor"/>
            <find_closest_gravidar_obscuring_position sector="$Sector" result="$NearestPos">
              <position value="$AnchorPos"/>
            </find_closest_gravidar_obscuring_position>
            <do_if value="$NearestPos">
              <set_value name="$BestPos" exact="$NearestPos"/>
              <set_value name="$BestFactor" exact="$Sector.gravidarfactorat.{$NearestPos}"/>
              <do_all exact="10">
                <get_safe_pos result="$SafePos" radius="$SafeposRadius" value="$NearestPos" min="1km" max="10km" allowyaxis="false" includeplotbox="true" sector="$Sector" />
                <do_if value="$SafePos">
                  <set_value name="$Factor" exact="$Sector.gravidarfactorat.{$SafePos}"/>
                  <do_if value="$Factor lt $BestFactor">
                    <set_value name="$BestFactor" exact="$Factor"/>
                    <set_value name="$BestPos" exact="$SafePos"/>
                  </do_if>
                </do_if>
              </do_all>
              <do_if value="$BestPos and $BestFactor lt 1.0">
                <debug_text text="$Sector + ' ' + $Sector.knownname + ' - Best pos ' + $BestPos + ' factor ' + $BestFactor" chance="$DebugChance"/>
                <return value="$BestPos"/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        <return value="null"/>
      </actions>
    </library>


    <!-- Find a shipmacro which can transport the specified cargo
      input: $shipcargo = [[2500, ware.nividium]], $Faction, output: $shipmacro
    -->
    <library name="FindShipMacroForCargo" purpose="run_actions">
      <params>
        <param name="shipcargo"/>
        <param name="Faction"/>
      </params>
      <actions>
        <!-- find a ship which can transport the reward-cargo in sufficient quantities -->
        <!-- TODO: Currently only supports 1 cargo-entry, extend that -->
        <get_ship_definition macro="$shipmacros" faction="$Faction" tags="[$shipcargo.{1}.{2}.transporttag]" multiple="true"/>
        <shuffle_list list="$shipmacros" comment="randomize results"/>
        <do_all exact="$shipmacros.count" counter="$mi">
          <set_value name="$cargoware" exact="$shipcargo.{1}.{2}"/>
          <set_value name="$cargoamount" exact="$shipcargo.{1}.{1}"/>
          <do_if value="$shipmacros.{$mi}.cargo.{$cargoware}.max ge $cargoamount">
            <return value="$shipmacros.{$mi}"/>
          </do_if>
        </do_all>
        <return value="null"/>
      </actions>
    </library>

    <library name="DetermineCorridorForRoom" purpose="run_actions">
      <params>
        <param name="RoomMacro"/>
        <param name="Race"/>
      </params>
      <actions>
        <set_value name="$CorridorMacro" exact="null"/>
        <!-- Adjust this table to change the pairings. -->
        <set_value name="$CorridorTable" exact="table[ {macro.room_gen_bar_01_macro}                = [tag.entertainmentcorridor],
                                                       {macro.room_gen_common_01_macro}             = [tag.residentialcorridor],
                                                       {macro.room_gen_generator_01_macro}          = [tag.maintenancecorridor],
                                                       {macro.room_gen_livingroom_01_macro}         = [tag.residentialcorridor],
                                                       {macro.room_gen_livingroomshadyguy_01_macro} = [[tag.residentialcorridor],[tag.maintenancecorridor]].random,
                                                       {macro.room_gen_managersoffice_01_macro}     = [tag.administrationcorridor] ]"/>
        <!-- First check if a pairing is specified. -->
        <do_if value="$CorridorTable.{$RoomMacro}?">
          <get_room_definition macro="$CorridorMacro" doors="$CorridorDoors" race="$Race" tags="$CorridorTable.{$RoomMacro}"/>
        </do_if>
        <!-- If pairing is not specified or race has not corridors for the referenced tags, check if race has a generic corridor set. -->
        <do_if value="not $CorridorMacro">
          <get_room_definition macro="$CorridorMacro" doors="$CorridorDoors" race="$Race" tags="tag.genericcorridor" />
        </do_if>
        <!-- If race doesn't have a generic corridor set, pick one at random. -->
        <do_if value="not $CorridorMacro">
          <get_room_definition macro="$CorridorMacro" doors="$CorridorDoors" race="$Race" tags="tag.corridor" />
        </do_if>

        <set_value name="$CorridorDefinition" exact="[$CorridorMacro, $CorridorDoors]"/>

        <return value="$CorridorDefinition"/>
      </actions>
    </library>

    <!-- Input: $Faction, output: $EnemyFaction - finds a random (arch)enemy of the specified faction -->
    <library name="DetermineEnemyFaction" purpose="run_actions">
      <params>
        <param name="Faction"/>
        <param name="ExemptFactions" default="[]"/>
        <param name="NonHostile"     default="false" comment="Only search for non-hostile enemy factions (so up to relation -19)? For context, relation.enemy includes the following, overlapping relation ranges:
                                                              relation.enemy (-10 to -30): no docking allowed, stations don't report the player for attacking the property of the other faction.
                                                              relation.killmilitary (-20 to -30): military assets of the other faction are getting attacked.
                                                              relation.kill (-25 to -30): all assets of the other faction are getting attacked.
                                                              relation.nemesis (-30): flavour."/>
        <param name="RelationLocked" default="false" comment="Filter for factions that are relation locked? Useful if we want to create objects that the player should be able to destroy without repercussions."/>
        <param name="DebugChance"    default="0"/>
        <param name="ReturnAllEnemyFactions" default="false" comment="returns list of all found enemy factions"/>
      </params>
      <actions>
        <do_if value="$NonHostile">
          <get_factions_by_relation result="$EnemyFactions" faction="$Faction" relation="enemy"/>
        </do_if>
        <do_else>
          <get_factions_by_relation result="$EnemyFactions" faction="$Faction" relation="killmilitary"/>
        </do_else>
        <shuffle_list list="$EnemyFactions"/>
        <do_if value="$ReturnAllEnemyFactions">
          <create_list name="$ValidEnemyFactions"/>
        </do_if>
        <do_for_each name="$EnemyFaction" in="$EnemyFactions">
          <do_if value="not $EnemyFaction.isvisitor and $EnemyFaction.isactive and $ExemptFactions.indexof.{$EnemyFaction} == 0
                        and (not $RelationLocked or $EnemyFaction.isrelationlocked) and (not $NonHostile or not $EnemyFaction.hasrelation.killmilitary.{$Faction})">
            <debug_text text="'Selected ' + $EnemyFaction" chance="$DebugChance"/>
            <do_if value="$ReturnAllEnemyFactions">
              <append_to_list name="$ValidEnemyFactions" exact="$EnemyFaction"/>
            </do_if>
            <do_else>
              <return value="$EnemyFaction"/>
            </do_else>
          </do_if>
        </do_for_each>

        <do_if value="$ReturnAllEnemyFactions">
          <return value="$ValidEnemyFactions"/>
        </do_if>
        <do_else>
          <debug_text text="'No enemy faction selected!'" chance="$DebugChance"/>
          <return value="null"/>
        </do_else>
      </actions>
    </library>

    <!-- @Owen: Review whether we could use Transfer_Ownership in boarding.xml instead -->
    <!-- input: $Ship, $Faction to transfer to (see boarding.xml) -->
    <library name="TransferShipOwnership" purpose="run_actions">
      <params>
        <param name="Ship"/>
        <param name="Faction"/>
        <param name="ReleaseSubordinates" default="true"/>
        <param name="RemoveCommander" default="true"/>
      </params>
      <actions>
        <!-- Release subordinates first, so that they don't disappear from the player's property list. -->
        <do_if value="$ReleaseSubordinates">
          <do_for_each in="$Ship.subordinates" name="$Subordinate">
            <remove_object_commander object="$Subordinate"/>
          </do_for_each>
        </do_if>

        <!-- Remove commander, so that the player isn't stuck with a foreign ship in their fleet. -->
        <do_if value="$Ship.commander and $RemoveCommander">
          <remove_object_commander object="$Ship"/>
        </do_if>

        <!-- Change owner of ship. This also updated the owner of all personnel and computers on the ship and re-initialises control entities -->
        <set_owner object="$Ship" faction="$Faction"/>
        <reinitialise_control_entities object="$Ship"/>
        <cease_fire object="$Ship"/>
      </actions>
    </library>

    <!-- input: $Station, $Faction -->
    <library name="TransferStationOwnership" purpose="run_actions">
      <params>
        <param name="Station" comment="Station to transfer ownership of"/>
        <param name="Faction" comment="New owner"/>
        <param name="AddBlueprints" default="true" comment="also add the blueprints. Ownership not required, but will keep the player from being able to edit stations before disassembling unonwed modules"/>
      </params>
      <actions>
        <do_if value="$Station.isclass.station and $Station.owner != $Faction">

          <!-- notification if player was involved -->
          <do_if value="$Station.owner == faction.player or $Faction == faction.player">
            <show_notification text="[{1015,906}, '', $Station.knownname]" sound="notification_achievement" comment="station ownership transferred"/>
          </do_if>

          <!-- first release subordinates from station-control -->
          <set_value name="$Subordinates" exact="$Station.subordinates"/>
          <do_all exact="$Subordinates.count" counter="$i">
            <set_value name="$Subordinate" exact="$Subordinates.{$i}"/>
            <create_order object="$Subordinate" id="'AssignCommander'" immediate="true">
              <param name="commander" value="null" />
            </create_order>
          </do_all>
          <clear_list list="$Station.subordinates"/>

          <!-- transfer money from station back to owner (before we transfer ownership) -->
          <do_if value="$Station.money gt 0">
            <transfer_money from="$Station" to="$Station.owner" amount="$Station.money" comment="Money station has"/>
          </do_if>
          <do_if value="$Station.buildstorage.money gt 0">
            <transfer_money from="$Station.buildstorage" to="$Station.owner" amount="$Station.buildstorage.money" comment="Money for station construction"/>
          </do_if>

          <!-- If the recipient is the player, give them the required module blueprints  -->
          <do_if value="$AddBlueprints and $Faction == faction.player">
            <set_value name="$StationModules" exact="$Station.modules.all.list"/>
            <do_for_each name="$module" in="$StationModules">
              <do_if value="not player.blueprints.{$module.macro.ware}.any.exists">
                <add_blueprints macros="$module.macro"/>
              </do_if>
            </do_for_each>
          </do_if>

          <!-- transfer ownership of station itself, this also transfers ownership of all control entities and personnel and re-initialises them -->
          <set_owner object="$Station" faction="$Faction"/>
          <set_known object="$Station" known="true"/>

          <!-- check control-entities -->
          <get_control_entities object="$Station" groupname="$ControlEntities"/>
          <set_value name="$HasManager" exact="false"/>
          <set_value name="$HasShiptrader" exact="false"/>
          <do_for_each name="$ControlEntity" in="$ControlEntities">
            <do_if value="$ControlEntity.controlpost == controlpost.manager">
              <set_value name="$HasManager" exact="true"/>
            </do_if>
            <do_elseif value="$ControlEntity.controlpost == controlpost.shiptrader">
              <set_value name="$HasShiptrader" exact="true"/>
            </do_elseif>
          </do_for_each>

          <reinitialise_control_entities object="$Station"/>

          <!-- Station needs a manager to function -->
          <do_if value="not $HasManager or not $HasShiptrader">
            <signal_objects object="player.galaxy" param="'init station'" param2="$Station" param3="false"/>
          </do_if>

          <!-- set ownership of "irrelevant" station-npc's (which are currently also player-owned) -->

        </do_if>
      </actions>
    </library>

    <library name="FixFactionRepresentative" purpose="run_actions">
      <params>
        <param name="Faction"/>
      </params>
      <actions>
        <!-- support lists -->
        <do_if value="typeof $Faction != datatype.list">
          <set_value name="$FactionList" exact="[$Faction]"/>
        </do_if>
        <do_else>
          <set_value name="$FactionList" exact="$Faction"/>
        </do_else>
        <!-- fix representative -->
        <do_for_each in="$FactionList" name="$faction">
          <do_if value="not $faction.representative">
            <debug_text text="'[Heinrich] Faction Rep for %s is null. (Fix Faction Representative Lib)'.[$faction]"/>
            <continue/>
          </do_if>
          <do_if value="not $faction.headquarters">
            <debug_text text="'[Heinrich] Faction Headquarters for %s is null. (Fix Faction Representative Lib)'.[$faction]"/>
            <continue/>
          </do_if>
          <do_if value="$faction.representative.station != $faction.headquarters">
            <!-- Relocate Rep to HQ -->
            <debug_text text="'[Heinrich] Relocating Representative to %s HQ. (Fix Faction Representative Lib)'.[$faction]"/>
            <signal_cue_instantly cue="md.FactionLogic.FactionSignalled" param="[$faction, 'relocatehq']"/>
            <!-- Odd states check -->
            <do_if value="($faction.headquarters.owner != $faction)
                       or ($faction.headquarters.trueowner != $faction)">
              <debug_text text="'[Heinrich] Faction Headquarters is not owned by faction (either owner or trueowner). (Fix Faction Representative Lib)'"/>
            </do_if>
          </do_if>
        </do_for_each>
      </actions>
    </library>

    <library name="CheckStationMatches" purpose="run_actions">
      <params>
        <param name="Station"/>
        <param name="StationSpecs"/>
        <param name="DefenceStation" default="false"/>
        <param name="DebugChance"/>
      </params>
      <actions>
        <do_if value="$StationSpecs and $Station and $Station.isoperational">
          <set_value name="$stationmatches" exact="true"/>

          <do_if value="$DefenceStation and not $Station.canclaimownership">
            <set_value name="$stationmatches" exact="false"/>
          </do_if>

          <!--Check the relativly cheap storage levels before looking at the contained components-->
          <do_if value="$stationmatches and $StationSpecs.$solidstorage? and (typeof $StationSpecs.$solidstorage).isnumeric and $StationSpecs.$solidstorage gt 0">
            <debug_text text="'Checking if station has enough solid storage. Requires: ' + $StationSpecs.$solidstorage + ' - has ' + $Station.cargo.capacity.solid" chance="$DebugChance"/>
            <do_if value="$Station.cargo.capacity.solid lt $StationSpecs.$solidstorage">
              <set_value name="$stationmatches" exact="false"/>
            </do_if>
          </do_if>

          <do_if value="$stationmatches and $StationSpecs.$containerstorage? and (typeof $StationSpecs.$containerstorage).isnumeric and $StationSpecs.$containerstorage gt 0">
            <debug_text text="'Checking if station has enough container storage. Requires: ' + $StationSpecs.$containerstorage + ' - has ' + $Station.cargo.capacity.container" chance="$DebugChance"/>
            <do_if value="$Station.cargo.capacity.container lt $StationSpecs.$containerstorage">
              <set_value name="$stationmatches" exact="false"/>
            </do_if>
          </do_if>

          <do_if value="$stationmatches and $StationSpecs.$liquidstorage? and (typeof $StationSpecs.$liquidstorage).isnumeric and $StationSpecs.$liquidstorage gt 0">
            <debug_text text="'Checking if station has enough liquid storage. Requires: ' + $StationSpecs.$liquidstorage + ' - has ' + $Station.cargo.capacity.liquid" chance="$DebugChance"/>
            <do_if value="$Station.cargo.capacity.liquid lt $StationSpecs.$liquidstorage">
              <set_value name="$stationmatches" exact="false"/>
            </do_if>
          </do_if>

          <do_if value="$stationmatches and $StationSpecs.$containedmacros? and $StationSpecs.$containedmacros.count">
            <do_all exact="$StationSpecs.$containedmacros.count" counter="$gtt_i">
              <set_value name="this.$MacroDef" exact="$StationSpecs.$containedmacros.{$gtt_i}"/>
              <do_if value="this.$MacroDef.{1} gt 0" comment="Check that the definition wants a positive amount">
                <assert value="typeof this.$MacroDef.{2} == datatype.macro" text="'Invalid macro definition. ' + this.$MacroDef.{2} + ' is not a macro.'"/>
                <do_if value="typeof this.$MacroDef.{2} == datatype.macro">
                  <find_object_component name="$ResultComponents" object="$Station" macro="this.$MacroDef.{2}" multiple="true"/>
                  <debug_text text="'Checking if station has macro: ' + this.$MacroDef.{2} + '. Requires: ' + this.$MacroDef.{1} + ' - has ' + $ResultComponents.count" chance="$DebugChance"/>
                  <do_if value="$ResultComponents.count lt this.$MacroDef.{1}">
                    <set_value name="$stationmatches" exact="false"/>
                    <break/>
                  </do_if>
                </do_if>
              </do_if>
            </do_all>
          </do_if>

          <do_if value="$stationmatches and $StationSpecs.$containedclasses? and $StationSpecs.$containedclasses.count">
            <do_all exact="$StationSpecs.$containedclasses.count" counter="$gtt_i">
              <set_value name="this.$ClassDef" exact="$StationSpecs.$containedclasses.{$gtt_i}"/>
              <do_if value="this.$ClassDef.{1} gt 0" comment="Check that the definition wants a positive amount">
                <assert value="typeof this.$ClassDef.{2} == datatype.class" text="'Invalid class definition. ' + this.$ClassDef.{2} + ' is not a class.'"/>
                <do_if value="typeof this.$ClassDef.{2} == datatype.class">
                  <find_object_component name="$ResultComponents" object="$Station" class="this.$ClassDef.{2}" multiple="true"/>
                  <debug_text text="'Checking if station has class: ' + this.$ClassDef.{2} + '. Requires: ' + this.$ClassDef.{1} + ' - has ' + $ResultComponents.count" chance="$DebugChance"/>
                  <do_if value="$ResultComponents.count lt this.$ClassDef.{1}">
                    <set_value name="$stationmatches" exact="false"/>
                    <break/>
                  </do_if>
                </do_if>
              </do_if>
            </do_all>
          </do_if>

          <do_if value="$stationmatches and $StationSpecs.$products? and $StationSpecs.$products.count">
            <do_all exact="$StationSpecs.$products.count" counter="$gtt_i">
              <set_value name="this.$ProductDef" exact="$StationSpecs.$products.{$gtt_i}"/>
              <do_if value="this.$ProductDef.{1} gt 0" comment="Check that the definition wants a positive amount">
                <assert value="typeof this.$ProductDef.{2} == datatype.ware" text="'Invalid product definition. ' + this.$ProductDef.{2} + ' is not a ware.'"/>
                <do_if value="typeof this.$ProductDef.{2} == datatype.ware">
                  <find_object_component name="$ResultComponents" object="$Station" multiple="true">
                    <match_products wares="this.$ProductDef.{2}"/>
                  </find_object_component>
                  <debug_text text="'Checking if station has production: ' + this.$ProductDef.{2} + '. Requires: ' + this.$ProductDef.{1} + ' - has ' + $ResultComponents.count" chance="$DebugChance"/>
                  <do_if value="$ResultComponents.count lt this.$ProductDef.{1}">
                    <set_value name="$stationmatches" exact="false"/>
                    <break/>
                  </do_if>
                </do_if>
              </do_if>
            </do_all>
          </do_if>

          <do_if value="$stationmatches and $StationSpecs.$builtclasses? and $StationSpecs.$builtclasses.count">
            <do_all exact="$StationSpecs.$builtclasses.count" counter="$gtt_i">
              <set_value name="this.$ClassDef" exact="$StationSpecs.$builtclasses.{$gtt_i}"/>
              <do_if value="this.$ClassDef.{1} gt 0" comment="Check that the definition wants a positive amount">
                <assert value="typeof this.$ClassDef.{2} == datatype.class" text="'Invalid class definition. ' + this.$ClassDef.{2} + ' is not a class.'"/>
                <do_if value="typeof this.$ClassDef.{2} == datatype.class">
                  <find_object_component name="$ResultComponents" object="$Station" module="true" canbuildclass="this.$ClassDef.{2}" multiple="true"/>
                  <debug_text text="'Checking if station can build class: ' + this.$ClassDef.{2} + '. Requires: ' + this.$ClassDef.{1} + ' - has ' + $ResultComponents.count" chance="$DebugChance"/>
                  <do_if value="$ResultComponents.count lt this.$ClassDef.{1}">
                    <set_value name="$stationmatches" exact="false"/>
                    <break/>
                  </do_if>
                </do_if>
              </do_if>
            </do_all>
          </do_if>
        </do_if>
        <do_else>
          <set_value name="$stationmatches" exact="false" comment="missing $StationSpecs parameter or station not operational = no match"/>
        </do_else>
        <return value="$stationmatches"/>
      </actions>
    </library>

    <!--Saved to $shipmatches. Requires $currentship, $shipequip-list, $shipwares-table, $shipammo-table, $shipmods-list -->
    <library name="CheckShipMatches" purpose="run_actions">
      <params>
        <param name="currentship"/>
        <param name="shipmatches"/>
        <param name="shipequip"   default="null" comment="List or Loadout"/>
        <param name="shipwares"   default="null" comment="Table"/>
        <param name="shipammo"    default="null" comment="Table"/>
        <param name="shipmods"    default="null" comment="List"/>
        <param name="DebugChance" default="null" comment="List"/>
      </params>
      <actions>

        <!-- check equipment (engines, shield, thrusters, ...) -->
        <do_if value="$shipmatches and $shipequip">
          <do_if value="typeof $shipequip == datatype.loadout">
            <check_object object="$currentship" result="$resultval">
              <match_loadout wares="$shipequip.wares.list"/>
            </check_object>
          </do_if>
          <do_elseif value="$shipequip.count">
            <check_object object="$currentship" result="$resultval">
              <match_loadout macros="$shipequip"/>
            </check_object>
          </do_elseif>
          <do_if value="not @$resultval">
            <set_value name="$shipmatches" exact="false"/>
            <debug_text text="$currentship.knownname + ' not matching (loadout)'" chance="$DebugChance"/>
          </do_if>
        </do_if>

        <!-- check wares (energycells, ... )-->
        <do_if value="$shipmatches and @$shipwares">
          <set_value name="$shipwares_ware" exact="null"/>
          <do_all exact="$shipwares.keys.count" counter="$WareCounter">
            <set_value name="$shipwares_ware" exact="$shipwares.keys.{$WareCounter}"/>
            <do_if value="$currentship.cargo.{$shipwares_ware}.count lt $shipwares.{$shipwares_ware}">
              <set_value name="$shipmatches" exact="false"/>
              <debug_text text="'wares not matching (loadout)'" chance="$DebugChance"/>
              <break/>
            </do_if>
          </do_all>
          <remove_value name="$shipwares_ware"/>
        </do_if>

        <!-- check ammo (flares, satellites, ... )-->
        <do_if value="$shipmatches and @$shipammo">
          <set_value name="$shipammomacro" exact="null"/>
          <do_all exact="$shipammo.keys.count" counter="$AmmoCounter">
            <set_value name="$shipammomacro" exact="$shipammo.keys.{$AmmoCounter}"/>
            <do_if value="$currentship.ammostorage.{$shipammomacro}.count lt $shipammo.{$shipammomacro}">
              <set_value name="$shipmatches" exact="false"/>
              <debug_text text="'ammo not matching (loadout)'" chance="$DebugChance"/>
              <break/>
            </do_if>
          </do_all>
          <remove_value name="$shipammomacro"/>
        </do_if>

        <!-- check mods -->
        <do_if value="$shipmatches and @$shipmods">
          <do_all exact="$shipmods.count" counter="$ModCounter">
            <set_value name="$shipmods_ware" exact="$shipmods.{$ModCounter}"/>

            <debug_text text="'Checking mod ' + $shipmods_ware.name" chance="$DebugChance"/>

            <do_if value="$shipmods_ware.isequipmentmod">
              <do_if value="$shipmods_ware.isenginemod">
                <!--engine-->
                <do_if value="not $currentship.hasenginemod.{$shipmods_ware}">
                  <debug_text text="'missing enginemod: ' + $shipmods_ware" chance="$DebugChance"/>
                  <set_value name="$shipmatches" exact="false"/>
                  <break/>
                </do_if>
              </do_if>
              <do_elseif value="$shipmods_ware.isweaponmod">
                <!--weapon-->
                <do_if value="not $currentship.hasweaponmod.{$shipmods_ware}">
                  <debug_text text="'missing weaponmod: ' + $shipmods_ware" chance="$DebugChance"/>
                  <set_value name="$shipmatches" exact="false"/>
                  <break/>
                </do_if>
              </do_elseif>
              <do_elseif value="$shipmods_ware.isshipmod">
                <!--ship-->
                <do_if value="not $currentship.hasshipmod.{$shipmods_ware}">
                  <debug_text text="'missing shipmod: ' + $shipmods_ware" chance="$DebugChance"/>
                  <set_value name="$shipmatches" exact="false"/>
                  <break/>
                </do_if>
              </do_elseif>
              <do_elseif value="$shipmods_ware.isshieldmod">
                <!--shield-->
                <do_if value="not $currentship.hasshieldmod.{$shipmods_ware}">
                  <debug_text text="'missing shieldmod: ' + $shipmods_ware" chance="$DebugChance"/>
                  <set_value name="$shipmatches" exact="false"/>
                  <break/>
                </do_if>
              </do_elseif>
            </do_if>
            <do_else>
              <debug_text text="'Non-equipment-mod in equipmentmod list! (ignoring)'" chance="$DebugChance"/>
            </do_else>
          </do_all>
        </do_if>
        <return value="$shipmatches"/>
      </actions>
    </library>

    <library name="CountEmptyEquipmentSlots" purpose="run_actions">
      <params>
        <param name="Ship"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <set_value name="$EmptyWeaponSlots" exact="$Ship.weapons.numslots - $Ship.weapons.all.count"/>
        <set_value name="$EmptyTurretSlots" exact="$Ship.turrets.numslots - $Ship.turrets.all.count"/>
        <set_value name="$EmptyShieldSlots" exact="$Ship.shields.numslots - $Ship.shields.all.count"/>

        <set_value name="$EmptySlots" exact="$EmptyWeaponSlots + $EmptyTurretSlots + $EmptyShieldSlots"/>
        <debug_text text="'Empty slots on ' + $Ship.knownname + ': ' + $EmptySlots + '\nWeapons: ' + $EmptyWeaponSlots + '\nTurrets: ' + $EmptyTurretSlots + '\nShields:' + $EmptyShieldSlots" chance="$DebugChance"/>

        <return value="$EmptySlots"/>
      </actions>
    </library>
    <!--TODO @Owen Replace library with one using build plots and construction plans-->
    <!--<library name="Build_Npc_Station">
      <params>
        <param name="BuildZone" comment="zone in which to build the station"/>
        <param name="BuildPosition" comment="position to build the station (relative to buildzone)"/>
        <param name="BuildRotation" comment="rotation to build the station (relative to buildzone)"/>
        <param name="BuildMacro" comment="what station to build"/>
        <param name="BuildPlanList" comment="Buildplan"/>
        <param name="UpgradePlanList" comment="Upgradeplan (can be null)"/>
        <param name="Faction" comment="Faction for which the station is"/>
        <param name="CheatResourcesPercent" comment="Cheat resources (0=none, 100=all)"/>
        <param name="Delay" default="1s"/>
        <param name="debugchance" default="0" />
      </params>
      <delay exact="$Delay"/>
    </library>-->


    <!-- ship formation 
      - First ship in the group will be the group-leader, running the script 'leaderorder' 
      - First ship (group-leader) can have an optional leader (e.g. a station )
      - All other ships will be set to follow the group-leader, running the order 'followerorder'
      - The group will fly in the specified formation, with the specified distance 
        - some formations require different parameters, we only support 'distance' and ignore the rest
    -->
    <library name="Setup_ShipGroup_Formation_v2" purpose="run_actions">
      <params>
        <param name="group" comment="A group of ships"/>
        <param name="formation" comment="The formation we want the group to fly"/>
        <param name="formation_distance" default="null" comment="reasonable distance between ships"/>
        <param name="leaderorder" default="null" comment="order the leader of the group will execute (e.g. 'Patrol' "/>
        <param name="leadercommander" default="null" comment="optional, commander for the group-leader (e.g. a station)"/>
        <param name="followerorder" default="null" comment="order the followers in the group will execute (e.g. 'Follow') "/>
        <!--param name="leader" comment="In the future we probably want to set who is the leader"-->
      </params>
      <actions>

        <do_all exact="$group.count" counter="$fi">

          <!-- Loop over all ships in the group, 1st one will be the leader -->
          <do_if value="$fi==1" comment="formation">
            <set_value name="$TheLeader" exact="$group.{$fi}"/>

            <do_if value="$leadercommander">
              <debug_text text="'setting groupleader-commander'"/>
              <set_object_commander commander="$leadercommander" object="$TheLeader"  />
            </do_if>

          </do_if>
          <do_else>

            <!-- setup relation between groupmembers -->
            <set_object_commander commander="$TheLeader" object="$group.{$fi}"  />

            <!-- set follower script -->
            <do_if value="$followerorder">
              <create_order object="$group.{$fi}" id="$followerorder">
                <param name="target" value="$TheLeader"/>
              </create_order>
            </do_if>
          </do_else>

          <!-- set leader-order -->
          <do_if value="$leaderorder">

            <do_if value="$leaderorder" exact="'Patrol'">
              <!-- For patrol-scripts in the plot we usually want to patrol the zone (not the sector!)-->
              <create_order object="$TheLeader" id="$leaderorder" default="true">
                <param name="space" value="$TheLeader.zone"/>
              </create_order>
            </do_if>
            <do_else>
              <create_order object="$TheLeader" id="$leaderorder"/>
            </do_else>
          </do_if>

          <!-- figure out parameter for the formation-call -->
          <do_if value="$formation_distance">
            <set_value name="$dist" exact="$formation_distance"/>
          </do_if>
          <do_else>
            <set_value name="$dist" exact="$TheLeader.size"/>
          </do_else>

          <do_if value="$fi gt 1">
            <!-- formation -->
            <do_if value="$formation">
              <create_formation leader="$TheLeader" follower="$group.{$fi}" formation="formationshape.{$formation}" param="$dist"/>
            </do_if>
            <do_else>
              <debug_text text="'No ship-formation specified!'"/>
            </do_else>
          </do_if>


        </do_all>
      </actions>
    </library>

    <!-- input: $ship, sets all turrets to hold fire -->
    <library name="Setup_Ship_Turrets_HoldFire" purpose="run_actions">
      <params>
        <param name="ship"/>
      </params>
      <actions>
        <do_if value="$ship">
          <set_value name="$weapons_all" exact="$ship.turrets.operational.list"/>
          <do_all exact="$weapons_all.count" counter="$i">
            <set_weapon_mode weapon="$weapons_all.{$i}" weaponmode="weaponmode.holdfire"/>
          </do_all>
        </do_if>
      </actions>
    </library>

    <!-- input: $ship, sets all turrets to hold fire -->
    <library name="Setup_Ship_Turrets_Defend" purpose="run_actions">
      <params>
        <param name="ship"/>
      </params>
      <actions>
        <do_if value="$ship">
          <set_value name="$weapons_all" exact="$ship.turrets.operational.list"/>
          <do_all exact="$weapons_all.count" counter="$i">
            <set_weapon_mode weapon="$weapons_all.{$i}" weaponmode="weaponmode.defend"/>
          </do_all>
        </do_if>
      </actions>
    </library>

    <!-- input: $InitialMap exact=[macro.cluster_xxx_sector00x_macro, macro.cluster_yyy_sector00y_macro, ...], $UncoverShipyardsAndWharfs(optional), $UncoverTradeStations(optional), $UncoverAllStations(optional), $UncoverStationFaction(optional) -->
    <library name="UncoverMap_SectorsAndGates" purpose="run_actions">
      <params>
        <param name="InitialMap"/>
        <param name="UncoverShipyardsAndWharfs" default="null" comment="optional"/>
        <param name="UncoverTradeStations" default="null" comment="optional"/>
        <param name="UncoverAllStations" default="null" comment="optional (true to uncover in all sectors of InitialMap, or alternatively a list of sector-macro's in which to uncover all stations)"/>
        <param name="UncoverStationFaction" default="null" comment="optional"/>
        <param name="UncoverHighways" default="null" comment="optional"/>
        <param name="ExceptionList" default="[]" comment="optional, exceptions (do not uncover these stations)"/>
      </params>
      <actions>
        <find_sector name="$InitialMapSectors" macro="$InitialMap" multiple="true"/>
        <do_all exact="$InitialMapSectors.count" counter="$i">
          <set_value name="$Sector" exact="$InitialMapSectors.{$i}"/>
          <!-- sector -->
          <set_known object="$Sector" known="true"/>
          <set_known object="$Sector.cluster" known="true"/>
          <!-- gates -->
          <find_object name="$Gates" class="class.gate" space="$Sector" multiple="true"/>
          <do_for_each name="$Gate" in="$Gates">
            <do_if value="($Gate.destination) and ($InitialMapSectors.indexof.{$Gate.destination.sector})">
              <set_known object="$Gate" known="true"/>
              <!--debug_text text="'Uncovering gate %s (sector %s to %s)'.[$Gate, $Gate.sector.knownname, $Gate.destination.sector.knownname]"/-->
            </do_if>
          </do_for_each>
          <!-- super highways (treated like gates) -->
          <find_highway_entry_gate name="$SuperHighwayEntryGates" superhighwaygate="true" space="$Sector" multiple="true"/>
          <do_for_each name="$SuperHighway" in="$SuperHighwayEntryGates">
            <do_if value="($SuperHighway.destination) and ($InitialMapSectors.indexof.{$SuperHighway.destination.sector})">
              <set_known object="$SuperHighway" known="true"/>
              <set_known object="$SuperHighway.highway" known="true"/>
              <!--debug_text text="'Uncovering superhighway entry %s (sector %s to %s)'.[$SuperHighway, $SuperHighway.sector.knownname, $SuperHighway.destination.sector.knownname]"/-->
            </do_if>
          </do_for_each>
          <find_highway_exit_gate name="$SuperHighwayExitGates" superhighwaygate="true" space="$Sector" multiple="true"/>
          <do_for_each name="$SuperHighway" in="$SuperHighwayExitGates">
            <set_known object="$SuperHighway" known="true"/>
            <!--debug_text text="'Uncovering superhighway exit %s (to sector %s)'.[$SuperHighway, $SuperHighway.sector.knownname]"/-->
          </do_for_each>
          <!-- highways -->
          <do_if value="@$UncoverHighways != null">
            <find_highway name="$UncoverHighways" space="$Sector" multiple="true" excluded="$ExceptionList"/>
            <do_all exact="$UncoverHighways.count" counter="$h">
              <set_known object="$UncoverHighways.{$h}" known="true" updatesnapshot="true"/>
            </do_all>
          </do_if>
          <!-- stations -->
          <set_value name="$FactionList" exact="[]"/>
          <do_if value="@$UncoverStationFaction != null">
            <append_to_list name="$FactionList" exact="$UncoverStationFaction"/>
          </do_if>
          <do_if value="(typeof @$UncoverAllStations == datatype.integer) and (@$UncoverAllStations != null)">
            <find_station name="$UncoverStations" space="$Sector" multiple="true" owner="$FactionList" excluded="$ExceptionList"/>
          </do_if>
          <do_else>
            <do_if value="@$UncoverShipyardsAndWharfs  != null">
              <find_station name="$UncoverStations" space="$Sector" shipyard="true" owner="$FactionList" multiple="true" append="true" excluded="$ExceptionList"/>
              <find_station name="$UncoverStations" space="$Sector" wharf="true"    owner="$FactionList" multiple="true" append="true" excluded="$ExceptionList"/>
            </do_if>
            <do_if value="@$UncoverTradeStations != null">
              <find_station name="$UncoverStations" space="$Sector" tradestation="true" owner="$FactionList" multiple="true" append="true" excluded="$ExceptionList"/>
            </do_if>
          </do_else>
          <do_if value="@$UncoverStations != null">
            <do_all exact="$UncoverStations.count" counter="$us">
              <set_known object="$UncoverStations.{$us}" known="true" updatesnapshot="true"/>
            </do_all>
          </do_if>
        </do_all>

        <!-- uncover all stations, in the specified list of sectors -->
        <do_if value="(typeof @$UncoverAllStations == datatype.list)">
          <find_sector name="$UncoverAllStationsSectors" macro="$UncoverAllStations" multiple="true"/>
          <find_station name="$UncoverStations" space="$UncoverAllStationsSectors" multiple="true" owner="$FactionList" excluded="$ExceptionList"/>
          <debug_text text="'AA1 %s, %s'.[$UncoverStations.count, $UncoverStations]"/>
          <do_all exact="$UncoverStations.count" counter="$us">
            <set_known object="$UncoverStations.{$us}" known="true" updatesnapshot="true"/>
          </do_all>
        </do_if>

      </actions>
    </library>

    <library name="ApproachObject_Handler" version="5">
      <!-- IN: $ApproachTarget, $ApproachDistance, $SuccessSignalCue (will be signalled on successful approach) -->
      <params>
        <param name="ApproachObject" default="player.entity"/>
        <param name="ApproachTarget"/>
        <param name="ApproachDistance" default="5km"/>
        <param name="HighPriorityTiming" default="false"/>
        <param name="SuccessSignalCue"/>
        <param name="FailureSignalCue" default="null"/>
        <param name="Invert" default="false" comment="Revert the Distance Check to signal Success when $ApproachObject is outside the $ApproachDistance"/>
        <param name="CancelOnSuccess" default="true" comment="Cancel cue on Success condition, when using 'false' the caller is responsible for cancelling when it's not needed anymore AND the SuccessSignalCue needs to be instantiated since it will be called multiple times!"/>
      </params>
      <actions>
        <do_if value="not $ApproachObject.exists or not $ApproachTarget.exists">
          <do_if value="$FailureSignalCue">
            <signal_cue cue="$FailureSignalCue"/>
          </do_if>
          <cancel_cue cue="ApproachObject_Handler"/>
        </do_if>
      </actions>
      <patch sinceversion="2" state="complete">
        <do_if value="ApproachObject_Success.state == cuestate.complete or ApproachObject_Failed.state == cuestate.complete">
          <debug_text text="'Cancelling active library which had already resolved'" filter="savegame"/>
          <cancel_cue cue="ApproachObject_Handler"/>
        </do_if>
        <do_elseif value="not $ApproachObject.exists or not $ApproachTarget.exists">
          <do_if value="$FailureSignalCue">
            <signal_cue cue="$FailureSignalCue"/>
          </do_if>
          <debug_text text="'Cancelling active library where an object is no longer valid'" filter="savegame"/>
          <cancel_cue cue="ApproachObject_Handler"/>
        </do_elseif>
      </patch>
      <patch sinceversion="3">
        <set_value name="$Invert" exact="false"/>
      </patch>
      <patch sinceversion="4">
        <set_value name="$CancelOnSuccess" exact="true"/>
      </patch>
      <patch sinceversion="5">
        <set_value name="$HighPriorityTiming" exact="false"/>
      </patch>
      <cues>
        <cue name="ApproachObject_Failed">
          <conditions>
            <check_any>
              <event_object_destroyed object="$ApproachObject"/>
              <event_object_destroyed object="$ApproachTarget"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="$FailureSignalCue">
              <signal_cue cue="$FailureSignalCue"/>
            </do_if>
            <cancel_cue cue="ApproachObject_Handler"/>
          </actions>
        </cue>

        <cue name="Approach_ObjectPriorityDefault" onfail="cancel">
          <conditions>
            <check_value value="not $HighPriorityTiming"/>
          </conditions>
          <cues>

            <cue name="ApproachObject_Success_V3" checkinterval="3s" instantiate="true">
              <conditions>
                <check_all>
                  <check_value value="$ApproachObject.sector.exists and $ApproachTarget.exists"/>
                  <check_any>
                    <!-- Approach Condition, true when within $ApproachDistance -->
                    <check_all>
                      <check_value value="$ApproachObject.sector == $ApproachTarget.sector"/>
                      <check_value value="$ApproachObject.distanceto.{$ApproachTarget}" max="$ApproachDistance"/>
                      <check_value value="not $Invert"/>
                    </check_all>
                    <!-- Diverge Condition, true when outside $ApproachDistance -->
                    <check_all>
                      <check_value value="$Invert"/>
                      <check_any>
                        <check_value value="$ApproachObject.sector != $ApproachTarget.sector"/>
                        <check_value value="$ApproachObject.distanceto.{$ApproachTarget}" min="$ApproachDistance"/>
                      </check_any>
                    </check_all>
                  </check_any>
                </check_all>
              </conditions>
              <actions>
                <signal_cue_instantly cue="$SuccessSignalCue" param="$ApproachTarget"/>
                <do_if value="$CancelOnSuccess">
                  <cancel_cue cue="ApproachObject_Handler"/>
                </do_if>
              </actions>
            </cue>

          </cues>
        </cue>


        <cue name="Approach_ObjectPriorityHighPriority" onfail="cancel">
          <conditions>
            <check_value value="$HighPriorityTiming"/>
          </conditions>
          <cues>

            <cue name="ApproachObject_Success_HighPriority" checkinterval="100ms" instantiate="true">
              <conditions>
                <check_all>
                  <check_value value="$ApproachObject.sector.exists and $ApproachTarget.exists"/>
                  <check_any>
                    <!-- Approach Condition, true when within $ApproachDistance -->
                    <check_all>
                      <check_value value="$ApproachObject.sector == $ApproachTarget.sector"/>
                      <check_value value="$ApproachObject.distanceto.{$ApproachTarget}" max="$ApproachDistance"/>
                      <check_value value="not $Invert"/>
                    </check_all>
                    <!-- Diverge Condition, true when outside $ApproachDistance -->
                    <check_all>
                      <check_value value="$Invert"/>
                      <check_any>
                        <check_value value="$ApproachObject.sector != $ApproachTarget.sector"/>
                        <check_value value="$ApproachObject.distanceto.{$ApproachTarget}" min="$ApproachDistance"/>
                      </check_any>
                    </check_all>
                  </check_any>
                </check_all>
              </conditions>
              <actions>
                <signal_cue_instantly cue="$SuccessSignalCue" param="$ApproachTarget"/>
                <do_if value="$CancelOnSuccess">
                  <cancel_cue cue="ApproachObject_Handler"/>
                </do_if>
              </actions>
            </cue>

          </cues>
        </cue>

        <!--DEPRECATED CUES-->
        <cue name="ApproachObject_Activate_Trigger">
          <conditions>
            <check_any>
              <!--<event_object_changed_sector object="$ApproachObject" sector="$ApproachTarget.sector"/>
              <event_object_changed_sector object="$ApproachTarget" sector="$ApproachObject.sector"/>-->
              <event_cue_signalled/>
            </check_any>
          </conditions>
          <cues>

            <!--We will check the state of this cue to see if the library should be cleaned up or not by a patch-->
            <cue name="ApproachObject_Success" checkinterval="3s">
              <conditions>
                <check_all>
                  <check_value value="false"/>
                  <check_value value="$ApproachObject.exists"/>
                  <check_value value="$ApproachObject.distanceto.{$ApproachTarget}" max="$ApproachDistance"/>
                  <check_value value="$ApproachObject.sector == $ApproachTarget.sector"/>
                </check_all>
              </conditions>
              <actions>
                <signal_cue_instantly cue="$SuccessSignalCue" param="$ApproachTarget"/>
                <cancel_cue cue="parent"/>
              </actions>
            </cue>

          </cues>
        </cue>
        <!--DEPRECATED CUES END-->

      </cues>
    </library>

    <!-- Approach specified sector/position (todo: and stay inside for specified time, so you can't quickly boost through the area) -->
    <library name="ApproachLocation_Handler" version="2">
      <!-- IN: $ApproachObject, $ApproachSector, $ApproachOffset, $ApproachDistance, $SuccessSignalCue (will be signalled on successful approach) -->
      <params>
        <param name="ApproachObject" default="player.entity" comment="object we require to be within [ApproachSector,ApproachOffset]"/>
        <param name="ApproachSector"/>
        <param name="ApproachOffset"/>
        <param name="ApproachDistance" default="5km"/>
        <!--param name="ApproachDuration" default="5s"/-->
        <param name="SuccessSignalCue"/>
        <param name="Invert" default="false" comment="Revert the Distance Check to signal Success when $ApproachObject is outside the $ApproachDistance"/>
      </params>
      <patch sinceversion="2">
        <set_value name="$Invert" exact="false"/>
      </patch>
      <cues>

        <cue name="ApproachLocation_Initialise">
          <actions>
            <debug_text text="this" chance="if $CueDebugChance? then $CueDebugChance else 0"/>
            <do_if value="$ApproachObject.sector == $ApproachSector">
              <signal_cue cue="ApproachLocation_Activate_Trigger"/>
            </do_if>
          </actions>
        </cue>

        <cue name="ApproachLocation_Activate_Trigger">
          <conditions>
            <check_any>
              <event_object_changed_sector object="$ApproachObject" sector="$ApproachSector"/>
              <event_cue_signalled/>
            </check_any>
          </conditions>
          <cues>

            <cue name="ApproachLocation_Deactivate_Trigger">
              <conditions>
                <event_object_changed_sector object="$ApproachObject" previous="$ApproachSector"/>
              </conditions>
              <actions>
                <reset_cue cue="ApproachLocation_Activate_Trigger"/>
              </actions>
            </cue>

            <cue name="ApproachLocation_Success" checkinterval="3s">
              <conditions>
                <check_all>
                  <check_value value="($ApproachObject.exists) and ($ApproachObject.sector == $ApproachSector)"/>
                  <check_any>
                    <!-- Approach Condition, true when within $ApproachDistance -->
                    <check_all>
                      <check_value value="$ApproachObject.distanceto.[$ApproachSector, $ApproachOffset]" max="$ApproachDistance"/>
                      <check_value value="not $Invert"/>
                    </check_all>
                    <!-- Approach Condition, true when outside $ApproachDistance -->
                    <check_all>
                      <check_value value="$ApproachObject.distanceto.[$ApproachSector, $ApproachOffset]" min="$ApproachDistance"/>
                      <check_value value="$Invert"/>
                    </check_all>
                  </check_any>
                </check_all>
              </conditions>
              <actions>
                <signal_cue cue="$SuccessSignalCue"/>
                <cancel_cue cue="parent"/>
              </actions>
            </cue>

          </cues>
        </cue>
      </cues>
    </library>

    <!-- Workaraound for our target guidance not handling first person multiple targets very well. Only works if the actors are on different containers -->
    <library name="MultipleActorConversation_Handling">
      <params>
        <param name="MissionCue"/>
        <param name="ActorGroup"/>
        <param name="MissionStep"       default="1"/>
        <param name="CustomMissionText" default="null"/>
        <param name="CustomAction"      default="null"/>
      </params>
      <cues>

        <!-- Player left a container with a relevant actor -->
        <cue name="MultipleActorConversation_PlayerLeftContainer" instantiate="true">
          <conditions>
            <event_object_changed_object object="player.entity"/>
            <check_any exact="$ActorGroup.count" counter="$i">
              <check_all>
                <check_value value="$ActorGroup.{$i}.hascontext.{event.param2}"/>
                <check_value value="not $ActorGroup.{$i}.hascontext.{event.param}"/>
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <do_if value="CustomAction?">
              <set_objective cue="$MissionCue" step="$MissionStep" action="objective.custom" customaction="$CustomAction" group="$ActorGroup" silent="true"/>
            </do_if>
            <do_else>
              <set_objective cue="$MissionCue" step="$MissionStep" action="objective.talkto" group="$ActorGroup" text="$CustomMissionText" silent="true" />
            </do_else>
          </actions>
        </cue>

        <!-- Listens to the player stepping on board of the container containing one of the Actors -->
        <cue name="MultipleActorConversation_PlayerenteredContainer" instantiate="true">
          <conditions>
            <event_object_changed_object object="player.entity"/>
            <check_any exact="$ActorGroup.count" counter="$i">
              <check_all>
                <check_value value="not $ActorGroup.{$i}.hascontext.{event.param2}"/>
                <check_value value="$ActorGroup.{$i}.hascontext.{event.param}"/>
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <do_for_each name="$actor" in="$ActorGroup">
              <do_if value="$actor.hascontext.{event.param}">
                <set_value name="this.$Objective_actor" exact="$actor"/>
              </do_if>
            </do_for_each>
            <do_if value="CustomAction?">
              <set_objective cue="$MissionCue" step="$MissionStep" action="objective.custom" customaction="$CustomAction" object="this.$Objective_actor" silent="true"/>
            </do_if>
            <do_else>
              <set_objective cue="$MissionCue" step="$MissionStep" action="objective.talkto" text="$CustomMissionText" object="this.$Objective_actor" silent="true" />
            </do_else>
          </actions>
        </cue>

      </cues>
    </library>

    <!-- Forces the specified ship to a halt (for cutscene and story purposes) -->
    <library name="ForceShipHalt">
      <params>
        <param name="Ship"/>
        <param name="RequiresPlayerowned" default="true" comment="only stop ship if it is playerowned or if explicitly called for in script"/>
        <param name="BreakingTime" default="1s" comment="defines how fast and abrupt the ship comes to a stop, default is immediately"/>
      </params>
      <cues>
        <cue name="ForceShipHalt_Setup">
          <actions>
            <do_if value="$RequiresPlayerowned and $Ship.owner != faction.player">
              <assert value="$Ship.owner != faction.player"/>
              <cancel_cue cue="parent"/>
            </do_if>
            <do_if value="$BreakingTime == 0">
              <assert value="$BreakingTime == 0"/>
              <cancel_cue cue="parent"/>
            </do_if>
            <set_value name="$BreakIterationTarget" exact="$BreakingTime"/>
            <set_value name="$BreakIterations" exact="0"/>
            <set_value name="$ShipThrottleValue" exact="$Ship.throttle"/>
            <set_value name="$ShipSpeed_Subtracted" exact="$ShipThrottleValue / $BreakIterationTarget"/>
          </actions>
        </cue>

        <cue name="ForceShipHalt_Start">
          <conditions>
            <event_cue_completed cue="ForceShipHalt_Setup"/>
          </conditions>
          <cues>

            <cue name="ForceShipHalt_Instantiated" instantiate="true" checkinterval="1s">
              <conditions>
                <check_value value="$BreakIterations lt $BreakIterationTarget"/>
              </conditions>
              <actions>
                <set_value name="$BreakIterations" operation="add" exact="1"/>
                <set_value name="$ShipSpeed_Deceleration" exact="$ShipSpeed_Subtracted * $BreakIterations"/>

                <force_player_speed speed="$ShipThrottleValue - $ShipSpeed_Deceleration"/>
                <set_value name="$Debug_Text" exact="$ShipThrottleValue - $ShipSpeed_Deceleration"/>

                <do_if value="$BreakIterations ge $BreakIterationTarget">
                  <signal_cue cue="ForceShipHalt_CameToHalt"/>
                </do_if>
              </actions>
            </cue>

            <cue name="ForceShipHalt_CameToHalt">
              <conditions>
                <event_cue_signalled/>
              </conditions>
              <actions>
                <stop_player_autopilot/>
                <set_playership_throttle value="0" comment="to force a full stop, no matter what"/>
                <force_player_speed speed="0"/>
                <do_if value="$Ship != player.occupiedship">
                  <create_order object="$Ship" id="'Wait'" name="$waitorder" immediate="true">
                    <param name="timeout" value="3min"/>
                    <param name="holdfire" value="true"/>
                    <param name="noattackresponse" value="true"/>
                  </create_order>
                </do_if>
                <cancel_cue cue="parent"/>
              </actions>
            </cue>

          </cues>
        </cue>
      </cues>
    </library>

    <library name="WarpBetweenObjects_v2" purpose="run_actions">
      <params>
        <param name="FromObject"/>
        <param name="ToObject"/>
        <param name="Distance01"  comment="range [0,1] where 0 is location of FromObject and 1 is location of ToObject"/>
        <param name="WarpGroup"   comment="the objects to warp"/>
      </params>
      <actions>
        <assert value="$FromObject.sector == $ToObject.sector" comment="parameter validation"/>
        <set_value name="$DistanceFromTo" exact="$FromObject.distanceto.{$ToObject} * $Distance01"/>

        <create_position name="$TargetOrigin" object="$ToObject" space="$FromObject.zone"/>
        <create_orientation name="$Rotation" orientation="look_at" refposition="$TargetOrigin">
          <position  object="$FromObject" space="$FromObject.zone"/>
        </create_orientation>

        <create_position name="$Location" x="$FromObject.position.x + sin($Rotation.yaw) * $DistanceFromTo" y="0" z="$FromObject.position.z + cos($Rotation.yaw) * $DistanceFromTo"/>

        <debug_text text="'Distance=' + $FromObject.distanceto.{$ToObject} + ' Distance01=' + $DistanceFromTo + ' BetweenPosition: ' + $Location + ' cos(yaw)=' + cos($Rotation.yaw) + ' sin(yaw)=' + sin($Rotation.yaw)" chance="0"/>

        <do_all exact="$WarpGroup.count" counter="$i">
          <warp object="$WarpGroup.{$i}" zone="$FromObject.zone">
            <rotation value="$Rotation"/>
            <safepos value="$Location" radius="$WarpGroup.{$i}.size"/>
          </warp>
          <debug_text text="'Warping: ' + $WarpGroup.{$i}.knownname + ' to-sector=' + $WarpGroup.{$i}.sector.knownname" chance="0"/>
        </do_all>

      </actions>
    </library>

    <!--Note: Position result is in the space of FromObject-->
    <library name="GetPositionBetweenObjects" purpose="run_actions">
      <params>
        <param name="FromObject"/>
        <param name="ToObject"/>
        <param name="Distance01"        default="null" comment="range [0,1] where 0 is location of FromObject and 1 is location of ToObject"/>
        <param name="Distance_Absolute" default="null" />
        <param name="IsForceEclipticPlane" default="true" />
      </params>
      <actions>
        <do_if value="$FromObject.isclass.sector"
          comment="allow calculations between an object and the sector origin">
          <set_value name="$Sector_FromObject" exact="$FromObject" />
        </do_if>
        <do_else>
          <set_value name="$Sector_FromObject" exact="$FromObject.sector" />
        </do_else>
        <do_if value="$ToObject.isclass.sector">
          <set_value name="$Sector_ToObject" exact="$ToObject" />
        </do_if>
        <do_else>
          <set_value name="$Sector_ToObject" exact="$ToObject.sector" />
        </do_else>
        <assert value="$Sector_FromObject == $Sector_ToObject" comment="parameter validation"/>
        <do_if value="$Distance01">
          <set_value name="$DistanceFromTo" exact="$FromObject.distanceto.{$ToObject} * $Distance01"/>
        </do_if>
        <do_elseif value="$Distance_Absolute">
          <set_value name="$DistanceFromTo" exact="$Distance_Absolute" />
        </do_elseif>

        <do_if value="$FromObject.isclass.sector">
          <create_position name="$TargetOrigin" object="$ToObject" space="$FromObject"/>
          <create_orientation name="$Rotation" orientation="look_at" refposition="$TargetOrigin">
            <position  object="$FromObject" space="$FromObject"/>
          </create_orientation>
        </do_if>
        <do_else>
          <create_position name="$TargetOrigin" object="$ToObject" space="$FromObject.zone"/>
          <create_orientation name="$Rotation" orientation="look_at" refposition="$TargetOrigin">
            <position  object="$FromObject" space="$FromObject.zone"/>
          </create_orientation>
        </do_else>

        <do_if value="$FromObject.isclass.sector">
          <set_value name="$FromPos" exact="position.[0m, 0m, 0m]" comment="Use centre of FromObject which is a sector"/>
        </do_if>
        <do_else>
          <!--TODO @Owen check if this should explicitly be in the space of the zone-->
          <set_value name="$FromPos" exact="$FromObject.position" comment="Use FromObject position to their parent"/>
        </do_else>

        <do_if value="$IsForceEclipticPlane">
          <!-- NOTE: this $Location's space is $FromObject.zone -->
          <create_position name="$Location" x="$FromPos.x + sin($Rotation.yaw) * $DistanceFromTo" y="0" z="$FromPos.z + cos($Rotation.yaw) * $DistanceFromTo"/>
        </do_if>
        <do_else>
          <!-- NOTE: this $Location's space is $FromObject.zone -->
          <create_position name="$Location"
            x="$FromPos.x + $DistanceFromTo * sin($Rotation.yaw) * cos($Rotation.pitch)"
            y="$FromPos.y + $DistanceFromTo * sin($Rotation.pitch)"
            z="$FromPos.z + $DistanceFromTo * cos($Rotation.yaw) * cos($Rotation.pitch)"
          />
        </do_else>

        <!-- NOTE: convert back the space to $FromObject so that no conversion is required at the receiving end. -->
        <do_if value="$FromObject.isclass.sector">
          <create_position name="$Location" space="$FromObject" object="$FromObject" value="$Location" />
        </do_if>
        <do_else>
          <create_position name="$Location" space="$FromObject" object="$FromObject.zone" value="$Location" />
        </do_else>

        <debug_text text="'Distance=' + $FromObject.distanceto.{$ToObject} + ' Distance01=' + $DistanceFromTo + ' BetweenPosition: ' + $Location + ' cos(yaw)=' + cos($Rotation.yaw) + ' sin(yaw)=' + sin($Rotation.yaw)" chance="0"/>

        <return value="table[ $position = $Location,
                              $rotation = $Rotation ]"/>
      </actions>
    </library>

    <!-- input: $position, $mindist, $maxdist, output: $position (modified) -->
    <library name="CreatePositionEclipticNearFar" purpose="run_actions">
      <params>
        <param name="position"/>
        <param name="mindist"/>
        <param name="maxdist"/>
      </params>
      <actions>
        <set_value name="this.$Yaw" min="0deg" max="360deg" />
        <set_value name="this.$SpawnDistance" min="$mindist" max="$maxdist"/>
        <set_value name="$position" exact="position.[$position.x + sin(this.$Yaw) * this.$SpawnDistance, $position.y, $position.z + cos(this.$Yaw) * this.$SpawnDistance]"/>

        <return value="$position" comment="modified"/>
      </actions>
    </library>

    <library name="ReachedSector">
      <params>
        <param name="TargetObject" default="player.entity" comment="object we require to be within $TargetSector"/>
        <param name="TargetSector"/>
        <param name="SuccessSignalCue"/>
        <param name="FailureSignalCue" default="null"/>
      </params>
      <cues>
        <cue name="In_Sector_Start">
          <actions>
            <do_if value="$TargetObject.sector == $TargetSector">
              <signal_cue cue="In_Sector_Check"/>
            </do_if>
          </actions>
        </cue>
        <cue name="In_Sector_Check">
          <conditions>
            <check_any>
              <event_cue_signalled/>
              <event_object_changed_sector object="$TargetObject" sector="$TargetSector"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="event.name == 'event_object_changed_sector'">
              <signal_cue_instantly cue="$SuccessSignalCue" param="event.param2"/>
            </do_if>
            <do_else>
              <signal_cue_instantly cue="$SuccessSignalCue"/>
            </do_else>
            <cancel_cue cue="Target_Destroyed"/>
          </actions>
        </cue>
        <cue name="Target_Destroyed">
          <conditions>
            <event_object_destroyed object="$TargetObject"/>
          </conditions>
          <actions>
            <do_if value="$FailureSignalCue != null">
              <signal_cue cue="$FailureSignalCue"/>
            </do_if>
            <cancel_cue cue="In_Sector_Check"/>
          </actions>
        </cue>
      </cues>
    </library>

    <library name="LeftSector">
      <params>
        <param name="TargetObject" default="player.entity" comment="object we require to be within $TargetSector"/>
        <param name="TargetSector"/>
        <param name="SuccessSignalCue"/>
        <param name="FailureSignalCue" default="null"/>
      </params>
      <cues>
        <cue name="Left_Sector_Start">
          <actions>
            <do_if value="$TargetObject.sector != $TargetSector">
              <signal_cue cue="Left_Sector_Check"/>
            </do_if>
          </actions>
        </cue>
        <cue name="Left_Sector_Check">
          <conditions>
            <check_any>
              <event_cue_signalled/>
              <event_object_changed_sector object="$TargetObject" previous="$TargetSector"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="event.name == 'event_object_changed_sector'">
              <signal_cue_instantly cue="$SuccessSignalCue" param="event.param2"/>
            </do_if>
            <do_else>
              <signal_cue_instantly cue="$SuccessSignalCue"/>
            </do_else>
            <cancel_cue cue="Left_Sector_Target_Destroyed"/>
          </actions>
        </cue>
        <cue name="Left_Sector_Target_Destroyed">
          <conditions>
            <event_object_destroyed object="$TargetObject"/>
          </conditions>
          <actions>
            <do_if value="$FailureSignalCue != null">
              <signal_cue cue="$FailureSignalCue"/>
            </do_if>
            <cancel_cue cue="Left_Sector_Check"/>
          </actions>
        </cue>
      </cues>
    </library>

    <library name="ReachedSameSector" comment="two Target Objects are in the same sector after either of them moved in there">
      <params>
        <param name="TargetObject"                          comment="First object we require to be in the same sector as the other one"/>
        <param name="TargetObject2" default="player.entity" comment="Second object we require to be in the same sector as the other one"/>
        <param name="SuccessSignalCue"/>
        <param name="FailureSignalCue" default="null"/>
      </params>
      <cues>
        <cue name="ReachedSameSector_Start">
          <actions>
            <signal_cue cue="ReachedSameSector_Check"/>
          </actions>
        </cue>

        <cue name="ReachedSameSector_Check">
          <conditions>
            <check_any>
              <event_cue_signalled/>
              <event_object_changed_sector object="$TargetObject"/>
              <event_object_changed_sector object="$TargetObject2"/>
            </check_any>
            <check_value value="$TargetObject.sector == $TargetObject2.sector"/>
            <check_value value="$TargetObject.sector != null" comment="prevent success when both are in a superhighway"/>
          </conditions>
          <actions>
            <signal_cue_instantly cue="$SuccessSignalCue" param="$TargetObject.sector"/>
            <cancel_cue cue="ReachedSameSector_Target_Destroyed"/>
          </actions>
        </cue>

        <cue name="ReachedSameSector_Target_Destroyed">
          <conditions>
            <check_any>
              <event_object_destroyed object="$TargetObject"/>
              <event_object_destroyed object="$TargetObject2"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="$FailureSignalCue != null">
              <signal_cue cue="$FailureSignalCue"/>
            </do_if>
            <cancel_cue cue="ReachedSameSector_Check"/>
          </actions>
        </cue>
      </cues>
    </library>

    <library name="TakeoverStations" namespace="this" version="2">
      <params>
        <param name="Stations"/>
        <param name="TargetFaction"/>
        <param name="Chance" default="100" comment="Every station has a Chance % chance to be picked"/>
        <param name="Delay" default="[30s]"/>
        <param name="SuccessSignalCue"/>
        <param name="RandomCount" default="0" comment="0 means ALL are picked, otherwise randomly(!) picks RandomCount stations from the list"/>
      </params>
      <actions>
        <set_value name="$CurCount" exact="0"/>
        <do_if value="not $Stations.count">
          <signal_cue cue="$SuccessSignalCue"/>
        </do_if>
      </actions>
      <patch sinceversion="2" state="complete">
        <do_if value="not $Stations.count">
          <signal_cue cue="$SuccessSignalCue" check="false"/>
        </do_if>
      </patch>
      <cues>
        <cue name="TakeoverStations_Delayed" onfail="cancel">
          <conditions>
            <check_value value="$Stations.count"/>
          </conditions>
          <delay exact="$Delay.random"/>
          <actions>
            <debug_text text="player.age + ' Transferring ' + $Stations.{$Stations.count}.knownname + ' to ' + $TargetFaction.name" chance="0"/>

            <do_if value="$RandomCount == 0">
              <!-- Go through all stations with a chance of $Chance %-->
              <do_if value="true" chance="$Chance">
                <set_owner object="$Stations.{$Stations.count}" faction="$TargetFaction" overridenpc="true"/>
                <do_all exact="$Stations.{$Stations.count}.subordinates.count" counter="$j">
                  <set_owner object="$Stations.{$Stations.count}.subordinates.{$j}" faction="$TargetFaction" overridenpc="true"/>
                </do_all>
              </do_if>
              <resize_list list="$Stations" count="$Stations.count - 1"/>
              <do_if value="$Stations.count">
                <reset_cue cue="TakeoverStations_Delayed"/>
              </do_if>
            </do_if>
            <do_else>
              <!-- pick up to $RandomCount station (with a chance of $Chance %) -->
              <do_if value="true" chance="$Chance">
                <set_value name="$SelectedStation" exact="$Stations.random"/>
                <set_owner object="$SelectedStation" faction="$TargetFaction" overridenpc="true"/>
                <do_all exact="$SelectedStation.subordinates.count" counter="$j">
                  <set_owner object="$SelectedStation.subordinates.{$j}" faction="$TargetFaction" overridenpc="true"/>
                </do_all>
                <remove_from_list name="$Stations" exact="$SelectedStation"/>
              </do_if>
              <set_value name="$CurCount" operation="add"/>
              <do_if value="($CurCount lt $RandomCount)">
                <reset_cue cue="TakeoverStations_Delayed"/>
              </do_if>
            </do_else>

            <do_if value="$SuccessSignalCue? and (($Stations.count == 0) or ($RandomCount and ($CurCount ge $RandomCount)))" >
              <signal_cue cue="$SuccessSignalCue"/>
            </do_if>
          </actions>
        </cue>
      </cues>
    </library>

    <!-- can't make a station invulnerable by setting it's minhull, instead loop over all modules-->
    <library name="SetStationMinHull" purpose="run_actions">
      <params>
        <param name="Station"/>
        <param name="MinHullPercent" comment="0-100"/>
      </params>
      <actions>
        <do_if value="$Station">
          <find_object_component object="$Station" name="$StationModules" class="class.module" multiple="true" checkoperational="true" />
          <do_all exact="$StationModules.count" counter="$m">
            <set_object_min_hull object="$StationModules.{$m}" exact="$MinHullPercent"/>
          </do_all>
        </do_if>
      </actions>
    </library>

    <library name="SetShipMinHull" purpose="run_actions">
      <params>
        <param name="Ship"/>
        <param name="MinHullPercent" comment="0-100"/>
        <param name="IncludeEngines" default="false"/>
        <param name="IncludeShields" default="false"/>
        <param name="IncludeTurrets" default="false"/>
      </params>
      <actions>
        <do_if value="$Ship">
          <do_if value="$MinHullPercent == 0">
            <!--Don't set a ship to vulnerable while leaving the surface elements to be invincible. That's not what this library is for.-->
            <set_value name="$IncludeEngines" exact="true"/>
            <set_value name="$IncludeShields" exact="true"/>
            <set_value name="$IncludeTurrets" exact="true"/>
          </do_if>
          <set_value name="$Components" exact="[]"/>
          <do_if value="$IncludeEngines">
            <find_object_component name="$Components" object="$Ship" class="class.engine" integrated="false" checkoperational="true" multiple="true" append="true"/>
          </do_if>
          <do_if value="$IncludeShields">
            <find_object_component name="$Components" object="$Ship" class="class.shieldgenerator" integrated="false" checkoperational="true" multiple="true" append="true"/>
          </do_if>
          <do_if value="$IncludeTurrets">
            <find_object_component name="$Components" object="$Ship" class="class.turret" integrated="false" checkoperational="true" multiple="true" append="true"/>
          </do_if>
          <do_for_each name="$Component" in="$Components">
            <set_object_min_hull object="$Component" exact="$MinHullPercent"/>
          </do_for_each>
          <set_object_min_hull object="$Ship" exact="$MinHullPercent"/>
          <do_if value="$Ship.isclass.spacesuit">
            <do_if value="$MinHullPercent == 0">
              <unpause_spacesuit_oxygen object="$Ship"/>
            </do_if>
            <do_else>
              <pause_spacesuit_oxygen object="$Ship"/>
            </do_else>
          </do_if>
        </do_if>
      </actions>
    </library>

    <!--
    ===== Object Invincibility Manager =====
    Request for an object to have a minhull value, making it invincible.
    Provide a cue as the 'requester'. If that cue is no longer complete/active, the request is lost. You can also manually signal for the request to be removed.
    If an object has no more active requesters, it will become vulnerable again.-->
    <cue name="ObjectInvincibilityManager" namespace="this" version="7">
      <actions>
        <!--$ObjectTable
        key = object
        value = list of requester cues-->
        <set_value name="$ObjectTable" exact="table[]"/>
        <set_value name="$MinHull" exact="5"/>
        <set_value name="$DebugChance" exact="0"/>
        <create_list name="$UnexpectedDestroyList"/>

        <!--TODO @Owen - a group for invincible stations to set min hull of new modules?-->

        <create_group groupname="$Objects"/>
      </actions>
      <patch sinceversion="2">
        <set_value name="$MinHull" exact="5"/>
        <create_group groupname="$Objects"/>
        <add_to_group groupname="$Objects" list="$ObjectTable.keys.list"/>
        <debug_text text="'Invicible objects group is tracking ' + $Objects.count + ' objects'" filter="savegame"/>

        <!--Convert the old $ObjectTable to the new version. The old value of the table was a list of cues. The new value is a table, of which $requestercues is the list.-->
        <do_for_each name="$Object" valuename="$RequesterCues" in="$ObjectTable">
          <set_object_min_hull object="$Object" exact="$MinHull"/>
          <set_value name="$ObjectTable.{$Object}" exact="table[$requestercues = $RequesterCues]"/>
        </do_for_each>
      </patch>
      <patch sinceversion="3">
        <add_to_group groupname="$Objects" list="$ObjectTable.keys.list"/>
      </patch>
      <patch sinceversion="4">
        <do_for_each name="$Patch_Obj" valuename="$ObjectEntry" in="$ObjectTable">
          <set_value name="$ObjRequesterCuesClone" exact="$ObjectEntry.$requestercues.clone"/>
          <clear_list list="$ObjectEntry.$requestercues"/>
          <do_for_each name="$ObjRequesterCue" in="$ObjRequesterCuesClone">
            <do_if value="$ObjectEntry.$requestercues.indexof.{$ObjRequesterCue} == 0">
              <append_to_list name="$ObjectEntry.$requestercues" exact="$ObjRequesterCue"/>
            </do_if>
            <do_else>
              <debug_text text="'Removing duplicate requester cue ' + $ObjRequesterCue + ' for object ' + $Patch_Obj + ' ' + $Patch_Obj.knownname" filter="savegame"/>
            </do_else>
          </do_for_each>
        </do_for_each>
      </patch>
      <patch sinceversion="5">
        <!-- Visualisation of table:
             $ObjectTable == table[component<...> = ...
                                   component<...> = ...
                                   component<...> = table[$requestercues       = [cue, cue, cue, ...]
                                                          $thresholdsignalcues = [cue, cue, cue, ...]
                                                          $minhull             = $MinHull
                                                                                                      ]
                                                                                                        ]
             -->
        <do_for_each in="$ObjectTable" name="$Patch_Obj" valuename="$ObjectEntry">
          <set_value name="$ObjectEntry.$minhull" exact="5"/>
        </do_for_each>
      </patch>
      <patch sinceversion="6">
        <create_list name="$UnexpectedDestroyList"/>
      </patch>
      <patch sinceversion="7">
        <do_for_each in="$ObjectTable" name="$Patch_Obj" valuename="$ObjectEntry">
          <do_if value="$Patch_Obj.isclass.spacesuit">
            <debug_text text="'Pausing oxygen consumption for invincible spacesuit ' + $Patch_Obj + ' ' + $Patch_Obj.knownname" filter="savegame"/>
            <pause_spacesuit_oxygen object="$Patch_Obj"/>
          </do_if>
        </do_for_each>
      </patch>
      <cues>

        <cue name="ObjectInvincibilityManager_CutsceneTemporaryInvincibility" instantiate="true" namespace="this">
          <conditions>
            <event_cutscene_started/>
            <check_value value="event.param3 != 0" comment="Only in fullscreen cutscenes"/>
            <cue_is_complete cue="md.CinematicCamera.CinematicCameraManager" negate="true"/>
          </conditions>
          <actions>
            <set_value name="$CutsceneKey" exact="event.param"/>
            <set_value name="$CutsceneID" exact="event.param2"/>
            <set_value name="$PlayerShip" exact="player.ship"/>
            <set_value name="$DebugChance" exact="parent.$DebugChance" comment="we are namespace'd, fetch this from parent"/>
            <do_if value="$PlayerShip.exists">
              <debug_text text="'Cutscene Invulnerability for %s `%s` started'.[$PlayerShip, $PlayerShip.knownname]" chance="$DebugChance"/>
              <run_actions ref="md.LIB_Generic.RequestObjectInvincibility">
                <param name="Object" value="$PlayerShip"/>
                <param name="RequesterCue" value="ObjectInvincibilityManager_CutsceneTemporaryInvincibility"/>
                <param name="MinHull" value="($PlayerShip.hull / $PlayerShip.maxhull) * 100 " comment="MinHull in %"/>
                <param name="DebugChance" value="$DebugChance"/>
              </run_actions>
            </do_if>
          </actions>
          <cues>

            <cue name="ObjectInvincibilityManager_PlayerMoved" instantiate="true">
              <conditions>
                <check_any>
                  <event_object_changed_room object="player.entity"/>
                  <event_player_teleport_successful/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="$PlayerShip.exists and (player.ship != $PlayerShip)">
                  <!-- remove invulnerability from old ship -->
                  <debug_text text="'Cutscene Invulnerability for %s `%s` ended'.[$PlayerShip, $PlayerShip.knownname]" chance="$DebugChance"/>
                  <run_actions ref="md.LIB_Generic.RequestObjectVulnerability">
                    <param name="Object" value="$PlayerShip"/>
                    <param name="RequesterCue" value="namespace"/>
                    <param name="DebugChance" value="$DebugChance"/>
                  </run_actions>
                </do_if>

                <set_value name="$PlayerShip" exact="player.ship"/>
                <do_if value="$PlayerShip.exists">
                  <!-- and set invulnerability to new ship -->
                  <debug_text text="'Cutscene Invulnerability switched to %s `%s`'.[$PlayerShip, $PlayerShip.knownname]" chance="$DebugChance"/>
                  <run_actions ref="md.LIB_Generic.RequestObjectInvincibility">
                    <param name="Object" value="$PlayerShip"/>
                    <param name="RequesterCue" value="ObjectInvincibilityManager_CutsceneTemporaryInvincibility"/>
                    <param name="MinHull" value="($PlayerShip.hull / $PlayerShip.maxhull) * 100 " comment="MinHull in %"/>
                    <param name="DebugChance" value="$DebugChance"/>
                  </run_actions>
                </do_if>
              </actions>
            </cue>

            <cue name="ObjectInvincibilityManager_CutsceneTemporaryInvincibility_Done">
              <conditions>
                <event_cutscene_stopped cutscene="parent.$CutsceneID"/>
              </conditions>
              <actions>
                <do_if value="$PlayerShip.exists">
                  <debug_text text="'Cutscene Invulnerability for %s `%s` ended'.[$PlayerShip, $PlayerShip.knownname]" chance="$DebugChance"/>
                  <run_actions ref="md.LIB_Generic.RequestObjectVulnerability">
                    <param name="Object" value="$PlayerShip"/>
                    <param name="RequesterCue" value="namespace"/>
                    <param name="DebugChance" value="$DebugChance"/>
                  </run_actions>
                </do_if>
                <cancel_cue cue="ObjectInvincibilityManager_CutsceneTemporaryInvincibility" comment="cancel running instance"/>
              </actions>
            </cue>
          </cues>
        </cue>

        <cue name="ObjectInvincibilityManager_Cull" instantiate="true" checkinterval="5s">
          <conditions>
            <check_value value="$ObjectTable.keys.count"/>
          </conditions>
          <actions>
            <include_actions ref="ObjectInvincibilityManager_CheckRequests"/>
          </actions>
        </cue>

        <cue name="ObjectInvincibilityManager_CheckRequestSignal" instantiate="true">
          <conditions>
            <event_cue_signalled cue="ObjectInvincibilityManager"/>
            <check_value value="event.param == 'check_requests'"/>
          </conditions>
          <actions>
            <include_actions ref="ObjectInvincibilityManager_CheckRequests"/>
          </actions>
        </cue>

        <cue name="ObjectInvincibilityManager_ObjectAttacked" instantiate="true">
          <conditions>
            <event_object_attacked group="$Objects"/>
            <check_value value="@$ObjectTable.{event.object}.$thresholdsignalcues.count and (event.object.hullpercentage)i le $ObjectTable.{event.object}.$minhull"/>
          </conditions>
          <actions>
            <debug_text text="'Object ' + event.object + ' ' + event.object.knownname + ' was damaged to the min hull threshold. Signalling ' + $ObjectTable.{event.object}.$thresholdsignalcues.count + ' threshold cues.'"/>
            <do_for_each name="$SignalCue" in="$ObjectTable.{event.object}.$thresholdsignalcues">
              <do_if value="$SignalCue.exists">
                <signal_cue cue="$SignalCue" check="false"/>
              </do_if>
            </do_for_each>
            <clear_list list="$ObjectTable.{event.object}.$thresholdsignalcues"/>
          </actions>
        </cue>

        <cue name="ObjectInvincibilityManager_ObjectDestroyed" instantiate="true">
          <conditions>
            <event_object_destroyed group="$Objects"/>
          </conditions>
          <actions>
            <!-- 
              This assert triggers if <destroy_object/> was called on an object, while it was under protection of the ObjectInvincibilityManager. 
              One case where this could happen is when the ship was given a 'MoveDie' order (and was destroyed, which can be minutes after the order was given) without first removing it from the ObjectInvincibilityManager 
            -->
            <assert value="false" text="'ObjectInvincibilityManager: Protected object %s \'%s\' macro=%s was destroyed?! killmethod=%s sector=%s position=%s (report to story team)'.[event.object, event.object.knownname, event.object.macro, event.param2, event.object.sector, event.object.position]"/>
            <!-- store parameters for postmortem debugging (see also ResearchShip_Lost_Log with details specifically for the Oberth case) -->
            <create_list name="$DestroyParams"/>
            <append_to_list name="$DestroyParams" exact="'Object-id: ' + event.object"/>
            <append_to_list name="$DestroyParams" exact="'Object-name: ' + event.object.knownname"/>
            <append_to_list name="$DestroyParams" exact="'Object-macro: ' + event.object.macro"/>
            <append_to_list name="$DestroyParams" exact="'Object-sector: ' + event.object.sector"/>
            <do_if value="event.object.sector != null">
              <append_to_list name="$DestroyParams" exact="'Object-sector-name: ' + event.object.sector.knownname"/>
            </do_if>
            <do_if value="event.object.parent != null">
              <append_to_list name="$DestroyParams" exact="'Object-parent: ' + event.object.parent.knownname"/>
            </do_if>
            <append_to_list name="$DestroyParams" exact="'Object-position: ' + event.object.position"/>
            <append_to_list name="$DestroyParams" exact="'Kill method: ' + event.param2"/>
            <append_to_list name="$DestroyParams" exact="'Time: ' + player.age"/>
            <append_to_list name="$DestroyParams" exact="'Killer: ' + event.param"/>
            <do_if value="event.param != null">
              <append_to_list name="$DestroyParams" exact="'Killer-name: ' + event.param.knownname"/>
            </do_if>
            <do_if value="@event.param.container">
              <append_to_list name="$DestroyParams" exact="'Killer-container: ' + event.param.container + ' ' + event.param.container.knownname"/>
            </do_if>
            <do_if value="event.param != null">
              <append_to_list name="$DestroyParams" exact="'Killer-sector: ' + event.param.sector"/>
              <append_to_list name="$DestroyParams" exact="'Killer-position: ' + event.param.position"/>
            </do_if>
            <append_to_list name="$UnexpectedDestroyList" exact="$DestroyParams"/>
          </actions>
        </cue>

        <cue name="ObjectInvincibilityManager_Report_Requests" instantiate="true">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <do_for_each name="$Object" valuename="$ObjectParameters" in="$ObjectTable">
              <do_if value="$Object.exists">
                <debug_text text="'Object %s `%s` (macro=%s hull=%s shield=%s isindestructible=%s iswreck=%s) - Requester cues: %s - Threshold cues: '.[$Object, $Object.knownname, $Object.macro, $Object.hull, $Object.shield, $Object.isindestructible, $Object.iswreck, $ObjectParameters.$requestercues, @$ObjectParameters.$thresholdsignalcues]"/>
              </do_if>
              <do_else>
                <debug_text text="'Object which was supposed to be invincible no longer exists. Requester cues: ' + $ObjectParameters.$requestercues + ' Threshold cues: ' + @$ObjectParameters.$thresholdsignalcues"/>
              </do_else>
            </do_for_each>
          </actions>
        </cue>

        <library name="ObjectInvincibilityManager_CheckRequests">
          <actions>
            <do_for_each name="$Object" valuename="$ObjectParameters" in="$ObjectTable" reverse="true">
              <do_if value="$Object.exists">
                <do_for_each name="$RequesterCue" in="$ObjectParameters.$requestercues" reverse="true">
                  <do_if value="$RequesterCue.state != cuestate.complete and $RequesterCue.state != cuestate.active">
                    <remove_from_list name="$ObjectParameters.$requestercues" exact="$RequesterCue"/>
                  </do_if>
                </do_for_each>
                <do_if value="$ObjectParameters.$requestercues.count == 0">
                  <!--No requester cues. Make vulnerable-->
                  <debug_text text="'Invincible object ' + $Object + ' ' + $Object.knownname + ' has no more requester cues. Setting to vulnerable.'" chance="$DebugChance"/>
                  <do_if value="$Object.isrealclass.station">
                    <run_actions ref="md.LIB_Generic.SetStationMinHull">
                      <param name="Station" value="$Object"/>
                      <param name="MinHullPercent" value="0"/>
                    </run_actions>
                  </do_if>
                  <do_elseif value="$Object.isrealclass.ship">
                    <run_actions ref="md.LIB_Generic.SetShipMinHull">
                      <param name="Ship" value="$Object"/>
                      <param name="MinHullPercent" value="0"/>
                      <param name="IncludeEngines" value="true"/>
                      <param name="IncludeShields" value="true"/>
                      <param name="IncludeTurrets" value="true"/>
                    </run_actions>
                  </do_elseif>
                  <do_else>
                    <set_object_min_hull object="$Object" exact="0"/>
                  </do_else>

                  <!--Remove from table-->
                  <remove_value name="$ObjectTable.{$Object}"/>
                  <remove_from_group group="$Objects" object="$Object"/>
                </do_if>
              </do_if>
              <do_else>
                <assert value="$Object.exists" text="'Object which was supposed to be invincible no longer exists. Requester cues: ' + $ObjectParameters.$requestercues + ' [Owen]'"/>
                <!--Remove from table-->
                <remove_value name="$ObjectTable.{$Object}"/>
              </do_else>
            </do_for_each>
          </actions>
        </library>
      </cues>
    </cue>

    <library name="RequestObjectInvincibility" purpose="run_actions">
      <params>
        <param name="Object"/>
        <param name="MinHull" default="5"/>
        <param name="RequesterCue"/>
        <param name="ReachedThresholdSignalCue" default="null" comment="Cue to be signalled when the object has been damaged to the minimum hull level"/>

        <!--params to set surface elements to invincible (note, currently only for ships and will not prevent components being removed via builds nor new components being affected)-->
        <param name="IncludeEngines" default="false"/>
        <param name="IncludeShields" default="false"/>
        <param name="IncludeTurrets" default="false"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <set_value name="$Manager" exact="md.LIB_Generic.ObjectInvincibilityManager"/>
        <do_if value="$Object.exists">
          <do_if value="typeof $RequesterCue == datatype.cue">
            <do_if value="$RequesterCue.state == cuestate.active or $RequesterCue.state == cuestate.complete">
              <!--Add request to the manager's $ObjectTable-->
              <do_if value="not $Manager.$ObjectTable.{$Object}?">
                <set_value name="$Manager.$ObjectTable.{$Object}" exact="table[$requestercues = [$RequesterCue]]"/>
              </do_if>
              <do_elseif value="$Manager.$ObjectTable.{$Object}.$requestercues.indexof.{$RequesterCue} == 0">
                <append_to_list name="$Manager.$ObjectTable.{$Object}.$requestercues" exact="$RequesterCue"/>
              </do_elseif>
              <do_if value="typeof $ReachedThresholdSignalCue == datatype.cue">
                <do_if value="not $Manager.$ObjectTable.{$Object}.$thresholdsignalcues?">
                  <set_value name="$Manager.$ObjectTable.{$Object}.$thresholdsignalcues" exact="[]"/>
                </do_if>
                <append_to_list name="$Manager.$ObjectTable.{$Object}.$thresholdsignalcues" exact="$ReachedThresholdSignalCue"/>
              </do_if>
              <set_value name="$Manager.$ObjectTable.{$Object}.$minhull" exact="$MinHull"/>
              <debug_text text="'Added %s hullpercent invincibility request for %s %s by cue %!s'.[$MinHull, $Object, $Object.knownname, $RequesterCue]" chance="$DebugChance"/>
              <!--Set object min hull-->
              <do_if value="$Object.isclass.station">
                <run_actions ref="md.LIB_Generic.SetStationMinHull">
                  <param name="Station" value="$Object"/>
                  <param name="MinHullPercent" value="$MinHull"/>
                </run_actions>
              </do_if>
              <do_elseif value="$Object.isclass.ship">
                <run_actions ref="md.LIB_Generic.SetShipMinHull">
                  <param name="Ship" value="$Object"/>
                  <param name="MinHullPercent" value="$MinHull"/>
                  <param name="IncludeEngines" value="$IncludeEngines"/>
                  <param name="IncludeShields" value="$IncludeShields"/>
                  <param name="IncludeTurrets" value="$IncludeTurrets"/>
                </run_actions>
              </do_elseif>
              <do_else>
                <set_object_min_hull object="$Object" exact="$MinHull"/>
              </do_else>
              <add_to_group groupname="$Manager.$Objects" object="$Object"/>
            </do_if>
            <do_else>
              <assert value="$RequesterCue.state == cuestate.active or $RequesterCue.state == cuestate.complete" text="'Requester cue ' + $RequesterCue + ' is of state ' + $RequesterCue.state + ' which is not allowed. Active or Complete only. [Owen]'"/>
            </do_else>
          </do_if>
          <do_else>
            <assert value="typeof $RequesterCue == datatype.cue" text="'Requested cue is not of type cue [Owen]'"/>
          </do_else>
        </do_if>
        <do_else>
          <assert value="$Object.exists" text="'Object does not exist [Owen]'"/>
        </do_else>
      </actions>
    </library>

    <!--Warning: This does not ensure vulnerability. Another cue may have requested it for the same object-->
    <library name="RequestObjectVulnerability" purpose="run_actions">
      <params>
        <param name="Object"/>
        <param name="RequesterCue"/>
        <param name="CheckObjectPresence" default="true" comment="Assert if the object is not known by the manager"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <set_value name="$Manager" exact="md.LIB_Generic.ObjectInvincibilityManager"/>
        <do_if value="typeof $RequesterCue == datatype.cue">
          <!--Attempt to remove request from manager-->
          <do_if value="$Manager.$ObjectTable.{$Object}?">
            <do_if value="$Manager.$ObjectTable.{$Object}.$requestercues.indexof.{$RequesterCue}">
              <remove_from_list name="$Manager.$ObjectTable.{$Object}.$requestercues" exact="$RequesterCue" multiple="false"/>
              <assert value="$Manager.$ObjectTable.{$Object}.$requestercues.indexof.{$RequesterCue} == 0" text="'RequesterCue ' + $RequesterCue + ' was apparently used multiple times. Should not happen [Owen]'"/>
              <debug_text text="'Removed invincibility request for %s %s by cue %!s'.[$Object, $Object.knownname, $RequesterCue]" chance="$DebugChance"/>
            </do_if>
            <do_else>
              <assert value="$Manager.$ObjectTable.{$Object}.$requestercues.indexof.{$RequesterCue}" text="'Manager does not have a request for object ' + $Object + ' ' + $Object.knownname + ' by cue ' + $RequesterCue + ' [Owen]'"/>
            </do_else>
          </do_if>
          <do_else>
            <assert value="not $CheckObjectPresence or $Manager.$ObjectTable.{$Object}?" text="'Manager does not have reference to object ' + $Object + ' ' + $Object.knownname + ' [Owen]'"/>
          </do_else>
        </do_if>
        <do_else>
          <assert value="typeof $RequesterCue == datatype.cue" text="'Requested cue is not of type cue [Owen]'"/>
        </do_else>

        <!--Signal the manager to check if the object still has any requesting cues-->
        <signal_cue_instantly cue="$Manager" param="'check_requests'"/>
      </actions>
    </library>

    <cue name="EntityDoNotScanManager" namespace="this">
      <actions>
        <set_value name="$EntityTable" exact="table[]"/>
        <!--  $Manager.$EntityTable = table[{$Entity} = table[{$RequesterCue} = table[ $spaces = [spaces list] ]]];
              $Manager.$EntityTable.{$Entity}.{$RequesterCue}.$spaces = ['$spaces'list space 1, $space2, ...]
        -->
        <create_group groupname="$Entities"/>
      </actions>
      <cues>
        <cue name="EntityDoNotScanManager_Running" instantiate="true">
          <conditions>
            <event_game_loaded/>
          </conditions>
          <actions>
            <set_value name="$Manager" exact="md.LIB_Generic.EntityDoNotScanManager"/>
            <do_if value="$Manager.$EntityTable.keys.count">
              <debug_text text="'EntityDoNotScanManager is tracking ' + $Manager.$EntityTable.keys.count + ' Entities: ' + $Manager.$EntityTable.keys.list"/>
              <do_if value="$Manager.$EntityTable.{player.entity}?">
                <debug_text text="'DoNotScan has been requested for player.entity by: ' + $Manager.$EntityTable.{player.entity}.keys.list"/>
              </do_if>
            </do_if>
          </actions>
        </cue>

        <cue name="EntityDestroyed" instantiate="true">
          <conditions>
            <event_object_destroyed group="$Entities"/>
          </conditions>
          <actions>
            <remove_value name="event.object.$donotscan" comment="the entity blackboard probably survives and we dabble in necromancy"/>
            <remove_value name="md.LIB_Generic.EntityDoNotScanManager.$EntityTable.{event.object}"/>
          </actions>
        </cue>

        <cue name="EntityMoved" instantiate="true">
          <conditions>
            <event_object_changed_sector group="$Entities"/>
          </conditions>
          <actions>
            <run_actions ref="md.LIB_Generic.EntitySpacesCheck">
              <param name="Entity"       value="event.object"/>
            </run_actions>
          </actions>
        </cue>

        <library name="EntitySpacesCheck" purpose="run_actions">
          <params>
            <param name="Entity"/>
          </params>
          <actions>
            <!-- Check whether the RequesterCues requested $donotscan to be active or inactive in the new sector -->
            <set_value name="$Manager" exact="md.LIB_Generic.EntityDoNotScanManager"/>
            <set_value name="this.$NewSectorInSpaces" exact="false"/>

            <do_if value="$Manager.$EntityTable.{$Entity}?" comment="lib is also called to remove $donotscan after removing the $Entity request">
              <do_for_each in="$Manager.$EntityTable.{$Entity}.keys.list" name="$requestercue">
                <do_for_each in="$Manager.$EntityTable.{$Entity}.{$requestercue}.$spaces" name="$space">
                  <do_if value="($Entity.sector.hascontext.{$space}) or ($Entity.sector == $space)">
                    <set_value name="this.$NewSectorInSpaces" exact="true"/>
                    <break/>
                  </do_if>
                </do_for_each>
                <do_if value="this.$NewSectorInSpaces">
                  <break/>
                </do_if>
              </do_for_each>
            </do_if>

            <do_if value="this.$NewSectorInSpaces">
              <set_value name="$Entity.$donotscan" exact="true"/>
            </do_if>
            <do_else>
              <remove_value name="$Entity.$donotscan"/>
            </do_else>
          </actions>
        </library>
      </cues>
    </cue>

    <library name="RequestEntityDoNotScan" purpose="run_actions">
      <params>
        <!-- TODO: $donotplunder, potentially a different library RequestEntityFlag or something suitable for new flags, too. -->
        <!-- TODO: ? set flag on pilots of the $Entity.ship if the $Entity is not piloting/starting/stopping control -->
        <param name="Entity"              default="player.entity"   comment="Entities, usually pilots or player.entity. Not Objects."/>
        <param name="RequesterCue"/>
        <param name="DoNotScanSpaces"     default="[player.galaxy]" comment="List of spaces to check $Entity.sector against to (de)activate .$donotscan accordingly"/>
        <param name="AddRequest"          default="true"            comment="Call with false to remove requests. Can remove specific requests or everything if called with [player.galaxy]"/>
        <!-- AddRequest:
              - true:
                  - Adds a request for the $Entity, the $RequesterCue and the $DoNotScanSpaces
                  - EntityDoNotScanManager will toggle $Entity.$donotscan on/off depending on whether $Entity.sector is in $DoNotScanSpaces of any $RequesterCue's '$spaces' list
              - false:
                  - If $DoNotScanSpaces contains player.galaxy, the $RequesterCue will be fully removed for this $Entity
                  - Else specific spaces are removed from the '$spaces' list for this $RequesterCue for this $Entity
              Pitfalls:
                  - If player.galaxy was ever added to $DoNotScanSpaces
                    -> it does not make sense to add/remove specific places, as $Entity will always be in player.galaxy
                    -> player.galaxy can never be removed as an entry from the '$spaces' list, as this removes the $RequesterCue entry entirely
                  - If $Cluster was added, you can not remove one $Sector in the $Cluster from the '$spaces' list and expect $donotscan behaviour for the other sectors in $cluster only
                    -> It is a list. In this case add all $Sectors manually and remove as desired.
         -->
        <param name="CheckPresence"       default="true" comment="Assert if the object is not known by the manager when trying to remove it"/>
        <param name="DebugChance"         default="0"/>
      </params>
      <actions>
        <set_value name="$Manager" exact="md.LIB_Generic.EntityDoNotScanManager"/>
        <!--             $Manager.$EntityTable = table[{$Entity} = table[{$RequesterCue} = table[ $spaces = $spaceslist ]]];
                         $Manager.$EntityTable.{$Entity}.{$RequesterCue}.$spaces = [$space1, $space2, ...]              -->
        <do_all exact="1" comment="handle break conditions instead of unreadable do_if cascades">

          <!-- Param Validation -->
          <do_if value="not (typeof $RequesterCue == datatype.cue)">
            <assert value="typeof $RequesterCue == datatype.cue" text="'Requester Cue ' + $RequesterCue + ' is not of type cue. [Heinrich]'"/>
            <break/>
          </do_if>
          <do_if value="$AddRequest and ($RequesterCue.state != cuestate.active and $RequesterCue.state != cuestate.complete)">
            <assert value="$RequesterCue.state == cuestate.active or $RequesterCue.state == cuestate.complete" text="'Requester cue ' + $RequesterCue + ' is of state ' + $RequesterCue.state + ' which is not allowed. Active or Complete only. [Heinrich]'"/>
            <break/>
          </do_if>
          <do_if value="$AddRequest and (not $Entity.exists)">
            <assert value="$Entity.exists" text="$Entity + 'Object does not exist [Heinrich]'"/>
            <break/>
          </do_if>
          <do_if value="(typeof $DoNotScanSpaces != datatype.list) or (not $DoNotScanSpaces.count)">
            <assert value="typeof $DoNotScanSpaces == datatype.list" text="'DoNotScanSpaces (lib param) is not a list (or empty) [Heinrich]'"/>
            <break/>
          </do_if>
          <do_if value="($DoNotScanSpaces.count gt 1) and ($DoNotScanSpaces.indexof.{player.galaxy})">
            <debug_text text="'DoNotScanSpaces (lib param) contains multiple entries and player.galaxy. All other entries will have no effect. (Read lib param comment) [Heinrich]'"/>
          </do_if>
          <do_if value="(not $AddRequest) and $CheckPresence">
            <!-- Assert if we are trying to remove but the entity is not managed -->
            <assert value="$CheckPresence and $Manager.$EntityTable.{$Entity}? and $Manager.$EntityTable.{$Entity}.{$RequesterCue}?" text="'Manager does not have a request for object ' + $Entity + ' ' + $Entity.knownname + ' by cue ' + $RequesterCue + '. Disable CheckPresence if this is expected. [Heinrich]'"/>
          </do_if>

          <!-- ADD -->
          <do_if value="$AddRequest">
            <!-- Add .$EntityTable.{$Entity}          /// {$Entity} is new -->
            <do_if value="not $Manager.$EntityTable.{$Entity}?">
              <add_to_group groupname="$Manager.$Entities" object="$Entity"/>
              <set_value name="$Manager.$EntityTable.{$Entity}" exact="table[{$RequesterCue} = table[$spaces = []]]"/>
            </do_if>
            <!-- Add .{$Entity}.{$RequesterCue}       /// {$RequesterCue} is new, {$Entity} was known-->
            <do_elseif value="not $Manager.$EntityTable.{$Entity}.{$RequesterCue}?">
              <set_value name="$Manager.$EntityTable.{$Entity}.{$RequesterCue}" exact="table[$spaces = []]"/>
            </do_elseif>

            <!-- Add .{$RequesterCue}.$spaces         /// Add $DoNotScanSpaces -->
            <do_for_each in="$DoNotScanSpaces" name="$space">
              <do_if value="0 == $Manager.$EntityTable.{$Entity}.{$RequesterCue}.$spaces.indexof.{$space}">
                <append_to_list name="$Manager.$EntityTable.{$Entity}.{$RequesterCue}.$spaces" exact="$space"/>
                <debug_text text="'Added DoNotScan request for ' + $Entity + ' ' + $Entity.knownname  + ' bye cue ' + $RequesterCue + ' in ' + $space.knownname" chance="$DebugChance"/>
              </do_if>
            </do_for_each>

          </do_if>
          <!-- REMOVE -->
          <do_elseif value="$Manager.$EntityTable.{$Entity}? and $Manager.$EntityTable.{$Entity}.{$RequesterCue}?" comment="Entity is managed">
            <!-- Clear .{$RequesterCue}.$spaces       /// Remove $DoNotScanSpaces from $spaces-->
            <do_if value="not $DoNotScanSpaces.indexof.{player.galaxy}">
              <do_for_each in="$DoNotScanSpaces" name="$space">
                <do_if value="$Manager.$EntityTable.{$Entity}.{$RequesterCue}.$spaces.indexof.{$space}">
                  <remove_from_list name="$Manager.$EntityTable.{$Entity}.{$RequesterCue}.$spaces" exact="$space"/>
                  <debug_text text="'Removed DoNotScan request for ' + $Entity + ' ' + $Entity.knownname  + ' by cue ' + $RequesterCue + ' in ' + $space.knownname" chance="$DebugChance"/>
                </do_if>
                <do_else>
                  <debug_text text="'No request found for ' + $Entity + ' ' + $Entity.knownname + ' in ' + $space.knownname + ' by ' + $RequesterCue + '. (nothing to remove)'" chance="$DebugChance"/>
                </do_else>
              </do_for_each>
            </do_if>

            <!-- Clear .{$Entity}.{$RequesterCue}     /// {$RequesterCue} removal - player.galaxy was removed OR $spaces is fully emptied -->
            <do_if value="$DoNotScanSpaces.indexof.{player.galaxy} or ($Manager.$EntityTable.{$Entity}.{$RequesterCue}.$spaces.count == 0)">
              <remove_value name="$Manager.$EntityTable.{$Entity}.{$RequesterCue}"/>
              <debug_text text="'No more $DoNotScan requests for ' + $Entity + ' ' + $Entity.knownname + ' by cue ' + $RequesterCue" chance="$DebugChance"/>
              <do_if value="$Manager.$EntityTable.{$Entity}.keys.count">
                <debug_text text="'Remaining Requests for this entity: ' + $Manager.$EntityTable.{$Entity}.keys.list" chance="$DebugChance"/>
              </do_if>
            </do_if>

            <!-- Clear .{$EntityTable}.{$Entity}      /// {Entity} removal - there are no $Entity.{$RequesterCue}s left -->
            <do_if value="not $Manager.$EntityTable.{$Entity}.keys.count">
              <remove_from_group group="$Manager.$Entities" object="$Entity"/>
              <remove_value name="$Manager.$EntityTable.{$Entity}"/>
              <debug_text text="'No more $DoNotScan requests for ' + $Entity + ' ' + $Entity.knownname  + ' bye any cue!'" chance="$DebugChance"/>
            </do_if>

          </do_elseif>

          <!-- UPDATE -->
          <!-- Update $DoNotScan based on current sector and updated requests -->
          <run_actions ref="md.LIB_Generic.EntitySpacesCheck">
            <param name="Entity"       value="$Entity"/>
          </run_actions>
        </do_all>
      </actions>
    </library>

    <library name="SetObjectOwner" purpose="run_actions">
      <params>
        <!-- NB: no default value elicits a warning if param is not provided by the caller -->
        <param name="ObjectParam"/>
        <param name="NewOwner" comment="faction or component with an owner"/>
        <param name="ResetOrders" default="true" comment="Reset orders of ships"/>
        <param name="SetHierarchyOwner" default="false" comment="Change the owner of the top commander and all of their subordinates?"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <do_if value="not $ObjectParam.iswreck and $ObjectParam.isrealclass.controllable">
          <do_if value="$NewOwner">
            <do_if value="typeof $NewOwner == datatype.component">
              <set_value name="$NewOwner" exact="$NewOwner.trueowner"/>
            </do_if>

            <do_if value="typeof $NewOwner == datatype.faction">
              <set_value name="$Objects" exact="[]"/>
              <do_if value="$SetHierarchyOwner and $ObjectParam.isoperational">
                <set_value name="$TopCommander" exact="$ObjectParam.toplevelcommander"/>
                <debug_text text="'Getting hierarchy objects of ' + $ObjectParam + ' ' + $ObjectParam.knownname + ' - topcommander ' + $TopCommander + ' ' + $TopCommander.knownname" chance="$DebugChance"/>
                <append_to_list name="$Objects" exact="$TopCommander"/>
                <append_list_elements name="$Objects" other="$TopCommander.allsubordinates"/>
              </do_if>
              <do_else>
                <append_to_list name="$Objects" exact="$ObjectParam"/>
              </do_else>

              <do_for_each name="$Object" in="$Objects">
                <do_if value="$Object.trueowner != $NewOwner">
                  <debug_text text="'Setting owner of ' + $Object + ' ' + $Object.knownname" chance="$DebugChance"/>
                  <set_owner object="$Object" faction="$NewOwner" overridenpc="true"/>
                </do_if>
                <do_if value="$Object.isoperational">
                  <reset_relation_boost object="$Object" faction="$NewOwner"/>
                  <do_if value="$ResetOrders">
                    <do_if value="@$Object.isjobship">
                      <!-- implicitly cancels all orders and sets default order to that set in job definition. -->
                      <activate_job_ship_orders ship="$Object"/>
                    </do_if>
                    <do_elseif value="$Object.isclass.ship">
                      <cancel_all_orders object="$Object"/>
                    </do_elseif>
                  </do_if>
                </do_if>
              </do_for_each>
            </do_if>
            <do_else>
              <debug_text text="'SetObjectOwner called with invalid NewOwner: %s'.[$NewOwner]" filter="error"/>
            </do_else>
          </do_if>
          <do_else>
            <debug_text text="'SetObjectOwner called with no NewOwner specified.'" filter="error"/>
          </do_else>
        </do_if>
        <do_else>
          <debug_text text="'SetObjectOwner called with invalid object: %s %s %s'.[@$ObjectParam.idcode, @$ObjectParam.knownname, $ObjectParam]" filter="error"/>
        </do_else>
      </actions>
    </library>

    <library name="SuppressChatter_AddCue" purpose="run_actions">
      <params>
        <param name="Cue"                                   comment="Adds Cue to md.$MissionDND and md.$CommChatterDND"/>
        <param name="CancelRemoveCue"   default="true"      comment="Remove the Request if the Cue was cancelled"/>
      </params>
      <!--md.$MissionDND          - List of Cues which block $MissionDND respecting cues
          md.$CommChatterDND      - List of Cues which block Comm Chatter, adds/subtracts onto global.$SuppressCommChatter
        - Cleanup invalid cues whenever a cue gets added / removed
        - Cleanup cancelled cues: md.$SuppressChatter_CueListener table [ $Cue = {Cancel_Helper_Instance} ] -->
      <actions>
        <do_if value="$Cue == null">
          <debug_text text="'Cue is null: ' + $Cue"/>
        </do_if>
        <do_else>

          <!-- Add Cue to md.$MissionDND-->
          <do_if value="not md.$MissionDND.indexof.{$Cue}">
            <append_to_list name="md.$MissionDND" exact="$Cue"/>
            <!-- Caller Cue Cancelled - Cleanup -->
            <do_if value="$CancelRemoveCue">
              <signal_cue_instantly cue="md.LIB_Generic.SuppressChatter_Cancel_Helper" param="$Cue"/>
            </do_if>
          </do_if>
          <do_else>
            <debug_text text="$Cue + ' already in md.$MissionDND ' + md.$MissionDND"/>
          </do_else>

          <!-- Add Cue to md.$CommChatterDND-->
          <run_actions ref="md.LIB_Generic.SuppressCommChatter_AddCue">
            <param name="Cue" value="$Cue"/>
          </run_actions>

        </do_else>

        <!-- Cleanup invalidated Cues from List -->
        <run_actions ref="md.LIB_Generic.Remove_Invalid_Cues_From_List">
          <param name="List" value="md.$MissionDND"/>
        </run_actions>
      </actions>
    </library>

    <library name="SuppressChatter_RemoveCue" purpose="run_actions">
      <params>
        <param name="Cue"/>
        <param name="DebugExistence" default="true"/>
      </params>
      <actions>
        <do_if value="$Cue == null">
          <debug_text text="'Cue is null'"/>
        </do_if>
        <do_else>

          <!-- Remove Cue from md.$MissionDND-->
          <do_if value="md.$MissionDND.indexof.{$Cue}">
            <remove_from_list name="md.$MissionDND" exact="$Cue"/>
          </do_if>
          <do_elseif value="$DebugExistence">
            <debug_text text="$Cue + ' not in md.$MissionDND ' + md.$MissionDND"/>
          </do_elseif>

          <!-- Remove Cue from md.$CommChatterDND-->
          <run_actions ref="md.LIB_Generic.SuppressCommChatter_RemoveCue">
            <param name="Cue" value="$Cue"/>
            <param name="DebugExistence" value="$DebugExistence"/>
          </run_actions>

          <!-- Cleanup SuppressChatter_Cancel_Helper Listener -->
          <do_if value="md.$SuppressChatter_CueListener.{$Cue}?">
            <do_if value="md.$SuppressChatter_CueListener.{$Cue}.exists">
              <cancel_cue cue="md.$SuppressChatter_CueListener.{$Cue}"/>
            </do_if>
            <remove_value name="md.$SuppressChatter_CueListener.{$Cue}"/>
          </do_if>

        </do_else>

        <!-- Cleanup invalidated Cues from List -->
        <run_actions ref="md.LIB_Generic.Remove_Invalid_Cues_From_List">
          <param name="List" value="md.$MissionDND"/>
        </run_actions>
      </actions>
    </library>

    <cue name="SuppressChatter_Cancel_Helper" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled/>
        <check_value value="typeof event.param == datatype.cue"/>
      </conditions>
      <actions>
        <set_value name="this.$CancelledCue" exact="event.param"/>
        <set_value name="md.$SuppressChatter_CueListener.{$CancelledCue}" exact="this"/>
        <!--<debug_text text="md.$SuppressChatter_CueListener"/>-->
      </actions>
      <cues>
        <cue name="SuppressChatter_CancelledCue_Cleanup">
          <conditions>
            <event_cue_cancelled cue="parent.$CancelledCue"/>
          </conditions>
          <actions>
            <debug_text text="'$Cue cancelled, cleaning up SuppressChatter Request for: ' + parent.$CancelledCue"/>

            <!-- Cleans up SuppressChatter and SuppressCommChatter -->
            <run_actions ref="md.LIB_Generic.SuppressChatter_RemoveCue">
              <param name="Cue" value="parent.$CancelledCue"/>
            </run_actions>

          </actions>
        </cue>
      </cues>
    </cue>

    <library name="SuppressCommChatter_AddCue" purpose="run_actions">
      <params>
        <param name="Cue"/>
      </params>
      <actions>
        <do_if value="$Cue == null">
          <debug_text text="'Cue is null'"/>
        </do_if>
        <do_else>

          <!-- Add Cue to md.$CommChatterDND-->
          <do_if value="not md.$CommChatterDND.indexof.{$Cue}">
            <append_to_list name="md.$CommChatterDND" exact="$Cue"/>
            <set_value name="global.$SuppressCommChatter" operation="add" exact="1"/>
          </do_if>
          <do_else>
            <debug_text text="$Cue + ' already in md.$CommChatterDND ' + md.$CommChatterDND"/>
          </do_else>

        </do_else>

        <!-- Cleanup invalidated Cues from $CommChatterDND List-->
        <run_actions ref="md.LIB_Generic.Remove_Invalid_Cues_From_List" result="$RemovalCounter">
          <param name="List" value="md.$CommChatterDND"/>
        </run_actions>
        <do_if value="$RemovalCounter">
          <set_value name="global.$SuppressCommChatter" operation="subtract" exact="$RemovalCounter"/>
        </do_if>

        <!--<debug_text text="md.$MissionDND + ' ' + md.$CommChatterDND"/>-->
      </actions>
    </library>

    <library name="SuppressCommChatter_RemoveCue" purpose="run_actions">
      <params>
        <param name="Cue"/>
        <param name="DebugExistence" default="true"/>
      </params>
      <actions>
        <do_if value="$Cue == null">
          <debug_text text="'Cue is null! ' + $Cue"/>
        </do_if>
        <do_else>

          <!-- Remove Cue from md.$CommChatterDND-->
          <do_if value="md.$CommChatterDND.indexof.{$Cue}">
            <remove_from_list name="md.$CommChatterDND" exact="$Cue"/>
            <set_value name="global.$SuppressCommChatter" operation="subtract" exact="1"/>
          </do_if>
          <do_elseif value="$DebugExistence">
            <debug_text text="$Cue + ' not in md.$CommChatterDND ' + md.$CommChatterDND"/>
          </do_elseif>

        </do_else>

        <!-- Cleanup invalidated Cues from md.$CommChatterDND List-->
        <run_actions ref="md.LIB_Generic.Remove_Invalid_Cues_From_List" result="$RemovalCounter">
          <param name="List" value="md.$CommChatterDND"/>
        </run_actions>
        <do_if value="$RemovalCounter">
          <set_value name="global.$SuppressCommChatter" operation="subtract" exact="$RemovalCounter"/>
        </do_if>

        <!--<debug_text text="md.$MissionDND + ' ' + md.$CommChatterDND"/>-->
      </actions>
    </library>

    <library name="Remove_Invalid_Cues_From_List" purpose="run_actions">
      <params>
        <param name="List"/>
      </params>
      <actions>
        <set_value name="$RemovalCounter" exact="0"/>
        <do_for_each in="$List" name="$Cue" reverse="true">
          <do_if value="not $Cue.exists" comment="Catch cues invalidated by loading a save with deprecated cues">
            <remove_from_list name="$List" exact="$Cue"/>
            <set_value name="$RemovalCounter" exact="1" operation="add"/>
          </do_if>
        </do_for_each>
        <do_if value="$RemovalCounter">
          <debug_text text="'Removed invalid Cues: ' + $RemovalCounter"/>
        </do_if>
        <return value="$RemovalCounter"/>
      </actions>
    </library>

    <library name="Friendly_Fire_Protection">
      <params>
        <param name="Object"/>
        <param name="ProtectionDuration" default="20s"/>
        <param name="CancelCue"/>
        <param name="DebugChance"        default="0"/>
      </params>
      <cues>

        <cue name="Friendly_Fire_Protection_Activate">
          <conditions>
            <event_object_attacked_object group="global.$PlayerContainerGroup"/>
            <check_value value="event.param.sector" comment="False if event.param is on superhighway"/>
            <check_value value="event.param.sector == $Object.sector"/>
            <check_value value="event.param.distanceto.{$Object} le $Object.maxradarrange"/>
            <check_value value="event.param.owner" comment="Objects without owner also have no relation"/>
            <check_value value="event.param.owner.relationto.{$Object.trueowner} le $Object.trueowner.relation.killmilitary.max"/>
          </conditions>
          <actions>
            <do_if value="Friendly_Fire_Protection_Enable.state == cuestate.complete">
              <debug_text text="'Player attacked enemy of ' + $Object.knownname + '. Resetting friendly fire protection timer.'" chance="$DebugChance"/>
              <reset_cue cue="Friendly_Fire_Protection_Disable"/>
            </do_if>
            <do_else>
              <debug_text text="'Player attacked enemy of ' + $Object.knownname + '. Starting friendly fire protection timer.'" chance="$DebugChance"/>
              <signal_cue cue="Friendly_Fire_Protection_Enable"/>
            </do_else>
          </actions>
          <delay exact="1s"/>
          <actions>
            <reset_cue cue="this"/>
          </actions>
        </cue>

        <cue name="Friendly_Fire_Protection_Enable">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <set_object_relation_behaviour object="$Object" disable="true"/>
          </actions>
          <cues>

            <cue name="Friendly_Fire_Protection_Disable">
              <actions>
                <debug_text text="'Relation behaviour disabled for ' + $ProtectionDuration + '.'" chance="$DebugChance"/>
              </actions>
              <delay exact="$ProtectionDuration"/>
              <actions>
                <set_object_relation_behaviour object="$Object" disable="false"/>
                <reset_cue cue="parent"/>
              </actions>
            </cue>

          </cues>
        </cue>

        <cue name="Friendly_Fire_Protection_Cancel">
          <conditions>
            <event_cue_completed cue="$CancelCue"/>
          </conditions>
          <actions>
            <debug_text text="$CancelCue + 'completed. Friendly fire protection for ' + $Object.knownname + ' ends.'" chance="$DebugChance"/>
            <set_object_relation_behaviour object="$Object" disable="false"/>
            <cancel_cue cue="parent"/>
          </actions>
        </cue>
      </cues>
    </library>

    <library name="PlayerInSpecificShip_Objective_Handler">
      <!-- If you want the player to dock/fly somewhere in a specific ship, this lib will toggle the objective between embark, dockat and the proper objective accordingly. -->
      <!-- Cancel this lib when the Ship reached the objective (docked at something, entered space/area) -->
      <params>
        <param name="Ship"            comment="Ship the player should be in"/>
        <param name="ObjectiveCue"    comment="Proper Objective Signalled when the player is inside the ship, Should be Instantiating"/>
        <param name="MissionCue"      comment="Adding objective to the correct $MissionCue"/>
      </params>
      <cues>

        <cue name="Set_Initial_Objective">
          <actions>
            <do_if value="player.ship != $Ship">
              <do_if value="$Ship.dock">
                <set_objective cue="$MissionCue" action="objective.embark" object="$Ship"/>
              </do_if>
              <do_else>
                <set_objective cue="$MissionCue" action="objective.dockat" object="$Ship"/>
              </do_else>
            </do_if>
            <do_else>
              <signal_cue cue="$ObjectiveCue"/>
            </do_else>
          </actions>
          <cues>

            <cue name="EnterShip" instantiate="true">
              <conditions>
                <event_object_changed_object object="player.entity" previous="$Ship"/>
              </conditions>
              <actions>
                <do_if value="$Ship.dock">
                  <set_objective cue="$MissionCue" action="objective.embark" object="$Ship"/>
                </do_if>
                <do_else>
                  <set_objective cue="$MissionCue" action="objective.dockat" object="$Ship"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EnterShipDifferently" instantiate="true">
              <conditions>
                <check_any>
                  <event_object_docked object="$Ship"/>
                  <event_object_undocked object="$Ship"/>
                </check_any>
                <check_value value="player.entity.ship != $Ship"/>
              </conditions>
              <actions>
                <do_if value="$Ship.dock">
                  <set_objective cue="$MissionCue" action="objective.embark" object="$Ship"/>
                </do_if>
                <do_else>
                  <set_objective cue="$MissionCue" action="objective.dockat" object="$Ship"/>
                </do_else>
              </actions>
            </cue>

            <cue name="FlyTo" instantiate="true">
              <conditions>
                <event_object_changed_object object="player.entity" newobject="$Ship"/>
              </conditions>
              <actions>
                <signal_cue cue="$ObjectiveCue"/>
              </actions>
            </cue>

          </cues>
        </cue>
      </cues>
    </library>

    <library name="WaitForFactionsToHaveStations" purpose="run_actions">
      <params>
        <param name="Factions"                          comment="list"/>
        <param name="SignalCue"                         comment="will receive station as event.param"/>
        <param name="DockExists"    default="true"/>
        <param name="CheckInterval" default="307s"      comment="~5 minutes"/>
      </params>
      <actions>
        <do_for_each in="$Factions" name="$faction">
          <signal_cue_instantly cue="WaitForFactionToHaveStations_Check" param="table[$faction = $faction,
                                                                                      $SignalCue = $SignalCue,
                                                                                      $DockExists = $DockExists,
                                                                                      $CheckInterval = $CheckInterval
                                                                                                    ]"/>
        </do_for_each>
      </actions>
    </library>
    <cue name="WaitForFactionToHaveStations_Check" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$Faction"        exact="event.param.$faction"/>
        <set_value name="$SignalCue"      exact="event.param.$SignalCue"/>
        <set_value name="$DockExists"     exact="event.param.$DockExists"/>
        <set_value name="$CheckInterval"  exact="event.param.$CheckInterval"/>
      </actions>
      <cues>
        <cue name="WaitForFactionToHaveStations_Delay">
          <!--<count_stations trueowner="$Faction" min="1" space="player.galaxy" multiple="false" result="$Station"/>-->
          <delay exact="$CheckInterval"/>
          <actions>
            <!-- Only check for existance + $DockExists, not docking relations or so -->
            <do_if value="$DockExists">
              <find_station_by_true_owner name="$Station" space="player.galaxy" multiple="false" faction="$Faction">
                <match_dock walkable="true"/>
              </find_station_by_true_owner>
            </do_if>
            <do_else>
              <find_station_by_true_owner name="$Station" space="player.galaxy" multiple="false" faction="$Faction"/>
            </do_else>

            <do_if value="$Station.exists">
              <signal_cue_instantly cue="$SignalCue" check="false" param="$Faction"/>
            </do_if>
            <do_else>
              <reset_cue cue="this"/>
            </do_else>
          </actions>
          <cues>
            <cue name="WaitForFactionToHaveStations_Cancel" comment="Cleanup if another instance (looking for another faction) is successful">
              <conditions>
                <event_cue_signalled cue="$SignalCue"/>
              </conditions>
              <actions>
                <cancel_cue cue="parent"/>
              </actions>
            </cue>
          </cues>
        </cue>
      </cues>
    </cue>

    <!-- wrapper around Cleanup_Mission_Interior (which forces parameters to exist) -->
    <library name="Cleanup_Mission_Interior_Call" purpose="run_actions">
      <params>
        <param name="Object"/>
        <param name="Interior"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <signal_cue_instantly cue="md.LIB_Generic.Cleanup_Mission_Interior" param="table[$Object = $Object, $Interior = $Interior, $DebugChance = $DebugChance]"/>
      </actions>
    </library>

    <!--Remove a mission created interior when the object leaves high attention
    event.param = table[
      $Object,
      $Interior,
      $DebugChance (optional)]-->
    <!-- ALWAYS USE Cleanup_Mission_Interior_Call TO ENFORCE PARAMS -->
    <cue name="Cleanup_Mission_Interior" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$Object" exact="event.param.$Object"/>
        <set_value name="$Interior" exact="event.param.$Interior"/>
        <set_value name="$DebugChance" exact="@event.param.$DebugChance"/>
        <do_if value="not $Object.exists or not $Interior.exists">
          <debug_text text="'Invalid parameters. Objects do not exist. Object: ' + $Object + ' ' + @$Object.knownname + ' Interior: ' + $Interior + ' ' + $Interior.knownname" filter="error"/>
          <cancel_cue cue="this"/>
        </do_if>
        <do_elseif value="$Object.attention lt attention.nearby">
          <remove_dynamic_interior object="$Object" interior="$Interior"/>
          <cancel_cue cue="this"/>
        </do_elseif>
      </actions>
      <cues>
        <cue name="Cleanup_Mission_Interior_Despawn">
          <conditions>
            <event_object_interiors_despawning object="$Object"/>
          </conditions>
          <actions>
            <debug_text text="'Destroying interior ' + $Interior + ' ' + $Interior.knownname" chance="$DebugChance"/>
            <remove_dynamic_interior object="$Object" interior="$Interior"/>
            <cancel_cue cue="namespace"/>
          </actions>
        </cue>
        <cue name="Cleanup_Mission_Interior_Killed">
          <conditions>
            <event_object_destroyed object="$Object"/>
          </conditions>
          <actions>
            <debug_text text="'Object ' + $Object + ' ' + $Object.knownname + ' destroyed'" chance="$DebugChance"/>
            <cancel_cue cue="namespace"/>
          </actions>
        </cue>
      </cues>
    </cue>

    <library name="TransportStoryPassenger">
      <!--
            The Passenger & Conversation was placed in the story.
            After: passenger_onboard -> c_movepassenger_destinationselected is successful,
                   the library is called to move the passenger into the ship
            1) Passenger moves to $PassengerShip
            2) Guide Player to $PassengerShip, wait for Passenger if not there yet
            3) DockAt $PassengerTarget
              3a) Guide player back to $PassengerShip if they leave it
            4) Success when $PassengerShip and player reach $PassengerTarget
      -->
      <params>
        <param name="Passenger"/>
        <param name="PassengerShip"                   comment="passenger already c_movepassenger_destinationselected"/>
        <param name="PassengerTarget"                 comment="Destination"/>
        <param name="SignalCueSuccess"/>
        <param name="SignalCuePassengerEmbark"        comment="NPC entered ship"/>
        <param name="SignalCueDestroyedTarget"/>
        <param name="SignalCueDestroyedShip"/>
        <param name="DebugChance"                     default="0"/>
        <param name="MissionName"                     default="''"/>
        <param name="MissionCue"/>
        <param name="ObjectiveStep"/>
        <param name="DisconnectPassenger"             default="false" comment="true: disconnect, false: spawn in duschkabine after reaching target. Use true if you want to spawn them somewhere afterwards instead of having them walk there."/>
        <!--<param name="PlayerOnTarget"  default="true"  comment="Success only after the PassengerShip and Player are on the target
                                                               (otherwise the lib will guide the player to deliver the passenger/dock independently)"/>-->
      </params>
      <actions>
        <set_value name="this.$DeepDebugChance" exact="0"/>
        <set_value name="$Passenger_Onboard" exact="false"/>
      </actions>
      <cues>
        <!-- Add $Passenger to $PassengerShip -->
        <cue name="TransportStoryPassenger_AddToShip">
          <actions>
            <!-- Create Passenger Template On Ship -->
            <create_npc_template name="$PassengerTemplate" object="$PassengerShip" entity="$Passenger" role="entityrole.passenger"/>
            <assert value="$PassengerTemplate" text="'Attempted to add passenger to the playership but it failed. [Owen]'"/>
            <do_if value="$PassengerTemplate">
              <!-- Make Actor a passenger and move them to the Ship -->
              <find_npc_waypoint name="this.$DespawnWaypoints" object="$PassengerShip" tags="tag.npctransport" multiple="true"/>
              <assert value="this.$DespawnWaypoints.count"
                      text="'No waypoints on ' + $PassengerShip + ' ' + $PassengerShip.knownname + ' tagged ' + tag.npctransport + '. No place to despawn passengers.'"/>
              <do_if value="this.$DespawnWaypoints.count and $Passenger.exists">
                <set_entity_role        entity="$Passenger" role="entityrole.passenger"/>
                <set_entity_role_object entity="$Passenger" object="$PassengerShip"/>
                <signal_cue_instantly cue="md.NPC_Instantiation.NPC_Placement_Manager"
                                      param="['add_definition', $Passenger,
                                                          table[
                                                           $requestercue = $MissionCue,
                                                           $location = this.$DespawnWaypoints.random,
                                                           $priority = 100,
                                                           $debugchance = parent.$DeepDebugChance,
                                                           $debugcaller = if $DebugChance == 100 then this else null]
                                                         ]"/>
              </do_if>
              <do_else>
                <remove_actor_from_room actor="$Passenger"/>
              </do_else>
            </do_if>
          </actions>
        </cue>

        <!-- Guide Player and Await Passenger to be in $PassengerShip -->
        <cue name="TransportStoryPassenger_SpecificShip" ref="md.LIB_Generic.PlayerInSpecificShip_Objective_Handler">
          <param name="Ship"             value="$PassengerShip"/>
          <param name="ObjectiveCue"     value="TransportStoryPassenger_PlayerInShip"/>
          <param name="MissionCue"       value="$MissionCue"/>
        </cue>
        <cue name="TransportStoryPassenger_PlayerInShip">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <do_if value="(not $Passenger.hascontext.{$PassengerShip})
                      and (not $Passenger_Onboard)">
              <set_objective object="$Passenger" cue="$MissionCue"
                             action="objective.await" step="$ObjectiveStep"
                             updatebriefing="true"/>
            </do_if>
          </actions>
          <cues>
            <cue name="TransportStoryPassenger_PlayerLeftShip">
              <conditions>
                <event_object_changed_object object="player.entity"/>
                <check_value value="not player.entity.hascontext.{$PassengerShip}"/>
              </conditions>
              <actions>
                <reset_cue cue="TransportStoryPassenger_PlayerInShip"/>
                <reset_cue cue="TransportStoryPassenger_SpecificShip"/>
              </actions>
            </cue>
          </cues>
        </cue>
        <cue name="TransportStoryPassenger_PassengerInShip">
          <conditions>
            <event_object_changed_object object="$Passenger" newobject="$PassengerShip"/>
          </conditions>
          <actions>
            <debug_text text="'Passenger has Ship Context'" chance="$DebugChance"/>
            <substitute_text text="$Notification" source="readtext.{30004}.{5102}">
              <replace string="'$SHIP$'" with="$PassengerShip.name" />
              <replace string="'$PASSENGER$'" with="$Passenger.knownname" />
            </substitute_text>
            <show_notification text="[$MissionName, '', $Notification]" />

            <set_value name="$Passenger_Onboard" exact="true"/>
            <signal_cue cue="$SignalCuePassengerEmbark" check="false"
                        chance="if $SignalCuePassengerEmbark then 100 else 0"/>
          </actions>
          <cues>
            <cue name="TransportStoryPassenger_DisconnectPassenger" onfail="cancel">
              <conditions>
                <check_value value="$DisconnectPassenger"/>
              </conditions>
              <actions>
                <debug_text text="'Delayed Passenger Disconnect'" chance="$DebugChance"/>
                <signal_cue_instantly cue="md.NPC_Instantiation.NPC_Placement_Manager" param="['add_definition', $Passenger,
                                                   table[
                                                   $requestercue = $MissionCue,
                                                   $location = 'disconnect',
                                                   $priority = 100,
                                                   $debugchance = $DeepDebugChance,
                                                   $debugcaller = if $DebugChance == 100 then this else null]
                                                   ]"/>
              </actions>
            </cue>

            <cue name="TransportStoryPassenger_PassengerLeftShip">
              <conditions>
                <event_object_changed_object object="$Passenger"/>
                <check_value value="not $Passenger.hascontext.{$PassengerShip}"/>
              </conditions>
              <actions>
                <!-- false alarm when undocking while the passenger is climbing up the ladder -->
                <!--<assert value="false" text="'Passenger left PassengerShip Unexpectedly! [Heinrich]'"/>-->
              </actions>
            </cue>
          </cues>
        </cue>

        <!-- Passenger + Player on Ship - Guide to Target-->
        <cue name="TransportStoryPassenger_Objective_Flyto" instantiate="true">
          <conditions>
            <check_any>
              <event_cue_signalled cue="TransportStoryPassenger_PlayerInShip"/>
              <event_cue_completed cue="TransportStoryPassenger_PassengerInShip"/>
            </check_any>
            <check_value value="player.entity.hascontext.{$PassengerShip}"/>
            <check_value    value="$Passenger_Onboard"/>
          </conditions>
          <actions>
            <set_objective object="$PassengerTarget" cue="$MissionCue"
                           action="objective.dockat" step="$ObjectiveStep"
                           updatebriefing="true"/>
            <debug_text text="'Passenger and Player have Ship Context'" chance="$DebugChance"/>
          </actions>
        </cue>

        <!-- Wait for Passenger (and optionally Player) to reach $PassengerTarget-->
        <cue name="TransportStoryPassenger_PlayerDockedAtPassengerTarget" instantiate="true">
          <conditions>
            <event_object_docked group="global.$PlayerShipsGroup"/>
            <check_value value="event.param == $PassengerTarget"/>
          </conditions>
          <actions>
            <signal_cue cue="TransportStoryPassenger_Passenger_Transport_End"/>
          </actions>
        </cue>
        <cue name="TransportStoryPassenger_PassengerShipDockedAtPassengerTarget" instantiate="true">
          <conditions>
            <event_object_docked object="$PassengerShip"/>
            <check_value value="event.param == $PassengerTarget"/>
          </conditions>
          <actions>
            <signal_cue cue="TransportStoryPassenger_Passenger_Transport_End"/>
          </actions>
        </cue>
        <!-- Success -->
        <cue name="TransportStoryPassenger_Passenger_Transport_End" instantiate="true">
          <conditions>
            <event_cue_signalled/>
            <check_value value="$PassengerShip.hascontext.{$PassengerTarget}"/>
          </conditions>
          <actions>
            <cancel_cue cue="TransportStoryPassenger_SpecificShip" comment="Cancel Objective Resetting"/>
            <cancel_cue cue="TransportStoryPassenger_Objective_Flyto" comment="Cancel Objective Resetting"/>
            <!-- Remove Passenger -->
            <remove_npc_template object="$PassengerShip" template="$PassengerTemplate"/>
            <do_if value="not $DisconnectPassenger">
              <find_npc_waypoint name="this.$DespawnWaypoints" object="$PassengerShip" tags="tag.npctransport" multiple="true"/>
              <signal_cue_instantly cue="md.NPC_Instantiation.NPC_Placement_Manager" param="['add_definition', $Passenger,
                                                                                                      table[
                                                                                                      $requestercue = $MissionCue,
                                                                                                      $location = this.$DespawnWaypoints.random,
                                                                                                      $priority = 100,
                                                                                                      $debugchance = parent.$DeepDebugChance,
                                                                                                      $debugcaller = if $DebugChance == 100 then this else null]
                                                                                                      ]"/>
            </do_if>
            <signal_cue cue="$SignalCueSuccess"/>
          </actions>
        </cue>
        <!-- FailSafes -->
        <cue name="TransportStoryPassenger_Failsafe_TargetDestroyed">
          <conditions>
            <event_object_destroyed object="$PassengerTarget"/>
          </conditions>
          <actions>
            <signal_cue cue="$SignalCueDestroyedTarget"/>
          </actions>
        </cue>
        <cue name="TransportStoryPassenger_Failsafe_ShipDestroyed">
          <conditions>
            <event_object_destroyed object="$PassengerShip"/>
          </conditions>
          <actions>
            <signal_cue cue="$SignalCueDestroyedShip"/>
          </actions>
        </cue>
      </cues>
    </library>

    <library name="RetrieveShip">
      <!-- will endlessly retrieve $Ship and potentially send into storage $Ship.class ships -->
      <!-- cancel the lib or undock $Ship to stop retrieving $Ship -->
      <params>
        <param name="Ship"/>
        <param name="SignalCue_Retrieved"     comment="can be signalled multiple times, also signalled on Undock/Not Docked (so at least once)"/>
        <param name="RetrieveInterval"        default="15s" comment="Attempt retrieving again with this interval"/>
        <param name="DebugChance"             default="0"/>
      </params>
      <cues>
        <cue name="RetrieveShip_Request">
          <actions>
            <do_if value="$Ship.dock and $Ship.dock.isstorage">
              <!-- attempt retrieval of $Ship from internal storage (possible the playership is occupying the dock) -->
              <request_retrieval queuedresult="$QueuedResult1" grantedresult="$GrantedResult1" ship="$Ship" highpriority="false" allowplayeronly="true" />
              <debug_text text="'request_retrieval for %s (%s) request=%s granted=%s'.[$Ship, $Ship.name, $QueuedResult1, $GrantedResult1]" chance="$DebugChance"/>
              <do_if value="not $GrantedResult1">
                <!-- retrieval failed, force whatever ship is docked into internal storage to retrieve $Ship-->
                <find_object_component name="$dockedships" docked="true" object="$Ship.container" includeobjects="true" multiple="true" class="$Ship.class">
                  <match_parent>
                    <match_dock storage="false"/>
                  </match_parent>
                </find_object_component>
                <do_for_each name="$dockedship" in="$dockedships">
                  <do_if value="$dockedship != $Ship" comment="just in case, avoid putting back Axiom's $Ship into storage">
                    <request_store_ship object="$Ship.container" allowplayeronly="true" highpriority="false" ship="$dockedship">
                      <storage skiptimeout="true" />
                    </request_store_ship>
                    <debug_text text="'request_store_ship for %s (%s), one space should be enough, no further storage requests'.[$dockedship, $dockedship.name]" chance="$DebugChance"/>
                    <break comment="freed up space should be enough" />
                  </do_if>
                </do_for_each>
              </do_if>
            </do_if>
          </actions>
          <delay exact="$RetrieveInterval"/>
          <actions>
            <reset_cue cue="this" comment="periodically re-request to avoid it put back in storage permanently"/>
          </actions>
        </cue>

        <cue name="RetrieveShip_Retrieved_Check" onfail="cancel">
          <conditions>
            <check_value value="$Ship.dock and (not $Ship.dock.isstorage)"/>
          </conditions>
          <actions>
            <signal_cue cue="RetrieveShip_Retrieved_Event" check="false"/>
          </actions>
        </cue>
        <cue name="RetrieveShip_Retrieved_Event">
          <conditions>
            <check_any>
              <event_cue_signalled/>
              <event_object_retrieved_from_internal_storage object="$Ship"/>
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'retrieved ' + $Ship.name + ' ' + $Ship + ' from storage'" chance="$DebugChance"/>
            <signal_cue cue="$SignalCue_Retrieved" check="false"/>
            <reset_cue cue="this"/>
          </actions>
        </cue>

        <cue name="RetrieveShip_Undocked_Check" onfail="cancel">
          <conditions>
            <check_value value="not $Ship.dock"/>
          </conditions>
          <actions>
            <signal_cue cue="RetrieveShip_Undocked_Event"/>
          </actions>
        </cue>
        <cue name="RetrieveShip_Undocked_Event">
          <conditions>
            <check_any>
              <event_cue_signalled/>
              <event_object_undocked object="$Ship"/>
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'Cancelling Lib as the ship undocked: ' + $Ship.name + ' ' + $Ship" chance="$DebugChance"/>
            <signal_cue cue="$SignalCue_Retrieved" check="false"/>
            <cancel_cue cue="parent"/>
          </actions>
        </cue>
      </cues>
    </library>

    <!-- 
      purpose: get safety level of sector.
      note: review StationSafety_Constants for constants.
      input:
        Sector: class.space or class.component
        Faction: datatype.faction
        Station (optional): class.station
      output:
        <return value="table[
          $Level = $Level,
          $Stations_Friend = $Stations_Friend,
          $Stations_Enemy = $Stations_Enemy
        ]" />
      notes:
        $SafetyLevel_Overwhelmed = any station count > 5 and friendly stations / enemy stations < 0.5
        $SafetyLevel_Balanced = any station count > 5 and friendlies / enemies < 0.75
        $SafetyLevel_Safe = otherwise
    -->
    <library name="GetSectorSafety" purpose="run_actions">
      <params>
        <param name="Sector" />
        <param name="Faction" />
        <param name="Station" default="null" />
      </params>
      <actions>
        <include_actions ref="StationSafety_Constants" />
        <set_value name="$Level" exact="$SafetyLevel_Safe" />
        <set_value name="$ComponentFrom_DistSort" exact="$Station" />
        <do_if value="not $ComponentFrom_DistSort">
          <set_value name="$ComponentFrom_DistSort" exact="$Sector" />
        </do_if>
        <find_station name="$Stations_Friend" space="$Sector" multiple="true" sortbydistanceto="$ComponentFrom_DistSort">
          <match_relation_of faction="$Faction" comparison="gt" relation="enemy"/>
        </find_station>
        <find_station name="$Stations_Enemy" space="$Sector" multiple="true" sortbydistanceto="$ComponentFrom_DistSort">
          <match_relation_of faction="$Faction" comparison="le" relation="enemy"/>
        </find_station>
        <set_value name="$Stations_Total" exact="$Stations_Friend.count + $Stations_Enemy.count" />
        <do_if value="$Stations_Total gt 5">
          <do_if value="($Stations_Friend.count + 1) / ($Stations_Enemy.count + 1)f lt 0.5">
            <set_value name="$Level" exact="$SafetyLevel_Overwhelmed" />
          </do_if>
          <do_elseif value="($Stations_Friend.count + 1) / ($Stations_Enemy.count + 1)f lt 0.75">
            <set_value name="$Level" exact="$SafetyLevel_Balanced" />
          </do_elseif>
        </do_if>
        <return value="table[
          $Level = $Level,
          $Stations_Friend = $Stations_Friend,
          $Stations_Enemy = $Stations_Enemy
        ]" />
      </actions>
    </library>
    <library name="StationSafety_Constants">
      <actions>
        <set_value name="$SafetyLevel_Overwhelmed" exact="1" />
        <set_value name="$SafetyLevel_Balanced" exact="2" />
        <set_value name="$SafetyLevel_Safe" exact="3" />
      </actions>
    </library>

    <!--
      purpose: create nav beacons on the map for debugging purposes.
      input:
        Id: string,
        Name: string,
        Space: datatype.space,
        Position: datatype.position
    -->
    <cue name="DebugPositions" namespace="this">
      <actions>
        <set_value name="$Beacons" exact="table[]" />
      </actions>
      <cues>
        <cue name="DebugPositions_DestroyAllBeacons">
          <conditions>
            <event_cue_signalled />
          </conditions>
          <actions>
            <do_for_each valuename="$Beacon" in="md.LIB_Generic.DebugPositions.$Beacons">
              <destroy_object object="$Beacon" />
            </do_for_each>
            <reset_cue cue="this" />
          </actions>
        </cue>
        <library name="DebugPositions_AddBeacon" purpose="run_actions">
          <params>
            <param name="Id" />
            <param name="Name" />
            <param name="Space" />
            <param name="Position" default="null" />
          </params>
          <actions>
            <do_if value="not @md.LIB_Generic.DebugPositions.$Beacons">
              <set_value name="md.LIB_Generic.DebugPositions.$Beacons" exact="table[] "/>
            </do_if>
            <do_if value="@md.LIB_Generic.DebugPositions.$Beacons.{'$' + $Id}">
              <destroy_object object="md.LIB_Generic.DebugPositions.$Beacons.{'$' + $Id}" />
              <remove_value name="md.LIB_Generic.DebugPositions.$Beacons.{'$' + $Id}" />
            </do_if>
            <do_if value="not $Position">
              <create_position name="$Position" x="0" y="0" z="0" />
            </do_if>
            <do_if value="(not @$Space.isclass.sector) and $Space.sector">
              <set_value name="$Sector" exact="$Space.sector" />
              <create_position name="$Position" space="$Sector" object="$Space" value="$Position" />
            </do_if>
            <do_else>
              <set_value name="$Sector" exact="$Space" />
            </do_else>
            <create_object name="$Beacon" sector="$Sector" macro="macro.env_deco_nav_beacon_t1_macro" owner="faction.player">
              <position value="$Position" />
            </create_object>
            <set_value name="md.LIB_Generic.DebugPositions.$Beacons.{'$' + $Id}" exact="$Beacon" />
            <set_object_name object="md.LIB_Generic.DebugPositions.$Beacons.{'$' + $Id}" name="$Name" />
            <return value="md.LIB_Generic.DebugPositions.$Beacons.{'$' + $Id}" />
          </actions>
        </library>
      </cues>
    </cue>

    <library name="Position_GetIsInTheWay" purpose="run_actions">
      <params>
        <param name="Position1" />
        <param name="Position2" />
        <param name="PositionTest" />
        <param name="DebugChance" default="0" />
      </params>
      <actions>
        <do_if value="$Position1.isclass.sector">
          <create_position name="$Position1" space="$Position1" object="$Position1" />
        </do_if>
        <do_else>
          <create_position name="$Position1" space="$Position1.sector" object="$Position1" />
        </do_else>
        <do_if value="$Position2.isclass.sector">
          <create_position name="$Position2" space="$Position2" object="$Position2" />
        </do_if>
        <do_else>
          <create_position name="$Position2" space="$Position2.sector" object="$Position2" />
        </do_else>
        <do_if value="$PositionTest.isclass.sector">
          <create_position name="$PositionTest" space="$PositionTest" object="$PositionTest" />
        </do_if>
        <do_else>
          <create_position name="$PositionTest" space="$PositionTest.sector" object="$PositionTest" />
        </do_else>
        <create_orientation name="$Rot_toPosition2" orientation="look_at" refposition="$Position2">
          <position value="$Position1" />
        </create_orientation>
        <set_value name="$Yaw_toPosition2" exact="$Rot_toPosition2.yaw * 180 / pi" />
        <create_orientation name="$Rot_toPositionTest" orientation="look_at" refposition="$PositionTest">
          <position value="$Position1" />
        </create_orientation>
        <set_value name="$Yaw_toPositionTest" exact="$Rot_toPositionTest.yaw * 180 / pi" />
        <set_value name="$Yaw_Diff" exact="$Yaw_toPosition2 - $Yaw_toPositionTest" />
        <!-- 80km = 15deg ... 0km = 5deg -->
        <set_value name="$Distance" exact="$Position1.distanceto.{$Position2}" />
        <set_value name="$Angle_InTheWay" exact="[15 - $Distance / 80km * (15 - 5), 5].max" />
        <set_value name="$IsInTheWay" exact="
          $Position1.distanceto.{$PositionTest} lt $Position1.distanceto.{$Position2} and
          $Yaw_Diff gt (-1 * $Angle_InTheWay) and $Yaw_Diff lt $Angle_InTheWay
        " />
        <do_if value="$DebugChance">
          <debug_text text="'$Position1.distanceto.{$Position2}: ' + $Position1.distanceto.{$Position2}" />
          <debug_text text="'$Position1.distanceto.{$PositionTest}: ' + $Position1.distanceto.{$PositionTest}" />
          <debug_text text="'$Angle_InTheWay: ' + $Angle_InTheWay" />
          <debug_text text="'$Yaw_Diff: ' + $Yaw_Diff" />
          <debug_text text="'$IsInTheWay: ' + $IsInTheWay" />
        </do_if>
        <return value="$IsInTheWay" />
      </actions>
    </library>

    <!-- purpose: get list of positions that make a shape.
      inputs:
        Position (create_position),
        Shape ("cube", "square", "wall", "disc", "sphere"),
        Size (length),
        Interval (length),
        Orientation (create_orientation)
      output: list of positions -->
    <library name="Shape_GetPositions" purpose="run_actions">
      <params>
        <param name="Shape" />
        <param name="Position" />
        <param name="Orientation" default="null" />
        <param name="Size" default="20km" />
        <param name="Interval" default="3km" />
      </params>
      <actions>
        <set_value name="$Positions" exact="[]" />
        <do_if value="$Shape == 'cube' or $Shape == 'square' or $Shape == 'wall'">
          <run_actions ref="md.LIB_Generic.Shape_GetPositions_Cube" result="$Positions">
            <param name="Position" value="$Position" />
            <param name="Shape" value="$Shape" />
            <param name="Orientation" value="$Orientation" />
            <param name="Size" value="$Size" />
            <param name="Interval" value="$Interval" />
          </run_actions>
        </do_if>
        <do_elseif value="$Shape == 'disc' or $Shape == 'sphere'">
          <run_actions ref="md.LIB_Generic.Shape_GetPositions_Sphere" result="$Positions">
            <param name="Position" value="$Position" />
            <param name="Shape" value="$Shape" />
            <param name="Size" value="$Size" />
            <param name="Interval" value="$Interval" />
          </run_actions>
        </do_elseif>
        <sort_list list="$Positions" sortbyvalue="loop.element.distanceto.{$Position}" />
        <return value="$Positions" />
      </actions>
    </library>

    <library name="Shape_GetPositions_Cube" purpose="run_actions">
      <params>
        <param name="Shape" />
        <param name="Position" />
        <param name="Orientation" default="null" />
        <param name="Size" default="20km" />
        <param name="Interval" default="3km" />
      </params>
      <actions>
        <set_value name="$Positions" exact="[]" />
        <set_value name="$Interval_Y" exact="$Interval" />
        <do_if value="$Size le $Interval_Y">
          <set_value name="$Interval_Y" exact="$Size" />
        </do_if>
        <do_if value="$Interval_Y == 0">
          <set_value name="$Interval_Y" exact="3km" />
        </do_if>
        <set_value name="$Width_Total" exact="$Size" />
        <set_value name="$Segments" exact="($Width_Total / $Interval_Y)i" />
        <set_value name="$Width_TotalFitted" exact="$Segments * $Interval_Y" />
        <set_value name="$Y_max" exact="0" />
        <do_if value="$Shape == 'square'">
          <set_value name="$Y" exact="0" />
          <set_value name="$Y_max" exact="0" />
        </do_if>
        <do_else>
          <set_value name="$Y" exact="$Width_TotalFitted / -2f" />
          <set_value name="$Y_max" exact="$Width_TotalFitted / 2f" />
        </do_else>
        <do_while value="$Y le $Y_max">
          <set_value name="$Interval_X" exact="$Interval" />
          <do_if value="$Shape == 'wall'"
            comment="width is double the height">
            <set_value name="$X" exact="$Width_TotalFitted / -2f * 2" />
            <set_value name="$Max_X" exact="$Width_TotalFitted / 2f * 2" />
          </do_if>
          <do_else>
            <set_value name="$X" exact="$Width_TotalFitted / -2f" />
            <set_value name="$Max_X" exact="$Width_TotalFitted / 2f" />
          </do_else>
          <do_while value="$X le $Max_X">
            <set_value name="$Interval_Z" exact="$Interval" />
            <do_if value="$Shape == 'wall'"
              comment="depth is half the height">
              <set_value name="$Z" exact="$Width_TotalFitted / -2f * 0.5" />
              <set_value name="$Max_Z" exact="$Width_TotalFitted / 2f * 0.5" />
            </do_if>
            <do_else>
              <set_value name="$Z" exact="$Width_TotalFitted / -2f" />
              <set_value name="$Max_Z" exact="$Width_TotalFitted / 2f" />
            </do_else>
            <do_while value="$Z le $Max_Z">
              <do_if value="$Orientation">
                <transform_position name="$Point_New" refposition="$Position" refrotation="$Orientation">
                  <position x="$X" y="$Y" z="$Z" />
                </transform_position>
              </do_if>
              <do_else>
                <create_position name="$Point_New" x="$Position.x + $X" y="$Position.y + $Y" z="$Position.z + $Z" />
              </do_else>
              <append_to_list name="$Positions" exact="$Point_New" />
              <set_value name="$Z" exact="$Z + $Interval_Z" />
            </do_while>
            <set_value name="$X" exact="$X + $Interval_X" />
          </do_while>
          <set_value name="$Y" exact="$Y + $Interval_Y" />
        </do_while>
        <return value="$Positions" />
      </actions>
    </library>

    <library name="Shape_GetPositions_Sphere" purpose="run_actions">
      <params>
        <param name="Shape" />
        <param name="Position" />
        <param name="Size" default="20km" />
        <param name="Interval" default="3km" />
      </params>
      <actions>
        <set_value name="$Positions" exact="[]" />
        <set_value name="$Interval_Y" exact="$Interval" />
        <do_if value="$Size le $Interval_Y">
          <set_value name="$Interval_Y" exact="$Size" />
        </do_if>
        <do_if value="$Interval_Y == 0">
          <set_value name="$Interval_Y" exact="3km" />
        </do_if>
        <set_value name="$Radius_Y" exact="$Size * 0.5" />
        <set_value name="$Diameter_Y" exact="$Size" />
        <set_value name="$Segments_y" exact="($Diameter_Y / $Interval_Y)i" />
        <set_value name="$Diameter_YFitted" exact="$Segments_y * $Interval_Y" />
        <do_if value="$Shape == 'disc'">
          <set_value name="$Y" exact="0" />
          <set_value name="$Y_max" exact="0" />
        </do_if>
        <do_else>
          <set_value name="$Y" exact="$Diameter_YFitted / -2f" />
          <set_value name="$Y_max" exact="$Diameter_YFitted / 2f" />
        </do_else>
        <do_while value="$Y le $Y_max">
          <set_value name="$Interval_XZ" exact="$Interval" />
          <set_value name="$Radius_XZ" exact="sqrt (($Diameter_YFitted / 2f) * ($Diameter_YFitted / 2f) - $Y * $Y)" />
          <set_value name="$Diameter_XZ" exact="$Radius_XZ * 2" />
          <set_value name="$Segments_y" exact="($Diameter_XZ / $Interval_XZ)i" />
          <set_value name="$Diameter_XZFitted" exact="$Segments_y * $Interval_XZ" />
          <set_value name="$XZ" exact="$Diameter_XZFitted  / -2f" />
          <do_while value="$XZ le 0">
            <set_value name="$Length_XZ" exact="sqrt ($XZ * $XZ)" />
            <set_value name="$ArcLength" exact="(2 * pi)f * $Length_XZ" />
            <set_value name="$Positions_Max" exact="($ArcLength / $Interval_XZ + 0.5)i" />
            <do_if value="$Positions_Max lt 1">
              <set_value name="$Positions_Max" exact="1" />
            </do_if>
            <do_all counter="$i" exact="$Positions_Max">
              <set_value name="$Theta" exact="2 * pi / $Positions_Max" />
              <set_value name="$Angle" exact="$Theta * $i" />
              <set_value name="$X" exact="$Length_XZ * cos($Angle)" />
              <set_value name="$Z" exact="$Length_XZ * sin($Angle)" />
              <create_position name="$Point_New" x="$Position.x + $X" y="$Position.y + $Y" z="$Position.z + $Z" />
              <append_to_list name="$Positions" exact="$Point_New" />
            </do_all>
            <set_value name="$XZ" exact="$XZ + $Interval_XZ" />
          </do_while>
          <set_value name="$Y" exact="$Y + $Interval_Y" />
        </do_while>
        <return value="$Positions" />
      </actions>
    </library>

    <library name="Create_Position_On_Plane" purpose="run_actions">
      <params>
        <param name="AnchorPos" default="position.[0m, 0m, 0m]"/>
        <param name="Distance"/>
        <param name="Yaw" default="[0deg, 360deg].randominrange"/>
        <param name="SafeposSpace" default="null" comment="Sector or Zone in which to find a safe position. $AnchorPos must be in this coordinate space."/>
        <param name="SafeposRadius" default="0m"/>
      </params>
      <actions>
        <set_value name="$SecSpawnPos" exact="null"/>
        <do_if value="$SafeposSpace">
          <do_if value="$SafeposSpace.isclass.sector">
            <get_safe_pos result="$SecSpawnPos" x="$AnchorPos.x + sin($Yaw) * $Distance" y="$AnchorPos.y" z="$AnchorPos.z + cos($Yaw) * $Distance" sector="$SafeposSpace" radius="$SafeposRadius"/>
          </do_if>
          <do_elseif value="$SafeposSpace.isclass.zone">
            <get_safe_pos result="$SecSpawnPos" x="$AnchorPos.x + sin($Yaw) * $Distance" y="$AnchorPos.y" z="$AnchorPos.z + cos($Yaw) * $Distance" zone="$SafeposSpace" radius="$SafeposRadius"/>
          </do_elseif>
          <do_else>
            <debug_text text="'Parameter SafeposSpace is not a valid sector or zone: ' + $SafeposSpace" filter="error"/>
          </do_else>
        </do_if>
        <do_else>
          <create_position name="$SecSpawnPos" x="$AnchorPos.x + sin($Yaw) * $Distance" y="$AnchorPos.y" z="$AnchorPos.z + cos($Yaw) * $Distance"/>
        </do_else>
        <return value="$SecSpawnPos"/>
      </actions>
    </library>

    <!--Temporary implementation to find NPC slots by group. If group is not required then find via find_npc_slot as usual.-->
    <library name="Find_NPC_Slots_By_Group" purpose="run_actions">
      <params>
        <param name="ObjectOrRoom"/>
        <param name="Group" comment="Group tag e.g. tag.npc_audience. Use null for groupless slots."/>
        <param name="Tags" default="null"/>
        <param name="ExcludeBlocked" default="true"/>
        <param name="ExcludeFilled" default="true"/>
        <param name="Multiple" default="false"/>
      </params>
      <actions>
        <find_npc_slot name="$Slots" object="$ObjectOrRoom" tags="$Tags" excludeblocked="$ExcludeBlocked" excludefilled="$ExcludeFilled" multiple="true"/>
        <do_if value="$Multiple">
          <do_all exact="$Slots.count" counter="$i" reverse="true">
            <do_if value="$Slots.{$i}.group != $Group">
              <remove_value name="$Slots.{$i}"/>
            </do_if>
          </do_all>
          <return value="$Slots"/>
        </do_if>
        <do_else>
          <shuffle_list list="$Slots"/>
          <do_for_each name="$Slot" in="$Slots">
            <do_if value="$Slot.group == $Group">
              <return value="$Slot"/>
            </do_if>
          </do_for_each>
          <return value="null"/>
        </do_else>
      </actions>
    </library>

    <!-- Wait for the player to add a module of the specified class to the specified station in the Plan Build menu and confirm changes, then add the required wares to the Build Storage. -->
    <library name="Add_Wares_For_Module" purpose="cue_ref">
      <params>
        <param name="Station"/>
        <param name="ModuleClass"/>
        <param name="ExcludedWares" comment="List of wares that should not be added to the build storage"/>
        <param name="DebugChance" default="0"/>
      </params>
      <cues>

        <cue name="Add_Wares_For_Module_Player_Build_Added">
          <conditions>
            <event_player_build_added container="$Station.buildstorage"/>
            <check_value value="event.param.isexpansion"/>
            <check_value value="event.param.constructionsequence"/>
            <check_any exact="event.param.constructionsequence.count" counter="$i">
              <check_value value="event.param.constructionsequence.{$i}.macro.isclass.{$ModuleClass}"/>
            </check_any>
          </conditions>
          <actions>
            <set_value name="$BuildStorage" exact="$Station.buildstorage"/>
            <set_value name="$ResourcesTable" exact="null"/>

            <!-- Warning: currently, the entire construction sequence is evaluated, which also includes the modules that have already been built!
                 So if the player adds a module that doesn't match the required class, and the station already contains a module of that class, this cue will detect that existing module.
                 Michael suggests the following, if we want to update the library:
                 - check $station.planmodule.{$ConstructionSequence.{$i}.id} which will return the module (could be in state operational, wreck or construction) or nothing if the module hasn't been built yet
                 - at the time of the event you are probably only interested in modules that haven't been built yet - so if the above returns a module that .exists it's in some form pre-existing, otherwise it's been newly added to the plan -->
            <do_all exact="event.param.constructionsequence.count" counter="$i" reverse="true">
              <debug_text text="'Checking module macro: ' + event.param.constructionsequence.{$i}.macro" chance="$DebugChance"/>
              <do_if value="event.param.constructionsequence.{$i}.macro.isclass.{$ModuleClass}">
                <set_value name="$ResourcesTable" exact="event.param.constructionsequence.{$i}.macro.ware.resources.table"/>
                <debug_text text="event.param.constructionsequence.{$i}.macro + ' has the correct class (' + $ModuleClass + '). Required resources: ' + $ResourcesTable" chance="$DebugChance"/>
                <break />
              </do_if>
            </do_all>

            <do_if value="$ResourcesTable">
              <do_for_each in="$ResourcesTable" name="$CurrentWare">
                <do_if value="not $ExcludedWares.indexof.{$CurrentWare}">
                  <add_cargo object="$BuildStorage" ware="$CurrentWare" exact="$ResourcesTable.{$CurrentWare}"/>
                  <debug_text text="'Adding ' + $ResourcesTable.{$CurrentWare} + ' ' + $CurrentWare" chance="$DebugChance"/>
                </do_if>
              </do_for_each>
            </do_if>
            <do_else>
              <reset_cue cue="this"/>
            </do_else>
          </actions>
        </cue>

      </cues>
    </library>

  </cues>
</mdscript>
