<?xml version="1.0" encoding="utf-8"?>
<mdscript name="GM_Ambush" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">
  <cues>

    <!--Base Mission information-->
    <!--
      Generic Mission: Destroy Objects - specific script for use with different missions
      Primary 'missiontype':  missiontype.destroy
      Page: 30159
      Notes:
        To start the mission, make use of gmc_dynemic breadcrumb style missions
    -->

    <!-- Variant Table -->
    <cue name="TextOffsets" namespace="this" onfail="cancel">
      <conditions>
        <check_value value="false" comment="not used for generic missions"/>
      </conditions>
      <actions>
        <set_value name="$Cue" exact="md.GM_Ambush.GenerateGenericMission"/>
        <append_to_list name="md.GenericMissions.Manager.$StaticGMCues" exact="$Cue" create="true" unique="true"/>
        <set_value name="$Cue.$TextOffsets" exact="table[]" comment="$Cue.$TextOffsets.{$Page}.{$TextOffset}"/>
        <set_value name="$Cue.$TextOffsets.{30159}"
                   exact="table[ {1000} = table[$lastoffertime = 0s, $offercounter = 0]
                          ]"/>
      </actions>
    </cue>

    <!--
      The Feedback Manager contains a table of feedback values related to this Generic Mission. 
		  This table is 'const' during the mission (the table itself doesn't change anymore after inialization)
	    There are several maintypes of feedback:
        event:    Something which happens during a mission but does not cause it to end e.g. the mission being accepted
        removed:  The mission offer was removed before acceptance
        success:  The mission was successfully completed by the player
        failure:  The player failed the mission
        error:    Something went wrong with the mission set-up or during the mission
    -->
    <cue name="FeedbackValueManager" namespace="this" version="6">
      <actions>
        <set_value name="$FeedbackValues" exact="table[
                   $MISSION_GENERATED       = table[$type = 'event',    $text = 'Mission variation generated successfully'],
                   $MISSION_ACCEPTED        = table[$type = 'event',    $text = 'Mission accepted'],
                   $MISSION_NO_VARIANT      = table[$type = 'event',    $text = 'No mission variant currently possible'],
                   $MISSION_NO_NPC_SCENE    = table[$type = 'event',    $text = 'No mission NPC scene could be set up'],
                   
                   $OFFER_REMOVED           = table[$type = 'removed',  $text = 'Offer removed'],
                   $DECLINED_OFFER          = table[$type = 'removed',  $text = 'Player declined Event Offer'],
                   $EVENT_OFFER_TIMEOUT     = table[$type = 'removed',  $text = 'Event Offer timeout'],
                   $SIGNAL_LEAK_REMOVED     = table[$type = 'removed',  $text = 'Signal leak offer removed'],
                   $TARGET_KILLED_EARLY     = table[$type = 'removed',  $text = 'Object was destroyed during the offer'],
                   
                   $MISSION_SUCCEEDED       = table[$type = 'success',  $text = 'Mission succeeded'],
                   
                   $MISSION_ABORTED         = table[$type = 'failure',  $text = 'Mission aborted by player'],
                   $FORCED_CLEANUP          = table[$type = 'failure',  $text = 'Forced to end from outside'],
                   $MISSION_TIMEOUT         = table[$type = 'failure',  $text = 'Mission timeout'],
                   $RML_FAILED              = table[$type = 'failure',  $text = 'RML failure'],
                   $TARGET_PLAYER_OWNED     = table[$type = 'failure',  $text = 'Object became player owned during offer'],
                   
                   $NO_VALID_CLIENT_OWNER   = table[$type = 'error',    $text = 'No valid ClientOwner parameter provided'],
                   $INVALID_OFFER_TYPE      = table[$type = 'error',    $text = 'No offer parameters were valid'],
                   $NO_TEXT_OFFSET          = table[$type = 'error',    $text = 'No TextOffset set'],
                   $INVALID_FORCE_CLEANUP   = table[$type = 'error',    $text = 'ForceCleanup cue invalid'],
                   $INVALID_TARGETS_PARAM   = table[$type = 'error',    $text = 'No objects found to destroy'],
                   $NO_VALID_TARGETS        = table[$type = 'error',    $text = 'No objects existed on the acceptance of the mission'],
                   $RML_ERROR               = table[$type = 'error',    $text = 'RML error']
                   ]"/>
      </actions>
      <patch sinceversion="6">
        <!--To patch new feedback values, increment 'version' and 'sinceversion' number-->
        <force_cue cue="FeedbackValueManager"/>
      </patch>
    </cue>

    <!--Required variables: $Page & $TextOffset (and any below substitute_text values)
    If text is to be substituted for a new text variant, people should feel free to add the substitution below. Alternativly, pass in an overriding text in the $TextTable param-->
    <library name="GenerateTextTable">
      <actions>
        <!-- Register unknown TextOffsets to the TextOffsets table -->
        <run_actions ref="md.GenericMissions.RegisterMissionVariant">
          <param name="StaticGMCue" value="md.GM_Destroy_Objects.GenerateGenericMission"/>
          <param name="Page"        value="$Page"/>
          <param name="TextOffset"  value="$TextOffset"/>
        </run_actions>

        <!--Text page indexes $TextOffset + #
        1 = $TextTable.$missionname
        2 = $TextTable.$description
        3 = $TextTable.$objective-->

        <!--$TextTable.$missionname + 1-->
        <set_value name="$TextTable.$missionname" exact="readtext.{$Page}.{$TextOffset + 1}" chance="if $TextTable.$missionname? then 0 else 100"/>

        <!--$TextTable.$description + 2-->
        <do_if value="not $TextTable.$description?">
          <substitute_text text="$TextTable.$description" source="readtext.{$Page}.{$TextOffset + 2}">
            <replace string="'$SECTOR$'" with="$TargetSector.knownname"/>
          </substitute_text>

          <do_if value="$Targets.count and $Targets.{1}.macro == macro.env_ast_ore_m_explosive_03_macro and readtext.{$Page}.{$TextOffset + 11}?">
            <set_value name="$TextTable.$description" exact="$TextTable.$description + '\n' + readtext.{$Page}.{$TextOffset + 11}"/>
          </do_if>


          <do_if value="$Targets.count">
            <!-- Note: In this case $TargetSector is the NAME of the sector, not the sector itself, so we can't pass that as TargetSpace -->
            <run_actions ref="md.LIB_Generic.GenerateTextTable_BriefingWarning_Call" result="$TextTable.$description">
              <param name="BriefingText" value="$TextTable.$description"/>
              <param name="TargetSpace" value="$Targets.{1}.sector"/>
            </run_actions>
          </do_if>

        </do_if>

        <!--$TextTable.$objective + 3 e.g (Destroy: )Ad Signs / Enemy Ship-->
        <set_value name="$TextTable.$objective" exact="readtext.{$Page}.{$TextOffset + 3}" chance="if $TextTable.$objective? then 0 else 100"/>
      </actions>
    </library>

    <!--
    ####################
    TARGET TRACKING
    ####################
    -->

    <!--event.param: [$ResultCue, $Target, $OfferFaction, $AddToList]
    
    Result saved to $ResultCue.$CheckTarget__Result
    Result is bool - true: Object can be used, false: Object already used by another mission-->
    <cue name="CheckTarget" instantiate="true" namespace="static">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$DebugChance" exact="0"/>
        <set_value name="$ResultCue" exact="event.param.{1}"/>

        <do_if value="not $TrackedTargets?">
          <create_list name="$TrackedTargets"/>
        </do_if>

        <set_value name="$Target" exact="[event.param.{2}, event.param.{3}]"/>
        <do_if value="$TrackedTargets.indexof.{$Target}">
          <debug_text text="'Return false: ' + $Target" chance="$DebugChance"/>
          <!--Return false-->
          <set_value name="$ResultCue.$CheckTarget__Result" exact="false"/>
        </do_if>
        <do_else>
          <do_if value="event.param.{4}">
            <append_to_list name="$TrackedTargets" exact="$Target"/>
          </do_if>
          <!--Only keep the 100 most recent targets-->
          <do_if value="$TrackedTargets.count" min="100">
            <remove_value name="$TrackedTargets.{1}"/>
          </do_if>

          <!--Return true-->
          <debug_text text="'***Return true: ' + $Target" chance="$DebugChance"/>
          <set_value name="$ResultCue.$CheckTarget__Result" exact="true"/>
        </do_else>
      </actions>
    </cue>

    <cue name="RemoveTarget" instantiate="true" namespace="static">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$DebugChance" exact="0"/>

        <do_if value="not CheckTarget.$TrackedTargets?">
          <create_list name="CheckTarget.$TrackedTargets"/>
        </do_if>

        <set_value name="$Target" exact="[event.param.{1}, event.param.{2}]"/>
        <set_value name="$Index" exact="CheckTarget.$TrackedTargets.indexof.{$Target}"/>
        <do_if value="$Index">
          <remove_value name="CheckTarget.$TrackedTargets.{$Index}"/>
          <debug_text text="'Removed ' + $Target + ' from target list ' + CheckTarget.$TrackedTargets" chance="$DebugChance"/>
        </do_if>
      </actions>
    </cue>

    <library name="GenerateVoiceTable">
      <actions>
        <run_actions ref="md.LIB_Generic.GenerateGenericVoiceTable" result="$VoiceTable">
          <param name="VoiceTable" value="$VoiceTable"/>
        </run_actions>
      </actions>
    </library>

    <library name="Start">
      <params>
        <param name="OfferObject" default="null" comment="The object on which this mission is based e.g. A Ship / Station / Signal Leak. Only needed for missions with a physical location."/>
        <param name="Client" default="null" comment="Pre-existing client"/>
        <param name="ClientOwner" default="null" comment="Overriding owner for reward calculation or creation of $Client if not provided. Defaults to $OfferObject owner if able"/>
        <param name="MissionCue" default="null" comment="Cue the mission is attached to. Defaults to Start (this)."/>
        <param name="MissionThread" default="null" comment="Mission thread for the offer and mission"/>

        <param name="GenerateReward" default="true" comment="If RewardCr or RewardNotoriety are invalid, generate them?"/>
        <param name="RewardCr" default="null" comment="If the reward for this mission is credits, the number of credits should be set to this variable." />
        <param name="RewardObj" default="null" comment="If the reward for this mission is not credits, and is an object, it should be set to this variable." />
        <param name="RewardNotoriety" default="null"/>
        <param name="RewardText" default="null" comment="Any text needed to define the reward for this mission - can be used in conjunction with $RewardCr and $RewardObj" />
        <param name="MissionDuration" default="null"/>
        <param name="MissionType" default="missiontype.destroy" comment="Variations can override mission type if required"/>
        <param name="MissionLevel"/>
        <param name="Difficulty"/>

        <!--Offer params-->
        <param name="WithoutOffer" default="false" comment="Do not create a mission offer. Either run immediatly or wait for WithoutOfferWaitCue"/>
        <param name="WithoutOfferWaitCue" default="null" comment="Do not create a mission offer but wait for this cue to be completed before running the mission (if event.param is passed, it must match 'Start' cue)"/>
        <param name="DeclineButton" default="true" comment="Have a decline button instead of a back button in the offer conversation"/>
        <param name="EventOffer" default="false" comment="Is the mission offered directly to the player with an interactive event"/>
        <param name="ConversationOffer" default="false" comment="When $EventOffer is false, should this offer be through a conversation with the $Client. Otherwise, offer at mission location"/>
        <param name="ConversationTriggerCue" default="null" comment="If provided, when this cue is signalled, start the mission offer conversation."/>
        <param name="OfferMaxDistance" default="null" comment="Maximum distance to OfferObject before it is cleaned up. null = do not check"/>
        <param name="HideFromBBS" default="false" comment="Hide this offer from the BBS? Show only through locations or special conversation handling."/>
        <param name="RemoveOnSectorChange" default="true"/>
        <param name="OfferDistance" default="50km" comment="Distance to the offer location before it becomes visible on the map or BBS (unless otherwise hidden)"/>

        <!--BBS only params-->
        <param name="BBSObject" default="null"/>
        <param name="BBSDistance" default="null"/>
        <param name="BBSTimeoutMin" default="null"/>
        <param name="BBSTimeoutMax" default="null"/>
        <param name="BBSSpace" default="null"/>

        <!--Mission text-->
        <param name="Page"                comment="Text page. Text IDs must be correctly with a text offset (see GenerateTextTable)."/>
        <param name="TextOffset"          comment="The text offset for this variant's text on the page"/>
        <param name="TextTable"           default="table[]" comment="Table, usually populated by the mission, to store the texts by an identifier key e.g. $missionname = 'Kill Bala Gi'
               Check library 'GenerateTextTable' for identifier keys. Pass in a table with such an entry to override the text usually generated from the $Page and $TextOffset"/>
        <param name="VoiceTable" default="table[]" comment="Table, usually populated by the mission, keys can have a value of 0 (=stay silent)"/>

        <!--Mission specific params-->
        <param name="Targets"                             comment="Group of objects that should be destroyed during this mission" />
        <param name="TargetRequestCue"    default="null"  comment="Cue to signal to request new targets if the current group is invalid when the mission starts. Cue passed as event.param. Result saved to event.param.$Targets. Mission fails if no targets provided."/>
        <param name="OpposingFaction"     default="null"/>

        <param name="ReportSignalCue"     default="null"  comment="Cue to be signalled when something happens which could be of interest to the calling cue. Saves values to ReportSignalCue.$FeedbackValue and ReportSignalCue.$EndFeedbackValue"/>
        <param name="CancelOfferCue"      default="null"  comment="Cue which when completed will force this missions offer to be removed and cleaned up. No effect if mission has been accepted."/>
        <param name="ForceCleanup"        default="null"  comment="Cue to force a cleanup from outside when completed"/>
        <param name="DebugChance"         default="0"/>
      </params>
      <actions>
        <set_value name="$Feedback" exact="null"/>
        <set_value name="$FeedbackManager" exact="md.GM_Destroy_Objects.FeedbackValueManager"/>

        <assert value="$WithoutOffer or not $MissionCue or (not $MissionCue.hasmission and not $MissionCue.hasmissionoffer)"
                text="'Mission is set to create an offer but provided MissionCue: ' + $MissionCue + ' already has an offer or is a running mission [Owen]'"/>


        <!--Param validation-->
        <do_if value="not $WithoutOffer">
          <!--Optional variables (at least one should exist): $OfferObject, (bool)$HideFromBBS, (bool)$ConversationOffer, (bool)$EventOffer
          Result variables:
          $OfferType = 'signalleak' OR 'objectbased' OR 'eventoffer' OR 'conversationoffer'
          $AllowOfferEvent = Will an event offering this event be also fired immediatly?-->
          <include_actions ref="md.GenericMissions.GetOfferType"/>
          <do_if value="not $OfferType">
            <set_value name="$Feedback" exact="'$INVALID_OFFER_TYPE'"/>
          </do_if>
        </do_if>

        <do_if value="not $Feedback">
          <do_if value="not $TextOffset">
            <set_value name="$Feedback" exact="'$NO_TEXT_OFFSET'"/>
          </do_if>
          <do_else>
            <do_if value="$Client">
              <set_value name="$PreexistingClient"/>
            </do_if>
            <do_if value="not $ClientOwner">
              <set_value name="$ClientOwner" exact="if $Client then $Client.owner else @$OfferObject.owner"/>
              <assert value="$ClientOwner" text="'No valid $ClientOwner [Owen]'"/>
            </do_if>

            <do_if value="not $ClientOwner">
              <set_value name="$Feedback" exact="'$NO_VALID_CLIENT_OWNER'"/>
            </do_if>
            <do_else>
              <!--Mission specific param checks-->
              <do_if value="not $TargetRequestCue" comment="If TargetRequestCue is set, then the mission will initialize $Targets in the callback">
                <do_if value="typeof $Targets != datatype.group or $Targets.count == 0">
                  <set_value name="$Feedback" exact="'$INVALID_TARGETS_PARAM'"/>
                </do_if>
              </do_if>
            </do_else>
          </do_else>
        </do_if>
      </actions>
      <cues>
        <cue name="Do_Not_Start_Mission" onfail="cancel">
          <conditions>
            <check_value value="$Feedback"/>
          </conditions>
          <actions>
            <signal_cue cue="CleanUp"/>
          </actions>
        </cue>

        <cue name="Do_Start_Mission" onfail="cancel">
          <conditions>
            <check_value value="not $Feedback" />
          </conditions>
          <actions>
            <do_if value="not $MissionCue">
              <set_value name="$MissionCue" exact="Start"/>
            </do_if>

            <do_if value="not $PreexistingClient?">
              <create_cue_actor cue="Start" name="$Client">
                <select faction="$ClientOwner" tags="tag.crew"/>
                <owner exact="$ClientOwner"/>
              </create_cue_actor>
            </do_if>

            <!-- Determine the reward (credits/object/notoriety) -->
            <do_if value="$GenerateReward">
              <include_actions ref="md.LIB_Reward_Balancing.Allocate_RewardWeight" comment="input: $Difficulty, $ClientOwner; output: $RewardCreditsWeight, $RewardModWeight, $RewardSeminarWeight"/>
              <do_if value="not $RewardCr" weight="$RewardCreditsWeight">
                <signal_cue_instantly cue="md.LIB_Reward_Balancing.Reward_Money" param="[Start, $Difficulty, $MissionLevel, $ClientOwner]" comment="basic reward credits"/>
                <include_actions ref="md.LIB_Reward_Balancing.Apply_RewardMultiplier" comment="signal leak and mission thread bonus"/>
                <set_value name="$RewardCr" exact="$Reward_Money__Result_Multiplied"/>
              </do_if>
              <do_if value="not $RewardObj">
                <run_actions ref="md.LIB_Reward_Balancing.DetermineAdditionalReward" result="$AdditionalReward">
                  <param name="RewardModWeight" value="$RewardModWeight"/>
                  <param name="RewardSeminarWeight" value="$RewardSeminarWeight"/>
                </run_actions>
                <do_if value="$AdditionalReward != null">
                  <set_value name="$RewardObj" exact="$AdditionalReward"/>
                  <set_value name="$RewardText" exact="$RewardObj.name"/>
                </do_if>
              </do_if>

              <do_if value="not $RewardNotoriety">
                <signal_cue_instantly cue="md.LIB_Reward_Balancing.Reward_Notoriety" param="[Start, $Difficulty, $MissionLevel, $ClientOwner]"/>
                <set_value name="$RewardNotoriety" exact="$Reward_Notoriety__Result"/>
              </do_if>
            </do_if>

            <include_actions ref="GenerateTextTable"/>
            <include_actions ref="GenerateVoiceTable"/>

            <!--Mission has passed checks - start preparing things for the offer-->
            <do_if value="$ReportSignalCue">
              <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_GENERATED.clone"/>
              <set_value name="$FeedbackData.$ID" exact="'$MISSION_GENERATED'"/>
              <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="Mission variation generated successfully"/>
              <signal_cue_instantly cue="$ReportSignalCue" param="table[$Name = $TextTable.$missionname, $Cue = $MissionCue, $Reward = $RewardCr, $RewardText = $RewardText]"/>
            </do_if>
          </actions>
          <cues>
            <cue name="With_Offer" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer" exact="false"/>
              </conditions>
              <actions>
                <do_if value="$Difficulty" max="level.easy">
                  <set_value name="$ConversationStartLine" exact="1000102" comment="Client says that the mission is relatively easy."/>
                </do_if>
                <do_elseif value="$Difficulty" min="level.medium">
                  <set_value name="$ConversationStartLine" exact="1000103" comment="Client says that the mission is relatively difficult."/>
                </do_elseif>
                <do_else>
                  <set_value name="$ConversationStartLine" exact="1000101" comment="other"/>
                </do_else>
              </actions>
              <cues>
                <cue name="CreateOffer" instantiate="true" comment="instanced to prevent cleanup">
                  <conditions>
                    <event_cue_signalled/>
                    <check_value value="not @$OfferCreated"/>
                  </conditions>
                  <actions>
                    <do_if value="not @$OfferCreated">
                      <create_offer cue="$MissionCue" location="$OfferObject" distance="$OfferDistance" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" actor="$Client"
                                  faction="$ClientOwner" opposingfaction="$OpposingFaction" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText" duration="$MissionDuration" hidden="$HideFromBBS" space="$BBSSpace">
                        <briefing>
                          <objective step="1" action="objective.destroy" text="$TextTable.$objective" encyclopedia="if $Targets.count then $Targets.{1} else null"/>
                        </briefing>
                      </create_offer>
                      <!-- Offers might be outside the $OfferDistance (default 50km) and not seen by players but still count up -->
                      <run_actions ref="md.GenericMissions.UpdateTextOffsetsTable">
                        <param name="StaticGMCue" value="md.GM_Destroy_Objects.GenerateGenericMission"/>
                        <param name="Page"        value="$Page"/>
                        <param name="TextOffset"  value="$TextOffset"/>
                      </run_actions>
                    </do_if>
                    <set_value name="$OfferCreated" exact="true"/>
                  </actions>
                </cue>

                <cue name="Offer_Management" ref="md.GenericMissions.OfferMission">
                  <param name="OfferType"     value="$OfferType"/>
                  <param name="OfferCue"      value="$MissionCue"/>
                  <param name="CleanupCue"    value="Offer_End"/>
                  <param name="BriefingSetupCue" value="CreateOffer"/>
                  <param name="MissionName"   value="$TextTable.$missionname"/>
                  <param name="CancelOfferCue" value="$CancelOfferCue"/>

                  <!--Object based params-->
                  <param name="TimeoutMin"  value="8min"/>
                  <param name="TimeoutMax"  value="12min"/>
                  <param name="MaxDistance" value="$OfferMaxDistance"/>
                  <param name="RemoveOnSectorChange" value="$RemoveOnSectorChange"/>

                  <!--Object and Signal Leak based params-->
                  <param name="OfferObject" value="$OfferObject"/>

                  <!--BBS based offers-->
                  <param name="BBSObject"     value="@$BBSObject"/>
                  <param name="BBSDistance"   value="@$BBSDistance"/>
                  <param name="BBSTimeoutMin" value="@$BBSTimeoutMin"/>
                  <param name="BBSTimeoutMax" value="@$BBSTimeoutMax"/>

                  <!--Conversation event offers-->
                  <param name="AllowOfferEvent" value="$AllowOfferEvent"/>
                  <param name="ConversationTriggerCue" value="$ConversationTriggerCue"/>

                  <!--Client-->
                  <param name="Client"                 value="$Client"/>
                  <param name="VoiceTable"             value="$VoiceTable"/>

                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <cue name="Offer_End">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <do_if value="this.$Feedback.$ID == '$accepted_offer'">
                      <signal_cue cue="MissionAccepted"/>
                    </do_if>
                    <do_elseif value="this.$Feedback.$ID == '$DECLINED_OFFER'">
                      <set_value name="$Feedback" exact="'$DECLINED_OFFER'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$OFFER_REMOVED'">
                      <set_value name="$Feedback" exact="'$OFFER_REMOVED'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$SIGNAL_LEAK_REMOVED'">
                      <set_value name="$Feedback" exact="'$SIGNAL_LEAK_REMOVED'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$EVENT_OFFER_TIMEOUT'">
                      <set_value name="$Feedback" exact="'$EVENT_OFFER_TIMEOUT'"/>
                      <signal_cue cue="CleanUp" />
                    </do_elseif>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="Without_Offer" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer"/>
                <check_value value="not $WithoutOfferWaitCue"/>
              </conditions>
              <actions>
                <signal_cue cue="MissionAccepted" />
              </actions>
            </cue>

            <cue name="Without_Offer_Wait_Cue" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer"/>
                <check_value value="$WithoutOfferWaitCue"/>
              </conditions>
              <cues>
                <cue name="Without_Offer_Wait_Cue_Completed">
                  <conditions>
                    <check_any>
                      <event_cue_completed cue="$WithoutOfferWaitCue"/>
                      <check_all>
                        <event_cue_signalled cue="$WithoutOfferWaitCue"/>
                        <check_value value="event.param == $MissionCue"/>
                      </check_all>
                    </check_any>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="MissionAccepted" />
                  </actions>
                </cue>
              </cues>
            </cue>

            <!--These cues handle the briefing presentations e.g. Holomap or cutscene render targets (depending on the mission)
            note: play_cutscene action should not be in the actions of the cue with a event_briefing_submission_selected condition. It must be delayed-->
            <cue name="BriefingStarted">
              <conditions>
                <check_any>
                  <event_briefing_started cue="$MissionCue"/>
                  <event_briefing_submission_selected cue="$MissionCue"/>
                </check_any>
              </conditions>
              <actions>
                <set_value name="$RenderTarget" exact="event.param.{1}"/>

                <set_value name="$OpenHolomap"/>
                <set_value name="$HolomapReplay" exact="false"/>
                <do_if value="$Targets.count" min="1">
                  <set_value name="$MapTarget" exact="$Targets.{1}"/>
                </do_if>
                <do_else>
                  <set_value name="$MapTarget" exact="player.zone"/>
                </do_else>

                <debug_text text="'Briefing started'" chance="$DebugChance"/>
              </actions>
              <cues>
                <cue name="DisplayHolomap" onfail="cancel">
                  <conditions>
                    <check_value value="$OpenHolomap?"/>
                  </conditions>
                  <actions>
                    <do_if value="not $HoloMap?">
                      <add_holomap name="$HoloMap" rendertarget="$RenderTarget"/>
                    </do_if>
                    <remove_value name="$OpenHolomap" />
                  </actions>
                  <cues>
                    <cue name="HolomapRef" ref="md.LIB_HolomapTarget.Start">
                      <param name="EndSignalCue" value="HolomapEnd"/>

                      <param name="HoloMap" value="$HoloMap" />
                      <param name="Components" value="[player.entity, $MapTarget]"/>
                      <param name="ShowUnknown" value="false"/>
                      <param name="IsReplay" value="$HolomapReplay"/>

                      <param name="verbosedebugchance" value="$DebugChance"/>
                    </cue>
                    <cue name="HolomapEnd">
                      <conditions>
                        <event_cue_signalled/>
                      </conditions>
                      <actions>
                        <debug_text text="'Holomap animation end'" chance="$DebugChance"/>
                      </actions>
                      <cues>
                        <cue name="PlayBriefingCutscene" onfail="cancel">
                          <conditions>
                            <check_value value="$MapTarget.isclass.ship"/>
                          </conditions>
                          <actions>
                            <do_if value="$HoloMap?">
                              <remove_holomap />
                              <remove_value name="$HoloMap"/>
                            </do_if>

                            <!--<create_presentation_cluster name="$CutsceneCluster" background="macro.cluster_black_wlight_bg_macro"/>-->
                            <create_presentation_cluster name="$CutsceneCluster"/>
                            <find_zone name="$CutsceneZone" space="$CutsceneCluster"/>

                            <create_ship name="$CutsceneShip" macro="$MapTarget.macro" zone="$CutsceneZone">
                              <pilot actor="null"/>
                              <position x="0" y="0" z="0"/>
                            </create_ship>

                            <set_value name="$BriefingCutsceneStarted"/>

                            <set_value name="$CutsceneKey" exact="'OrbitIndefinitely'"/>
                            <play_cutscene key="$CutsceneKey" rendertarget="$RenderTarget">
                              <param name="targetobject" object="$CutsceneShip"/>
                            </play_cutscene>

                          </actions>
                          <cues>
                            <cue name="ReplayHoloMap">
                              <delay exact="10s"/>
                              <actions>
                                <!--Temp value. This is used to identify if a cutscene for this mission is still playing.-->
                                <remove_value name="$BriefingCutsceneStarted"/>

                                <stop_cutscene key="$CutsceneKey"/>

                                <do_if value="$CutsceneCluster.exists">
                                  <destroy_object object="$CutsceneCluster"/>
                                </do_if>
                                <do_if value="$CutsceneShip.exists">
                                  <destroy_object object="$CutsceneShip"/>
                                </do_if>

                                <set_value name="$HolomapReplay" exact="true"/>
                                <set_value name="$OpenHolomap"/>
                                <reset_cue cue="DisplayHolomap"/>
                              </actions>
                            </cue>
                          </cues>
                        </cue>
                      </cues>
                    </cue>
                  </cues>
                </cue>

                <cue name="BriefingStopped">
                  <conditions>
                    <check_any>
                      <event_briefing_cancelled cue="$MissionCue"/>
                      <event_briefing_submission_unselected cue="$MissionCue"/>
                    </check_any>
                  </conditions>
                  <actions>

                    <do_if value="$HoloMap?">
                      <remove_holomap />
                      <remove_value name="$HoloMap"/>
                    </do_if>

                    <do_if value="$BriefingCutsceneStarted?">
                      <!--Temp value. This is used to identify if a cutscene for this mission is still playing.-->
                      <remove_value name="$BriefingCutsceneStarted"/>

                      <stop_cutscene key="$CutsceneKey"/>

                      <do_if value="$CutsceneCluster.exists">
                        <destroy_object object="$CutsceneCluster"/>
                      </do_if>
                      <do_if value="$CutsceneShip.exists">
                        <destroy_object object="$CutsceneShip"/>
                      </do_if>
                    </do_if>

                    <debug_text text="'Briefing canceled'" chance="$DebugChance"/>
                    <reset_cue cue="BriefingStarted"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <!--TODO @Owen - parameters to allow some losses from the group instead of failing when one is lost?-->
            <cue name="TargetBecamePlayerOwned" instantiate="true">
              <conditions>
                <event_object_changed_true_owner group="$Targets" owner="faction.player"/>
              </conditions>
              <actions>
                <do_if value="not $TargetRequestCue">
                  <set_value name="$Feedback" exact="'$TARGET_PLAYER_OWNED'"/>
                  <signal_cue cue="CleanUp"/>
                </do_if>
              </actions>
            </cue>
            <cue name="TargetDestroyedPrematurely" instantiate="true">
              <conditions>
                <event_object_destroyed group="$Targets"/>
              </conditions>
              <actions>
                <do_if value="not $TargetRequestCue">
                  <do_if value="MissionAccepted.state == cuestate.complete">
                    <signal_cue_instantly cue="md.GenericMissions.GenericFailLogbookEntry" param="[$TextTable.$missionname, $Client, {30004,6027}]"/>
                  </do_if>
                  <set_value name="$Feedback" exact="'$TARGET_KILLED_EARLY'"/>
                  <signal_cue cue="CleanUp"/>
                </do_if>
              </actions>
            </cue>

            <cue name="MissionAccepted">
              <conditions>
                <event_cue_signalled />
              </conditions>
              <actions>
                <debug_text text="'Mission accepted!'" chance="$DebugChance"/>
                <set_value name="stat.missions_accepted" operation="add"/>

                <do_if value="$WithoutOffer">
                  <!--$MissionCue may already be a mission cue passed in as a parameter-->
                  <do_if value="not $MissionCue.hasmission">
                    <do_if value="$MissionThread">
                      <create_mission cue="$MissionCue" missionthread="$MissionThread" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" faction="$ClientOwner" opposingfaction="$OpposingFaction" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText" />
                    </do_if>
                    <do_else>
                      <create_mission cue="$MissionCue" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" faction="$ClientOwner" opposingfaction="$OpposingFaction" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText" />
                    </do_else>
                  </do_if>

                  <update_mission cue="$MissionCue">
                    <briefing>
                      <objective step="1" action="objective.destroy" text="$TextTable.$objective" encyclopedia="if $Targets.count then $Targets.{1} else null"/>
                    </briefing>
                  </update_mission>
                </do_if>
                <do_else>
                  <!--Copy data from the offer, then remove it-->
                  <do_if value="$MissionThread">
                    <create_mission cue="$MissionCue" offercue="$MissionCue" missionthread="$MissionThread">
                      <briefing>
                        <objective step="1" action="objective.destroy" text="$TextTable.$objective" encyclopedia="if $Targets.count then $Targets.{1} else null" comment="force-update, $Targets might have changed in case of $TargetRequestCue!"/>
                      </briefing>
                    </create_mission>
                  </do_if>
                  <do_else>
                    <create_mission cue="$MissionCue" offercue="$MissionCue"/>
                  </do_else>
                  <remove_offer cue="$MissionCue"/>
                  <cancel_cue cue="With_Offer"/>
                </do_else>

                <do_if value="$ReportSignalCue">
                  <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_ACCEPTED.clone"/>
                  <set_value name="$FeedbackData.$ID" exact="'$MISSION_ACCEPTED'"/>
                  <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="Mission accepted"/>
                  <signal_cue_instantly cue="$ReportSignalCue"/>
                </do_if>

                <signal_cue_instantly cue="md.GenericMissions.GenericAcceptLogbookEntry" param="[$TextTable.$missionname, $Client, $ClientOwner]"/>

              </actions>
              <cues>
                <cue name="ActivateImmediately" onfail="cancel">
                  <conditions>
                    <check_value value="not $MissionThread and not $Feedback"/>
                  </conditions>
                  <actions>
                    <signal_cue cue="ActivateMission"/>
                  </actions>
                </cue>

                <cue name="ActivateOnCondition" onfail="cancel">
                  <conditions>
                    <check_value value="$MissionThread and not $Feedback"/>
                  </conditions>
                  <actions>
                    <do_if value="$MissionThread.canactivatesubmission.{$MissionCue}">
                      <signal_cue cue="ActivateMission"/>
                      <cancel_cue cue="ActivateOnCondition"/>
                    </do_if>
                  </actions>
                  <cues>
                    <!--TODO @Owen add an event for when a submission has been removed from the thread-->
                    <cue name="CheckMissionThreadState" checkinterval="1s">
                      <conditions>
                        <check_value value="$MissionThread.canactivatesubmission.{$MissionCue}"/>
                      </conditions>
                      <actions>
                        <signal_cue cue="ActivateMission"/>
                        <cancel_cue cue="ActivateOnCondition"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="ActivateMission">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <set_value name="$StartStep" exact="1"/>
                    <cancel_cue cue="TargetBecamePlayerOwned"/>
                    <cancel_cue cue="TargetDestroyedPrematurely"/>
                    <do_if value="not $Targets.count">
                      <do_if value="$TargetRequestCue">
                        <signal_cue_instantly cue="$TargetRequestCue" param="this"/>
                        <add_to_group groupname="$Targets" group="this.$Targets"/>
                      </do_if>
                      <do_if value="not $Targets.count">
                        <set_value name="$Feedback" exact="'$NO_VALID_TARGETS'"/>
                        <signal_cue cue="CleanUp" />
                      </do_if>
                    </do_if>
                  </actions>
                  <cues>
                    <cue name="DestroyComponentsRef" ref="md.RML_Destroy_Components.DestroyComponents">
                      <param name="EndSignalCue" value="ObjectsDestroyed" />
                      <param name="MissionCue" value="$MissionCue" />

                      <param name="Targets_Param" value="$Targets" />
                      <param name="AllowCapture" value="true" />
                      <param name="AllowAbandoned" value="true" />
                      <param name="ObjectiveIsGroup" value="true" />

                      <param name="CustomObjective" value="'Defeat Ambush'" />

                      <param name="DebugChance" value="$DebugChance"/>
                    </cue>

                    <cue name="MissionTimeout" onfail="cancel">
                      <conditions>
                        <check_value value="typeof $MissionDuration == datatype.time"/>
                        <check_value value="$MissionDuration" min="1s"/>
                      </conditions>
                      <delay exact="$MissionDuration"/>
                      <actions>
                        <signal_cue_instantly cue="md.GenericMissions.GenericTimeoutLogbookEntry" param="[$TextTable.$missionname, $Client]"/>

                        <remove_mission cue="$MissionCue" type="failed"/>
                        <set_value name="$Feedback" exact="'$MISSION_TIMEOUT'"/>
                        <signal_cue_instantly cue="CleanUp" />
                      </actions>
                    </cue>

                    <cue name="ObjectsDestroyed">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <do_if value="ObjectsDestroyed.$EndFeedbackValue" max="-100">
                          <debug_text text="'GM_Destroy_Objects: There was a script or code error in RML - aborting mission: ' + ObjectsDestroyed.$EndFeedbackValue" chance="$DebugChance" />
                          <set_value name="$Feedback" exact="'$RML_ERROR'" />
                          <signal_cue cue="MissionAborted" />
                        </do_if>
                        <do_else>
                          <set_value name="MissionEnded.$EndFeedbackValue" exact="ObjectsDestroyed.$EndFeedbackValue" />
                          <set_value name="MissionEnded.$EndFeedbackText" exact="@ObjectsDestroyed.$EndFeedbackText" />
                          <signal_cue cue="MissionEnded" />
                        </do_else>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <cue name="MissionAborted">
              <conditions>
                <check_any>
                  <event_mission_aborted cue="$MissionCue"/>
                  <event_cue_signalled />
                </check_any>
              </conditions>
              <actions>
                <!-- Player aborted mission -->
                <do_if value="event.object" exact="$MissionCue">
                  <set_value name="$Feedback" exact="'$MISSION_ABORTED'"/>
                  <debug_text text="'GM_Destroy_Objects: Mission was aborted by the player.'" chance="$DebugChance" />
                  <signal_cue_instantly cue="md.GenericMissions.GenericAbortLogbookEntry" param="[$TextTable.$missionname, $Client]"/>
                </do_if>

                <!-- Script / code error aborted mission -->
                <do_else>
                  <!-- Leave $FeedbackValue as it is because it has already been set in the part of the script that went wrong -->
                  <debug_text text="'GM_Destroy_Objects: Mission was aborted by script or code error.'" chance="$DebugChance" />
                  <speak actor="$Client" line="$VoiceTable.$MissionAborted" chance="if $VoiceTable.$MissionAborted == 0 then 0 else 100" comment="(mission aborted by NPC / script error)" />
                </do_else>

                <remove_mission cue="$MissionCue" type="aborted"/>
                <signal_cue cue="CleanUp" />
              </actions>
            </cue>

            <cue name="MissionEnded">
              <conditions>
                <event_cue_signalled/>
              </conditions>
              <actions>
                <!-- Failure case -->
                <do_if value="MissionEnded.$EndFeedbackValue" max="0">
                  <debug_text text="'This mission has failed. RML Feedback: ' + MissionEnded.$EndFeedbackValue" chance="$DebugChance"/>
                  <set_value name="$Feedback" exact="'$RML_FAILED'"/>
                  <speak actor="$Client" line="$VoiceTable.$MissionFailed" comment="(failed mission)" chance="if $VoiceTable.$MissionFailed == 0 then 0 else 100" />
                  <signal_cue_instantly cue="md.GenericMissions.GenericFailLogbookEntry" param="[$TextTable.$missionname, $Client, @MissionEnded.$EndFeedbackText]"/>

                  <remove_mission cue="$MissionCue" type="failed" reason="@MissionEnded.$EndFeedbackText"/>
                </do_if>

                <!-- Success case -->
                <do_else>
                  <!--TODO: Partial success-->
                  <debug_text text="'This mission has ended. RML Feedback: ' + MissionEnded.$EndFeedbackValue" chance="$DebugChance"/>
                  <do_if value="$RewardNotoriety and $ClientOwner">
                    <debug_text text="'Relation was: ' + player.entity.relationto.{$ClientOwner}" chance="$DebugChance"/>
                    <add_faction_relation faction="faction.player" otherfaction="$ClientOwner" value="$RewardNotoriety" reason="relationchangereason.missioncompleted" />
                    <debug_text text="'Relation is now: ' + player.entity.relationto.{$ClientOwner}" chance="$DebugChance"/>
                  </do_if>

                  <do_if value="$RewardCr">
                    <reward_player money="$RewardCr" />
                  </do_if>
                  <do_if value="$RewardObj">
                    <do_if value="$RewardObj.isinventory">
                      <add_inventory entity="player.entity" ware="$RewardObj" />
                      <show_notification text="[{1015,100}, '', $RewardText]" sound="notification_achievement" comment="Item received" />
                    </do_if>
                  </do_if>
                  <set_value name="stat.missions_completed" operation="add"/>
                  <set_value name="$Feedback" exact="'$MISSION_SUCCEEDED'"/>
                  <speak actor="$Client" line="$VoiceTable.$MissionSuccess" comment="(successful mission)" chance="if $VoiceTable.$MissionSuccess == 0 then 0 else 100" />
                  <signal_cue_instantly cue="md.GenericMissions.GenericCompleteLogbookEntry" param="[$TextTable.$missionname, $Client, null, $RewardCr]"/>

                  <remove_mission cue="$MissionCue" type="completed" activate="next" />
                </do_else>
                <signal_cue cue="CleanUp" />
              </actions>
            </cue>
          </cues>
        </cue>

        <cue name="ForceCleanup" onfail="cancel" version="2">
          <conditions>
            <check_value value="$ForceCleanup"/>
          </conditions>
          <actions>
            <do_if value="not $ForceCleanup.exists">
              <set_value name="$Feedback" exact="'$INVALID_FORCE_CLEANUP'"/>
              <signal_cue_instantly cue="CleanUp"/>
            </do_if>
          </actions>
          <cues>
            <cue name="ForceCleanup_Wait">
              <conditions>
                <check_any>
                  <event_cue_completed cue="$ForceCleanup"/>
                  <check_all>
                    <event_cue_signalled cue="$ForceCleanup"/>
                    <check_value value="event.param == $MissionCue"/>
                  </check_all>
                </check_any>
              </conditions>
              <actions>
                <set_value name="$Feedback" exact="'$FORCED_CLEANUP'"/>
                <signal_cue_instantly cue="CleanUp"/>
              </actions>
            </cue>
          </cues>
        </cue>

        <cue name="CleanUp">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <do_if value="$HoloMap?">
              <remove_holomap />
              <remove_value name="$HoloMap"/>
            </do_if>

            <do_if value="$BriefingCutsceneStarted?">
              <!--Temp value. This is used to identify if a cutscene for this mission is still playing.-->
              <remove_value name="$BriefingCutsceneStarted"/>

              <stop_cutscene key="$CutsceneKey"/>

              <do_if value="$CutsceneCluster.exists">
                <destroy_object object="$CutsceneCluster"/>
              </do_if>
              <do_if value="$CutsceneShip.exists">
                <destroy_object object="$CutsceneShip"/>
              </do_if>
            </do_if>


            <!--***Cleanup objects***-->

            <!--No .exists check here as $Client may not be connected to gamegraph-->
            <do_if value="$Client.isclass.npc and (not $PreexistingClient?)">
              <destroy_object object="$Client"/>
            </do_if>

            <do_if value="$Target?">
              <signal_cue_instantly cue="md.GM_Destroy_Objects.RemoveTarget" param="[$Target, $ClientOwner]"/>
            </do_if>

            <!--***Evaluate result***-->

            <do_if value="$DebugChance or $ReportSignalCue">
              <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.{$Feedback}.clone"/>
              <do_if value="$FeedbackData">
                <set_value name="$FeedbackData.$ID" exact="$Feedback"/>
                <debug_text text="'Mission ended with reason: ' + $FeedbackData.$type + ' - ' + $FeedbackData.$text" chance="$DebugChance"/>
              </do_if>
              <do_else>
                <set_value name="$FeedbackData" exact="table[$ID = 'error_unknown', $type = 'error', $text = 'This is an unknown error']"/>
                <assert value="false" text="'Mission ended with unknown case: ' + $Feedback + ' [Owen]'" break="1"/>
              </do_else>

              <do_if value="$ReportSignalCue">
                <set_value name="$ReportSignalCue.$EndFeedbackValue" exact="$FeedbackData"/>
                <signal_cue cue="$ReportSignalCue"/>
              </do_if>
            </do_if>

            <cancel_cue cue="Start"/>

          </actions>
        </cue>
      </cues>
    </library>

    <!--============
        ~~ MASTER EVALUATION LIBRARY ~~
        ================-->
    <library name="Dynamic_Mission_Eval" purpose="run_actions">
      <params>
        <param name="Label" default="'$defaultnext'"/>
        <param name="ChainDefinitionTable"/>
        <param name="OutcomeTable" default="table[$success = '$defaultnext']" comment="Table of outcomes. Key: GM $FeedbackValues ID or 'type' strings ($ prepended). Value: Label string to next dynamic mission section."/>
        <param name="DebugChance" default="0"/>

        <!--Repair object and Repair Percentage parameters -->

        <param name="EnemiesKey" comment="Group containing objects or object components to repair"/>
        <param name="EnemyStrength" default="2" comment="Group containing objects or object components to repair"/>
        <param name="EnemyFactionKey" comment="Group containing objects or object components to repair"/>
        <param name="FactionKey" comment="Group containing objects or object components to repair"/>

        <!--Client NPC parameters-->
        <param name="Client" default="null" comment="Table key to client data. If the value evaluates to 'generating' then the NPC is set to be created before this mission spawns."/>
      </params>
      <actions>
        <include_actions ref="md.GMC_Dynamic.Get_Branch_Sources"/>

        <do_for_each name="$BranchSource" in="$BranchSources">
          <set_value name="$ChainDefinitionTable.$ConstructingDefinitionRef" exact="$BranchSource"/>
          <set_value name="$MissionValTable" exact="$BranchSource.$MissionValTable"/>

          <!--====================
            ~~ Check Client via $Client ~~
            ========================-->
          <set_value name="$ClientNPC" exact="@$MissionValTable.{$Client}"/>
          <do_if value="$ClientNPC">
            <do_if value="$ClientNPC == 'generating'">
              <debug_text text="'$ClientNPC is set to be generated'" chance="$DebugChance"/>
            </do_if>
            <do_elseif value="not @$ClientNPC.isclass.npc">
              <debug_text text="'$ClientNPC ' + $ClientNPC + ' is not set to be generated, nor is an existing NPC component'" filter="error"/>
              <return value="false"/>
            </do_elseif>
          </do_if>

          <!--Validate $EnemiesKey-->
          <set_value name="$EnemiesDef" exact="@$MissionValTable.{$EnemiesKey}"/>
          <do_if value="$EnemiesDef">
            <do_if value="$EnemiesDef == 'generating'">
              <debug_text text="'$EnemiesDef is set to be generated'" chance="$DebugChance"/>
            </do_if>
            <do_elseif value="$EnemiesDef == 'spawning'">
              <debug_text text="'$EnemiesDef is set to be spawned'" chance="$DebugChance"/>
            </do_elseif>
            <do_elseif value="$EnemiesDef == 'commandeering'">
              <debug_text text="'$EnemiesDef is set to be commandeered'" chance="$DebugChance"/>
            </do_elseif>
            <do_elseif value="(typeof $EnemiesDef != datatype.group) and $EnemiesDef.count lt 1">
              <debug_text text="'$EnemiesDef ' + $EnemiesDef + ' is not a valid target group definition'" filter="error"/>
              <return value="false"/>
            </do_elseif>
          </do_if>

          <!--Validate $FactionKey-->
          <set_value name="$FactionDef" exact="@$MissionValTable.{$FactionKey}"/>
          <do_if value="$FactionDef">
            <do_if value="$FactionDef == 'generating'">
              <debug_text text="'$FactionDef is set to be generated'" chance="$DebugChance"/>
            </do_if>
            <do_elseif value="(typeof $FactionDef != datatype.faction)">
              <debug_text text="'$FactionDef ' + $FactionDef + ' is not a valid faction definition'" filter="error"/>
              <return value="false"/>
            </do_elseif>
          </do_if>

          <!--Finalisation. Construct the mission instance param table.-->

          <!--Build the $Params table which will be passed to the instance so it can lookup the data from from $MissionValTable on spawning-->
          <set_value name="$ChainDefinitionTable.$ConstructingDefinitionRef.$StaticMissionCue"     exact="Ambush_Start"/>
          <set_value name="$ChainDefinitionTable.$ConstructingDefinitionRef.$Params"               exact="table[
                         $Client = $Client,
                         $EnemiesKey = $EnemiesKey,
                         $EnemyFactionKey = $EnemyFactionKey,
                         $EnemyStrength = $EnemyStrength,
                         $FactionKey = $FactionKey]"/>

          <include_actions ref="md.GMC_Dynamic.Set_Up_Outcome_Branches"/>
        </do_for_each>

        <return value="true"/>

      </actions>
    </library>

    <cue name="Ambush_Start" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$Parameters" exact="event.param.$instanceparams"/>
        <set_value name="$MissionValTable" exact="event.param.$missionvaltable"/>
        <debug_text text="'$Parameters ' + $Parameters"/>
        <debug_text text="'$MissionValTable ' + $MissionValTable"/>

        <set_value name="$Client" exact="$MissionValTable.{$Parameters.$Client}"/>
        <set_value name="$OpposingFaction" exact="$MissionValTable.{$Parameters.$EnemyFactionKey}"/>
        <set_value name="$EnemyStrength" exact="$Parameters.$EnemyStrength"/>
        <set_value name="$FactionKey" exact="$MissionValTable.{$Parameters.$FactionKey}"/>

        <create_group groupname="$EnemyGroup"/>

        <!-- Set up enemy group -->
        <do_if value="typeof $MissionValTable.{$Parameters.$EnemiesKey} != datatype.group ">
          <!-- Determine the player's strength to factor that into enemy ambush strength -->
          <do_if value="player.ship.isclass.[class.ship_l, class.ship_xl]">
            <!-- is the player in an L ship or larger? -->
            <do_if value="player.ship.primarypurpose == purpose.fight">
              <set_value name="$DestroyerCombat"/>
            </do_if>
          </do_if>
          <do_if value="player.ship.subordinates.count">
            <!-- Does the player have subordinates with them? -->
            <set_value name="$EnemyStrength" operation="add" exact="player.ship.subordinates.count"/>
            <do_for_each name="$ship" in="player.ship.subordinates">
              <do_if value="$ship.isclass.[class.ship_l, class.ship_xl] and ($ship.primarypurpose == purpose.fight)">
                <set_value name="$DestroyerCombat"/>
                <break/>
              </do_if>
            </do_for_each>
          </do_if>

          <!-- Either have the ships spawn at a point of entry to the system if one is close enough, or have them appear somewhere just outside of radar range -->
          <find_object name="$gate" class="[class.gate, class.highwayexitgate]" space="player.sector" sortbydistanceto="player.ship">
            <match_distance object="player.entity" max="50km"/>
          </find_object>

          <do_if value="$gate">
            <get_safe_pos result="$StagingPos" sector="player.sector" object="$gate" z="8.5km"/>
          </do_if>
          <do_else>
            <get_safe_pos result="$StagingPos" sector="player.sector" object="player.ship" radius="30km" min="player.ship.maxradarrange*1.05" max="player.ship.maxradarrange*1.15" allowyaxis="false"/>
          </do_else>

          <!-- if the group of enemies is not supplied, we either commandeer or spawn ships -->
          <do_if value="$MissionValTable.{$Parameters.$EnemiesKey} == 'commandeering'">

            <do_if value="$DestroyerCombat?">
              <remove_value name="$DestroyerCombat"/>
              <find_ship_by_true_owner name="$commander" groupname="$EnemyGroup" space="player.galaxy" class="class.ship_l" primarypurpose="purpose.fight" commandeerable="true" faction="$OpposingFaction" sortbygatedistanceto="player.ship"/>
            </do_if>

            <find_ship_by_true_owner groupname="$EnemyGroup" space="player.galaxy" class="[class.ship_s, class.ship_m]" primarypurpose="purpose.fight" commandeerable="true" faction="$OpposingFaction" sortbygatedistanceto="player.ship" sortlimit="$EnemyStrength - $EnemyGroup.count" multiple="true"/>

            <do_for_each name="$ship" in="$EnemyGroup" counter="$i">
              <commandeer_object object="$ship"/>
              <do_if value="$i and not $commander?">
                <set_value name="$commander" exact="$ship"/>
              </do_if>
              <do_if value="($ship.sector != player.ship.sector) or ($ship.distanceto.{player.ship} gt 45km)">
                <warp object="$ship" sector="player.sector">
                  <orientation refobject="player.ship" orientation="look_at"/>
                  <safepos value="$StagingPos" radius="0.5km" />
                </warp>
              </do_if>
            </do_for_each>
          </do_if>
          <do_if value="$MissionValTable.{$Parameters.$EnemiesKey} == 'spawning'
                        or $EnemyGroup.count lt $EnemyStrength">
            <!-- if the commandeering could not fulfill the -->
            <do_all exact="$EnemyStrength - $EnemyGroup.count">
              <do_if value="$DestroyerCombat?">
                <remove_value name="$DestroyerCombat"/>
                <get_ship_definition reference="$ship_def" faction="$OpposingFaction" size="class.ship_l" tags="tag.military"/>
                <do_if value="not $ship_def">
                  <get_ship_definition reference="$ship_def" faction="$OpposingFaction" size="[class.ship_s, class.ship_m]" tags="tag.military"/>
                </do_if>
              </do_if>
              <do_else>
                <get_ship_definition reference="$ship_def" faction="$OpposingFaction" size="[class.ship_s, class.ship_m]" tags="tag.military"/>
              </do_else>

              <create_ship name="$ship" ref="$ship_def" sector="player.sector" groupname="$EnemyGroup">
                <owner exact="$OpposingFaction" overridenpc="true"/>
                <pilot>
                  <select race="$OpposingFaction.primaryrace" tags="tag.aipilot"/>
                </pilot>
                <loadout>
                  <level exact="0.4"/>
                </loadout>
                <orientation refobject="player.ship" orientation="look_at"/>
                <safepos value="$StagingPos" radius="0.5km" />
              </create_ship>
              <do_if value="not $commander?">
                <set_value name="$commander" exact="$ship"/>
              </do_if>
            </do_all>
          </do_if>
        </do_if>
        <do_else>
          <set_value name="$EnemyGroup" exact="$MissionValTable.{$Parameters.$EnemiesKey}"/>
        </do_else>

        <do_for_each name="$ship" in="$EnemyGroup">
          <set_relation_boost object="$ship" silent="true" otherobject="player.entity" value="-1.0" decay="0.02" delay="540s"/>

          <do_if value="$ship == $commander">
            <cancel_all_orders object="$ship"/>
            <create_order object="$ship" id="'Patrol'" default="true"/>
            <create_order object="$commander" id="'Attack'" immediate="true">
              <param name="primarytarget" value="player.ship"/>
              <param name="secondarytargets" value="player.ship.subordinates"/>
              <param name="pursuetargets" value="true"/>
              <param name="allowothertargets" value="false"/>
              <param name="checkrelation" value="true"/>
            </create_order>
          </do_if>
          <do_else>
            <cancel_all_orders object="$ship"/>
            <create_order id="'AssignCommander'" object="$ship">
              <param name="commander" value="$commander"/>
              <param name="assignment" value="assignment.attack"/>
              <param name="cancelorders" value="true"/>
            </create_order>
          </do_else>
        </do_for_each>
      </actions>
      <cues>

        <cue name="Ambush_GM_Ref" ref="md.GM_Ambush.Start">
          <param name="Client"            value="$Client"/>
          <param name="MissionCue"        value="$MissionValTable.$ChainInstance"/>

          <!--TODO @Owen-->
          <param name="MissionLevel"      value="1"/>
          <param name="Difficulty"        value="level.medium"/>

          <!--Offer location and conversation-->
          <param name="WithoutOffer"      value="true"/>

          <!--Mission text TODO @Owen-->
          <param name="Page"              value="30159"/>
          <param name="TextOffset"        value="1000"/>

          <!--see GenerateGenericMission_Variant_1_PostInit-->
          <param name="Targets"           value="$EnemyGroup" />
          <param name="OpposingFaction"   value="$OpposingFaction" />

          <param name="ReportSignalCue"   value="$MissionValTable.$ChainMissionReportCue"/>
          <param name="CancelOfferCue"    value="null"/>
          <param name="ForceCleanup"      value="null"/>
          <param name="DebugChance"       value="@GenerateGenericMission.$DebugChance"/>
        </cue>

      </cues>
    </cue>

  </cues>
</mdscript>
