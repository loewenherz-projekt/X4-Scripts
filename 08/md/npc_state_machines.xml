<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="NPC_State_Machines.xsl" type="text/xsl" ?>
<mdscript name="NPC_State_Machines" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">
  <cues>
    <!--TODO @Owen DockArea > WalkableModule/Module-->

    <!--DEBUG-->
    <cue name="NPCWalkTest" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled/>
        <check_value value="player.room.parent.isclass.walkablemodule"/>
      </conditions>
      <actions>
        <set_value name="$DockArea" exact="player.room.parent"/>
        <find_station name="$Stations" space="player.sector" multiple="true"/>
        <do_all exact="$Stations.count" counter="$i">
          <find_object_component groupname="$NPCs" class="class.npc" entitytype="entitytype.crowd" object="$Stations.{$i}" multiple="true"/>
          <destroy_group group="$NPCs"/>
        </do_all>

      </actions>
      <cues>
        <cue name="NPCWalkTest_Delay">
          <delay exact="2s"/>
          <actions>
            <find_npc_slot name="$DockAreaSlots" object="$DockArea" multiple="true"/>
            <create_cue_actor cue="this" name="$NPC">
              <select race="race.argon"/>
            </create_cue_actor>
            <set_value name="$NPC.$DebugDockAreaMovement" exact="true"/>
            <set_entity_traits entity="$NPC" missionactor="true"/>
            <set_entity_type entity="$NPC" type="entitytype.crowd"/>
            <add_actor_to_room actor="$NPC" slot="$DockAreaSlots.random" />
          </actions>
        </cue>
      </cues>
    </cue>

    <cue name="TerminalFlagHelper">
      <actions>
        <set_value name="this.$Table" exact="table[
                    {1} = 'sit_terminal_forward',
                    {2} = 'sit_terminal_left',
                    {3} = 'sit_terminal_leftfore',
                    {4} = 'sit_terminal_right',
                    {5} = 'sit_terminal_rightfore',
                    {6} = 'sit_terminal_side',
                    {7} = 'sit_terminal_all',]"/>
      </actions>
    </cue>

    <cue name="Base" namespace="this" instantiate="true" version="9">
      <conditions>
        <event_npc_created/>
        <check_value value="event.param.exists and not event.param.cluster.ispresentation"/>
        <!--HACK @Owen event_npc_created should not fire for NPCs created as a result of loading a savegame-->
        <check_value value="not event.param.$StateMachine?"/>
      </conditions>
      <actions>
        <set_value name="$NPC" exact="event.param"/>
        <!--<assert value="not $NPC.$StateMachine?" text="'NPC already has a state machine [Owen]'" break="always"/>-->
        <set_value name="$NPC.$StateMachine" exact="this"/>
        <set_value name="$ActiveStates" exact="[]"/>
        <!--<set_value name="$DebugChance" exact="100"/>-->
        <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' created with INIT state'" chance="@$DebugChance" />
      </actions>
      <patch sinceversion="2" state="complete">
        <!--This is a convenient cue to patch NPC with incorrect conversation handlers without having to find them in the galaxy-->
        <do_if value="$NPC.controlpost == controlpost.shiptrader and not $NPC.customhandler">
          <debug_text text="'Ship trader ' + $NPC + ' ' + $NPC.knownname + 'of faction ' + $NPC.owner.id + ' had no custom handler. Restarting shiptrader conversation handler'" filter="savegame"/>
          <signal_cue_instantly cue="md.NPC_Shiptrader.Base" param="$NPC"/>
        </do_if>
      </patch>
      <patch sinceversion="3" state="complete">
        <remove_value name="$AncestorCues"/>
      </patch>
      <patch sinceversion="4">
        <remove_value name="$CurrentSlotTags"/>
      </patch>
      <patch sinceversion="5" state="complete">
        <do_if value="$NPC.exists and $NPC.controlpost == controlpost.trainee_individual">
          <signal_objects object="$NPC" param="'npc_state_reinit'" delay="1ms"/>
        </do_if>
      </patch>
      <patch sinceversion="6" state="complete">
        <do_if value="$NPC.isplayerowned and @$NPC.$StateMachine.$ActiveStates.{1}.staticbase == md.NPC_State_Machines.STATE_init and $NPC.role == entityrole.trainee_group">
          <do_if value="$NPC.roleobject">
            <set_npc_template_traits object="$NPC.roleobject" template="$NPC.npctemplate" intransit="false"/>
          </do_if>
          <debug_text text="'Killing left over trainee NPC ' + $NPC + ' ' + $NPC.knownname" filter="savegame"/>
          <destroy_object object="$NPC"/>
        </do_if>
      </patch>
      <patch sinceversion="7" state="complete">
        <do_if value="not $DebugChance">
          <remove_value name="$DebugChance"/>
        </do_if>
        <do_if value="$QueuedTransitionRequests.count == 0">
          <remove_value name="$QueuedTransitionRequests"/>
        </do_if>
      </patch>
      <patch sinceversion="8" state="complete">
        <do_if value="@$NPC.$StateMachine.$QueuedTransitionRequests.{1}.{1}.staticbase == md.NPC_State_Machines.TRANSITION_despawn and $NPC.$StateMachine.$QueuedTransitionRequests.count gt 1">
          <set_value name="$Patch_ParamTable" exact="$NPC.$StateMachine.$QueuedTransitionRequests.{1}.{2}.{2}"/>
          <do_if value="not @$Patch_ParamTable.$despawn and not @$Patch_ParamTable.$reinit">
            <set_entity_traits entity="$NPC" temporary="true"/>
            <debug_text text="$NPC + ' ' + $NPC.knownname + ' has a queued despawn event but also other queued transitions due to incorrect handling. Setting to temporary so they may be cleaned up once the transitions are done'" filter="savegame"/>
          </do_if>
          <remove_value name="$Patch_ParamTable"/>
        </do_if>
      </patch>
      <patch sinceversion="9" state="complete">
        <do_if value="$NPC.exists and $NPC.$roulette_dealer_slot? and $NPC.isplayerowned and $NPC.roomslot != $NPC.$roulette_dealer_slot">
          <debug_text text="'Setting player owned croupier NPC ' + $NPC + ' ' + $NPC.knownname + ' on ' + @$NPC.object.knownname + ' to be an ordinary NPC'" filter="savegame"/>
          <remove_value name="$NPC.$roulette_dealer_slot"/>
          <set_entity_traits entity="$NPC" customhandler="false"/>
          <set_entity_overrides entity="$NPC" icon="''" title="''"/>
        </do_if>
      </patch>
      <cues>
        <cue name="NPC_Killed">
          <conditions>
            <check_any>
              <event_object_destroyed object="$NPC"/>
              <event_object_changed_attention object="$NPC" attention="attention.unknown" comment="Disconnected. New state machine will be started if re-connected."/>
              <check_all>
                <!--Some entities are disconnected before the kill event is dispatched e.g. mass traffic pilots. Checking if they were removed with a kill method catches this case.-->
                <event_control_entity_removed object="$NPC"/>
                <check_value value="event.param2"/>
              </check_all>
              <!--Disabled due to exceeding the max number of listeners. Replaced with hack below-->
              <!--<check_all>
                <event_game_loaded/>
                <check_value value="not $NPC.exists"/>
              </check_all>-->
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' - Stopping state machine due to ' + event.name" chance="@$DebugChance"/>
            <remove_value name="$NPC.$StateMachine"/>
            <remove_value name="$NPC.$state_machine_critical"/>
            <cancel_cue cue="Base"/>
          </actions>
        </cue>

        <!--HACK-->
        <cue name="NPC_Check_Lost" checkinterval="5s">
          <conditions>
            <check_value value="not $NPC.exists"/>
          </conditions>
          <actions>
            <do_if value="$NPC.isclass.npc">
              <debug_text text="'NPC no longer exists but case was not caught by NPC_Killed: ' + $NPC + ' type: ' + $NPC.type + ' role: ' + $NPC.role + ' post ' + $NPC.controlpost + ' - Aborting state machine. [Owen]'"/>
            </do_if>
            <do_else>
              <debug_text text="'NPC no longer exists but case was not caught by NPC_Killed - Aborting state machine. [Owen]'"/>
            </do_else>
            <cancel_cue cue="Base"/>
          </actions>
        </cue>

        <!--
        ########################
        USECASE RESERVATIONS
        ########################-->

        <library name="Validate_Usecase_Reservation">
          <actions>
            <do_if value="$UsecaseCue? and not $UsecaseCue.exists">
              <assert value="$UsecaseCue.exists" text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' referenced a usecase which no longer exists. Should have been cleaned up earlier. [Owen]'"/>
              <remove_value name="$UsecaseCue"/>
            </do_if>
          </actions>
        </library>

        <!--
        NPC signalled to check if this NPC can be requested by a usecase.
        
        event.param = 'can_be_reserved_by_usecase'
        event.param2 = $ResultCue (result saved to $CanReserve)
        -->
        <cue name="Can_Be_Requested_By_Usecase" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_value value="event.param == 'can_be_reserved_by_usecase'"/>
          </conditions>
          <actions>
            <debug_text text="'Checking if ' + $NPC + ' ' + $NPC.knownname + ' can be requsted for a usecase'" chance="@$DebugChance"/>

            <set_value name="event.param2.$CanRequest" exact="false"/>

            <include_actions ref="Validate_Usecase_Reservation"/>

            <do_if value="$ActiveStates.count and 
                   not @$NPC.$state_machine_critical and
                   (not $QueuedTransitionRequests? or $QueuedTransitionRequests.count == 0) and 
                   not @Handle_ChangeState.$QueuedTransition and 
                   not $UsecaseCue? and
                   $NPC != player.conversationactor and
                   (not $NPC.controlled or not $NPC.controlled.order or $NPC.controlled.order.canplayercancel)">

              <signal_cue_instantly cue="$ActiveStates.{$ActiveStates.count}" param="'check_can_allow_npc_usecase_reservation'" check="false"/>

              <set_value name="event.param2.$CanRequest" exact="@$ActiveStates.{$ActiveStates.count}.$AllowUsecaseReservation == true" comment="== true just so we don't set the result to 'null' in some cases"/>
            </do_if>
          </actions>
        </cue>

        <!--
        Check if the NPC's current state is listening for a transition request of a certain ID
        
        event.param = 'can_have_transition'
        event.param2 = $ResultCue (result saved to $CanTransition)
        event.param3 = list to define a transition to request and its parameters:
          e.g. ['npc_move_to', $paramtable]
        -->
        <cue name="Can_Have_Transition" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_value value="event.param == 'can_have_transition'"/>
          </conditions>
          <actions>
            <debug_text text="'Checking if ' + $NPC + ' ' + $NPC.knownname + ' can be signalled to transition to ' + event.param3.{1} + ' with params: ' + @event.param3.{2} + ' and ' + @event.param3.{3}" chance="@$DebugChance"/>

            <set_value name="$CanHaveTransition_Result" exact="null"/>
            <signal_objects object="$NPC" param="event.param3.{1}" param2="@event.param3.{2}" param3="@event.param3.{3}"/>
            <set_value name="event.param2.$CanTransition" exact="$CanHaveTransition_Result == true" comment="== true just so we don't set the result to 'null' in some cases"/>

            <debug_text text="if $CanHaveTransition_Result then (event.param3.{1} + ' can be signalled') else (event.param3.{1} + ' can not be signalled')" chance="@$DebugChance"/>
            <remove_value name="$CanHaveTransition_Result"/>
          </actions>
        </cue>

        <!--
        Reserve a NPC for a usecase
        
        event.param = 'reserve_for_usecase'
        event.param2 = Usecase related cue, to be stored for reference (potentially could also be signalled by the NPC if needed)
        -->
        <cue name="Reserve_For_Usecase" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_value value="event.param == 'reserve_for_usecase'"/>
          </conditions>
          <actions>
            <debug_text text="'Attempting to reserve NPC ' + $NPC + ' ' + $NPC.knownname + ' for usecase of cue ' + event.param2" chance="@$DebugChance"/>

            <include_actions ref="Validate_Usecase_Reservation"/>

            <do_if value="event.param2.exists and not @$UsecaseCue">
              <assert value="$ActiveStates.count and 
                   not @$NPC.$state_machine_critical and
                   (not $QueuedTransitionRequests? or $QueuedTransitionRequests.count == 0) and 
                   not @Handle_ChangeState.$QueuedTransition and 
                   $NPC != player.conversationactor and
                   (not $NPC.controlled or not $NPC.controlled.order or $NPC.controlled.order.canplayercancel)" text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' has been reserved for usecase ' + event.param2 + ' while being in a potentially busy state [Owen]'"/>

              <set_value name="$UsecaseCue" exact="event.param2"/>
            </do_if>
          </actions>
        </cue>

        <!--
        Release a usecase reservation of a NPC
        
        event.param = 'release_usecase_reservation'
        -->
        <cue name="Release_Usecase_Reservation" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_value value="event.param == 'release_usecase_reservation'"/>
          </conditions>
          <actions>
            <do_if value="$UseCase?">
              <debug_text text="'Releasing usecase reservation for NPC: ' + $NPC + ' ' + $NPC.knownname + ' of usecase ' + $UsecaseCue" chance="@$DebugChance"/>
              <remove_value name="$UsecaseCue"/>
            </do_if>
            <do_else>
              <debug_text text="'Attempting to release usecase reservation for NPC: ' + $NPC + ' ' + $NPC.knownname + ' but they were not reserved.'" filter="error"/>
            </do_else>
          </actions>
        </cue>

        <cue name="Meet_Greet_Request" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_value value="event.param == 'meetandgreet'"/>
            <check_value value="not @md.$MissionDND.count" comment="chatter not suppressed by a mission" />
          </conditions>
          <actions>
            <set_value name="$MetNPC" exact="event.param2"/>
            <!--<debug_text text="'MeetandGreet Request: ' + $NPC.knownname + ' and ' + $MetNPC.knownname" chance="@$DebugChance"/>-->
            <do_if value="($NPC.isplayerowned and $MetNPC == player.entity) or ($NPC.role and $NPC.roleobject == $MetNPC.assignedcontrolled)">
              <signal_cue_instantly cue="md.NPC_UseCases.UseCase" param="table[ $name = '$MeetAndGreetCommander', $actors = table[ $Actor1 = $NPC, $Actor2 = $MetNPC ] ]" />
            </do_if>
            <do_elseif value="not $NPC.hasrelation.enemy.{$MetNPC}">
              <signal_cue_instantly cue="md.NPC_UseCases.UseCase" param="table[ $name = '$MeetAndGreet', $actors = table[ $Actor1 = $NPC, $Actor2 = $MetNPC ] ]" />
            </do_elseif>
            <remove_value name="$MetNPC"/>
          </actions>
        </cue>

        <!--cue name="DebugConv">
          <conditions>
            <event_conversation_started actor="$NPC"/>
          </conditions>
          <actions>
            <set_value name="$DebugChance" exact="100"/>
          </actions>
        </cue-->

        <!--State Management-->

        <!--The requested state changes or queued transitions are processed as soon as the NPC is not in a critical movement state e.g. halfway climbing a ladder-->

        <!--event.param = 
            - (On state request) State cue to request a state change to
            - (On signal from ChangeState_Dispatch) Nothing, as $RequestedCue should already be set
        This cue is instantiated so that the state machine is always listening for signals.
        When a signal comes, it will prepare the variables used by Handle_ChangeState to actually change the state-->
        <cue name="ChangeState" instantiate="true">
          <conditions>
            <event_cue_signalled/>
            <remove_value name="$QueuedTransition"/>
            <!--Only process request if it is a different state the the one currently being processed and that it is not a regular request from a critical state while another request is still waiting-->
            <check_value value="event.param and (not @Handle_ChangeState.$Cue or event.param != @Handle_ChangeState.$Cue)"/>
            <set_value name="$RequestedCue" exact="event.param"/>
            <remove_value name="this.$ParamTable"/>
            <set_value name="$IsTransitionRelatedStateChange" exact="@$DispatchTransitionStateChange"/>
            <debug_text text="$RequestedCue + ' state requested for NPC ' + $NPC" debugchance="@$DebugChance"/>
            <check_value value="false" comment="Optimisation. We don't actually need the cue to instantiate."/>
          </conditions>
        </cue>

        <!--
        Internal use. Do not signal from states directly. Use QueueTransitionRequest library to add a new transition request.
        event.param = transition id string
        This cue is instantiated so that the state machine is always listening for signals.-->
        <cue name="RequestQueuedTransition" instantiate="true">
          <conditions>
            <event_cue_signalled/>
            <!--Only process request if there is no $RequestedCue already set-->
            <check_value value="not @$RequestedCue and event.param"/>
            <set_value name="$QueuedTransition" exact="event.param"/>
            <debug_text text="'queued state change to ' + $QueuedTransition + ' requested for NPC ' + $NPC" debugchance="@$DebugChance"/>
            <check_value value="false" comment="Optimisation. We don't actually need the cue to instantiate."/>
          </conditions>
        </cue>

        <cue name="Handle_ChangeState">
          <conditions>
            <check_any>
              <check_all>
                <event_cue_signalled cue="ChangeState"/>
                <check_value value="$RequestedCue.exists"/>
              </check_all>
              <check_all>
                <event_cue_signalled cue="RequestQueuedTransition"/>
                <check_value value="$QueuedTransition"/>
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <!--This cue deals with both state changes and queued transitions.
            While this cue is running, any new state request will have it abandon the processing of the state change or transition it was going to process.
            If a state change was going to happen, any requested transition is ignored. The transitions only get processed if the state machine is in a lull.-->

            <do_if value="@$RequestedCue">
              <assert value="typeof $RequestedCue == datatype.cue" text="'Requested state change cue was not of type cue: ' + $RequestedCue + ' [Owen]'"/>
              <do_if value="typeof $RequestedCue == datatype.cue">
                <set_value name="this.$Cue" exact="$RequestedCue"/>
                <debug_text text="'Regular state change is set to be processed for ' + $RequestedCue" chance="@$DebugChance"/>
                <assert value="not @$QueuedTransition" text="'There was a transition request ' + $QueuedTransition + ' alongside a state change request to ' + $RequestedCue + ' which should not happen. [Owen]'"/>
              </do_if>
              <do_else>
                <remove_value name="$RequestedCue"/>
                <reset_cue cue="Handle_ChangeState"/>
              </do_else>
            </do_if>
            <do_elseif value="@$QueuedTransition">
              <debug_text text="'Queued transition is set to be processed for ' + $QueuedTransition" chance="@$DebugChance"/>
              <set_value name="this.$QueuedTransition" exact="$QueuedTransition"/>
            </do_elseif>
            <do_else>
              <reset_cue cue="Handle_ChangeState"/>
            </do_else>

            <do_if value="not $NPC.isclass.npc">
              <assert value="$NPC.isclass.npc" text="'NPC is no longer valid. This should have been caught by NPC_Killed. Destructing state machine. [Owen]'"/>
              <cancel_cue cue="Base"/>
            </do_if>
            <do_elseif value="not $NPC.exists">
              <assert value="$NPC.exists" text="'NPC no longer exists but case was not caught by NPC_Killed: ' + $NPC + ' type: ' + $NPC.type + ' role: ' + $NPC.role + ' post ' + $NPC.controlpost + ' - Destructing state machine. [Owen]'"/>
              <cancel_cue cue="Base"/>
            </do_elseif>
          </actions>
          <cues>
            <!--Wait until the NPC is ready for a state change e.g. not in the middle of a critical animation such as climbing a ladder
            Also, if a queued transition, do not perform if $NPC.controlled has an order in a critical section-->
            <cue name="ChangeState_NPC_Ready" checkinterval="1ms">
              <conditions>
                <check_value value="not @$NPC.$state_machine_critical and $NPC != player.conversationactor and (not @parent.$QueuedTransition or not $NPC.controlled or not $NPC.controlled.order or $NPC.controlled.order.canplayercancel)"/>
              </conditions>
            </cue>

            <cue name="ChangeState_Shutdown">
              <conditions>
                <event_cue_completed cue="ChangeState_NPC_Ready"/>
                <check_value value="@parent.$Cue"/>
              </conditions>
              <actions>
                <debug_text text="player.age + ' Can attempt to shutdown states as NPC is not in a critical movement. Condition trigger was: ' + event.object" chance="@$DebugChance"/>
                <!--Check that the RequestedCue is still the one set to be processed by this cue-->
                <set_value name="this.$Cue" exact="null"/>
                <do_if value="@$RequestedCue.exists and parent.$Cue.exists and $RequestedCue == parent.$Cue">
                  <set_value name="this.$Cue" exact="parent.$Cue"/>

                  <!--Shut down current states to prepare for state change-->
                  <set_value name="$Parent" exact="this.$Cue.parent"/>

                  <do_all chance="@$DebugChance">
                    <debug_text text="player.age + ' Shutting down active cues in preparation for activating activating state cue ' + this.$Cue + ' for ' + $NPC + ' ' + $NPC.knownname"/>
                    <debug_text text="'Has ' + $ActiveStates.count + ' Previously active states:'"/>
                    <do_all exact="$ActiveStates.count" counter="$i">
                      <debug_text text="$ActiveStates.{$i}"/>
                    </do_all>
                  </do_all>

                  <set_value name="$AncestorCues" exact="[]"/>
                  <do_while value="$Parent and $Parent.staticbase != Base.staticbase">
                    <append_to_list name="$AncestorCues" exact="$Parent"/>
                    <set_value name="$Parent" exact="$Parent.parent"/>
                  </do_while>
                  <remove_value name="$Parent"/>

                  <do_all chance="@$DebugChance">
                    <debug_text text="'Has ' + $AncestorCues.count + ' Ancestor states:'"/>
                    <do_all exact="$AncestorCues.count" counter="$i" reverse="true">
                      <debug_text text="$AncestorCues.{$i}"/>
                    </do_all>
                  </do_all>

                  <do_all exact="$ActiveStates.count" counter="$i" reverse="true">
                    <do_if value="$ActiveStates.{$i} == this.$Cue">
                      <debug_text text="'Reset state ' + this.$Cue" chance="@$DebugChance"/>
                      <signal_cue_instantly cue="this.$Cue" param="'exit'"/>
                      <reset_cue cue="this.$Cue"/>
                    </do_if>
                    <do_elseif value="not $AncestorCues.indexof.{$ActiveStates.{$i}}">
                      <debug_text text="'Exiting state ' + $ActiveStates.{$i}" chance="@$DebugChance"/>
                      <signal_cue_instantly cue="$ActiveStates.{$i}" param="'exit'"/>
                      <reset_cue cue="$ActiveStates.{$i}"/>
                    </do_elseif>
                  </do_all>

                  <clear_list list="$ActiveStates"/>
                  <do_all exact="$AncestorCues.count" counter="$i" reverse="true">
                    <append_to_list name="$ActiveStates" exact="$AncestorCues.{$i}"/>
                  </do_all>
                  <remove_value name="$AncestorCues"/>

                  <do_all chance="@$DebugChance">
                    <debug_text text="'Has ' + $ActiveStates.count + ' Active states:'"/>
                    <do_all exact="$ActiveStates.count" counter="$i">
                      <debug_text text="$ActiveStates.{$i}"/>
                    </do_all>
                  </do_all>
                </do_if>
                <do_else>
                  <debug_text text="player.age + ' Aborting shutdown of active cues for state cue ' + parent.$Cue + ' for ' + $NPC + ' ' + $NPC.knownname + ' - a different state (' + $RequestedCue + ') was requested before the shutdown happened.'" chance="@$DebugChance"/>

                  <reset_cue cue="Handle_ChangeState"/>
                  <!--This is simply to trigger Handle_ChangeState again-->
                  <signal_cue cue="ChangeState"/>
                </do_else>
              </actions>
              <cues>
                <cue name="ChangeState_Dispatch">
                  <delay exact="1ms"/>
                  <actions>
                    <!--Check that the RequestedCue is still the one set to be processed by this cue-->
                    <set_value name="this.$Cue" exact="null"/>
                    <do_if value="@$RequestedCue.exists and parent.$Cue.exists and $RequestedCue == parent.$Cue">
                      <debug_text text="player.age + ' Dispatched trigger for activating state cue ' + $RequestedCue + ' for ' + $NPC + ' ' + $NPC.knownname + ' - Is transition request: ' + if @$IsTransitionRelatedStateChange then true else false" chance="@$DebugChance"/>
                      <assert value="$RequestedCue.state == cuestate.waiting" text="'NPC state cue ' + $RequestedCue + ' is not waiting to be signalled. State machine may stall. [Owen]'" break="1"/>
                      <do_if value="@$IsTransitionRelatedStateChange">
                        <assert value="@$QueuedTransitionRequests.count" text="'Processing a transition related state change to ' + $RequestedCue + ', although the request list is empty. [Owen]'"/>
                        <do_if value="@$QueuedTransitionRequests.count">
                          <!--ASSUMPTION CITY!
                          We are assuming that the the state we are changing to is related to the first entry in the queued transition list. It always should be, but pretty much impossible to verify.
                          Remove the first entry as it is now processed (we hope)-->
                          <remove_value name="$QueuedTransitionRequests.{1}"/>
                          <do_if value="$QueuedTransitionRequests.count == 0">
                            <remove_value name="$QueuedTransitionRequests"/>
                          </do_if>
                        </do_if>
                      </do_if>
                      <signal_cue cue="$RequestedCue"/>
                      <do_if value="ChangeState.$ParamTable?">
                        <set_value name="$RequestedCue.$ParamTable" exact="ChangeState.$ParamTable"/>
                      </do_if>
                      <remove_value name="$RequestedCue"/>
                    </do_if>
                    <do_else>
                      <debug_text text="player.age + ' Aborting dispatch trigger for activating state cue ' + parent.$Cue + ' for ' + $NPC + ' ' + $NPC.knownname + ' - another state (' + @$RequestedCue + ') was requested before the dispatch happened.'" chance="@$DebugChance"/>
                    </do_else>

                    <reset_cue cue="Handle_ChangeState"/>
                    <remove_value name="$IsTransitionRelatedStateChange"/>
                    <!--This is to trigger Handle_ChangeState again-->
                    <do_if value="@$RequestedCue.exists">
                      <signal_cue cue="ChangeState"/>
                    </do_if>
                    <do_elseif value="@$QueuedTransition">
                      <signal_cue cue="RequestQueuedTransition"/>
                    </do_elseif>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="ChangeState_Dispatch_Transition">
              <conditions>
                <event_cue_completed cue="ChangeState_NPC_Ready"/>
                <check_value value="@parent.$QueuedTransition"/>
              </conditions>
              <actions>
                <do_if value="not @$RequestedCue and parent.$QueuedTransition == $QueuedTransition">
                  <debug_text text="'Queued transition request for ' + $QueuedTransition + '. NPC : ' + $NPC + ' ' + $NPC.knownname" chance="@$DebugChance"/>

                  <do_if value="@$QueuedTransitionRequests.count">
                    <do_if value="$QueuedTransitionRequests.{1} == $QueuedTransition">
                      <remove_value name="$QueuedTransition"/>

                      <set_value name="$DispatchTransitionStateChange" exact="true"/>
                      <signal_objects object="$NPC" param="$QueuedTransitionRequests.{1}.{1}" param2="$QueuedTransitionRequests.{1}.{2}"/>
                      <remove_value name="$DispatchTransitionStateChange"/>
                      <do_if value="@$RequestedCue">
                        <!--We don't remove the transition request here as we can't be sure if something else will jump in with a state request before it is processed-->
                      </do_if>
                      <do_else>
                        <debug_text text="'Transition request did not result in a state change request. Removing transition request and queueing the next one (if there is one).'" chance="@$DebugChance"/>
                        <remove_value name="$QueuedTransitionRequests.{1}"/>
                        <do_if value="$QueuedTransitionRequests.{1}?">
                          <set_value name="$QueuedTransition" exact="$QueuedTransitionRequests.{1}"/>
                        </do_if>
                        <do_else>
                          <remove_value name="$QueuedTransitionRequests"/>
                        </do_else>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'A queued state request for ' + parent.$QueuedTransition + ' was set to be processed but it did not match the first entry in the queue [Owen]'" filter="error"/>
                      <remove_value name="$QueuedTransition"/>
                      <do_if value="$QueuedTransitionRequests.count">
                        <signal_cue_instantly cue="QueuedStateChangeTrigger"/>
                      </do_if>
                    </do_else>
                  </do_if>
                  <do_else>
                    <debug_text text="'A queued state request for ' + parent.$QueuedTransition + ' was set to be processed but the queue itself is empty [Owen]'" filter="error"/>
                    <remove_value name="$QueuedTransition"/>
                  </do_else>
                </do_if>

                <reset_cue cue="Handle_ChangeState"/>
                <!--This is to trigger Handle_ChangeState again-->
                <do_if value="@$RequestedCue.exists">
                  <signal_cue cue="ChangeState"/>
                </do_if>
                <do_elseif value="@$QueuedTransition">
                  <signal_cue cue="RequestQueuedTransition"/>
                </do_elseif>
              </actions>
            </cue>
          </cues>
        </cue>

        <!--Queued state change requests will only fire when the state machine is in a phase where nothing else is requesting a regular state change
        Instanced so it can be signalled at any time, but the most recently instanced is the only one which can request the state change
        This cue is signalled when a state has been entered and is designed to perform the subcue actions if that activated state did not trigger a new state change, meaning the state machine is idle-->
        <cue name="QueuedStateChangeTrigger" instantiate="true">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <set_value name="static.$LatestInstance" exact="this"/>
          </actions>
          <cues>
            <cue name="QueuedStateChangeTrigger_Wait">
              <delay exact="1ms"/>
              <actions>
                <do_if value="parent.static.$LatestInstance == parent and @$QueuedTransitionRequests.count">
                  <do_all chance="@$DebugChance">
                    <debug_text text="player.age + ' Attempting to process the queue of transition requests for ' + $NPC.knownname + ' ' + $NPC"/>
                    <do_all exact="$QueuedTransitionRequests.count" counter="$i">
                      <debug_text text="$QueuedTransitionRequests.{$i}"/>
                    </do_all>
                  </do_all>
                  <signal_cue_instantly cue="RequestQueuedTransition" param="$QueuedTransitionRequests.{1}"/>
                </do_if>
                <do_else>
                  <cancel_cue cue="parent"/>
                </do_else>
              </actions>
            </cue>
          </cues>
        </cue>

        <library name="QueueTransitionRequest">
          <actions>
            <do_if value="$CanHaveTransition_Result?">
              <!--if $CanHaveTransition_Result exists it means that this request is just a test to see if this transition was possible. Set $CanHaveTransition_Result to true but don't actually queue-->
              <set_value name="$CanHaveTransition_Result" exact="true"/>
            </do_if>
            <do_else>
              <do_if value="not $QueuedTransitionRequests?">
                <set_value name="$QueuedTransitionRequests" exact="[]"/>
              </do_if>
              <append_to_list name="$QueuedTransitionRequests" exact="[staticbase, [@event.param, @event.param2, @event.param3]]"/>
              <debug_text text="player.age + ' Queueing transition request ' + staticbase + ' with params : ' + @event.param + ' , ' + @event.param2 + ', ' + @event.param3 + ' - currently has ' + $QueuedTransitionRequests.count + ' requests'" chance="@$DebugChance"/>
              <signal_cue_instantly cue="QueuedStateChangeTrigger"/>
            </do_else>
          </actions>
        </library>

        <cue name="ENTER_base">
          <actions>
            <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
          </actions>
        </cue>

        <!--base transitions-->
        <cue name="TRANSITION_reinit" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_state_reinit'"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <!--debugging-->
        <cue name="Change_Debugging" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_set_debugging'"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'npc_set_debugging '+ event.param2"/>
            <do_if value="event.param2">
              <set_value name="$DebugChance" exact="100"/>
            </do_if>
            <do_else>
              <set_value name="$DebugChance" exact="0"/>
            </do_else>
          </actions>
        </cue>

        <cue name="TRANSITION_move_to" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_move_to'" comment="event.param2 = table[
                           $slot = Target slot
                           OR
                           $context = Context component to walk to without a slot (requires $offset and $room),
                           AND
                           $room = Room component related to the floor position at $offset in $context space (NPC will be connected to this room at the end of the movement)
                           
                           $offset = Additional offset to $slot or $context (for which it is required),
                           $rotation = End rotation at the end position, relative to the $slot or $context (optional), 
                           $movementspeed = Movement speed (optional),
                           $destinationtags = List of floor tags at the destination position (optional),
                           $preventanimation = Prevent the default animation at the end of the movement]"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_move_to"/>
              <!--TODO @Owen if slot, check if is free-->
              <set_value name="ChangeState.$ParamTable" exact="event.param2.{2}"/>
            </do_if>
            <do_else>
              <do_if value="typeof event.param2 == datatype.table and (@event.param2.$slot or @event.param2.$context)">
                <include_actions ref="QueueTransitionRequest"/>
              </do_if>
              <do_else>
                <debug_text text="'Invalid call. No valid table or slot/context provided. ' + event.param2" filter="error"/>
              </do_else>
            </do_else>
          </actions>
        </cue>

        <!--TODO @Owen refactor state machines to allow outside state change requests-->

        <!--TODO @Owen find out who's despawning temporary NPCs on dock areas-->
        <cue name="TRANSITION_despawn" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_despawn'" comment="event.param2 = table[$slot = Target slot (optional), $movementspeed = Movement speed (optional), $disconnect = bool (optional), $reinit = bool (optional), $hide = bool (optional)]"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
              <set_value name="ChangeState.$ParamTable" exact="event.param2.{2}"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <!--

        <cue name="TRANSITION_airmarshal_test" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_airmarshal_test' and event.param2 == 'init'"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <cue name="TRANSITION_welder_test" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_welder_test' and event.param2 == 'init'"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <set_value name="$DebugChance" exact="100"/>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_welder"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>-->

        <!--states-->
        <cue name="STATE_init">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_init">
              <actions>
                <debug_text text="player.age + ' *** Initializing state machine for NPC %1 type %2 role %3 controlpost %4'.[$NPC.name, $NPC.type, $NPC.role, $NPC.controlpost]" chance="@$DebugChance" />

                <do_if value="not $NPC.object.isoperational">
                  <signal_cue_instantly cue="ChangeState" param="STATE_not_operational"/>
                </do_if>
                <!--TODO @Owen better init states-->
                <do_elseif value="@$NPC.$Stay">
                  <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                </do_elseif>
                <do_elseif value="@$NPC.$casual or @$NPC.$butler or @$NPC.$station_visitor">
                  <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                </do_elseif>
                <!--<do_elseif value="@$NPC.$DebugDockAreaMovement">
                  <signal_cue_instantly cue="ChangeState" param="STATE_dockarea_movement_test"/>
                </do_elseif>-->
                <do_elseif value="$NPC.controlpost == controlpost.aipilot">
                  <!--AI Pilot Control Entities (pilots/commanders)-->
                  <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot"/>
                </do_elseif>
                <do_elseif value="$NPC.controlpost == controlpost.manager">
                  <signal_cue_instantly cue="ChangeState" param="STATE_manager"/>
                </do_elseif>
                <do_elseif value="$NPC.controlpost == controlpost.shiptrader">
                  <signal_cue_instantly cue="ChangeState" param="STATE_shiptrader"/>
                </do_elseif>
                <do_elseif value="$NPC.controlpost == controlpost.trainee_individual">
                  <signal_cue_instantly cue="ChangeState" param="STATE_trainee_individual"/>
                </do_elseif>
                <do_elseif value="$NPC.type == entitytype.trader or $NPC.type == entitytype.shadyguy">
                  <signal_cue_instantly cue="ChangeState" param="STATE_trader"/>
                </do_elseif>
                <do_elseif value="$NPC.role == entityrole.service">
                  <do_if value="$NPC.$airmarshal_dockingbay?">
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal"/>
                  </do_if>
                  <do_elseif value="$NPC.$roulette_dealer_slot?">
                    <signal_cue_instantly cue="ChangeState" param="STATE_roulette_dealer"/>
                  </do_elseif>
                  <do_else>
                    <signal_cue_instantly cue="ChangeState" param="STATE_worker"/>
                  </do_else>
                </do_elseif>
                <do_elseif value="$NPC.role == entityrole.marine">
                  <signal_cue_instantly cue="ChangeState" param="STATE_marine_guard"/>
                </do_elseif>
                <do_elseif value="$NPC.role == entityrole.trainee_group">
                  <signal_cue_instantly cue="ChangeState" param="STATE_trainee_group"/>
                </do_elseif>
                <do_elseif value="$NPC.type == entitytype.officer">
                  <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                </do_elseif>
                <do_elseif value="$NPC.type == entitytype.factionrepresentative">
                  <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                </do_elseif>
                <do_elseif value="$NPC.type == entitytype.agent">
                  <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                </do_elseif>
                <do_elseif value="$NPC.role == entityrole.prisoner">
                  <signal_cue_instantly cue="ChangeState" param="STATE_prisoner" />
                </do_elseif>
                <do_elseif value="$NPC.ismissionactor">
                  <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                </do_elseif>
                <do_elseif value="$NPC.isavatar">
                  <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                </do_elseif>
                <do_elseif value="$NPC.role == entityrole.passenger">
                  <signal_cue_instantly cue="ChangeState" param="STATE_stay" />
                </do_elseif>
                <do_else>
                  <assert value="false" text="'Unknown NPC state case: ' + $NPC + ' type: ' + $NPC.type + ' role: ' + $NPC.role + ' post ' + $NPC.controlpost + ' [Owen]'"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_init" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_not_operational">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
            <set_entity_traits entity="$NPC" hidden="true"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="EXIT_not_operational" ref="EXIT_Empty"/>

            <!--transitions-->
            <cue name="TRANSITION_not_operational_now_operational" instantiate="true">
              <conditions>
                <check_any>
                  <event_object_changed_state object="$NPC.object" state="componentstate.operational"/>
                  <event_object_signalled object="$NPC" param="staticbase"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <set_entity_traits entity="$NPC" hidden="false"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                </do_if>
                <do_else>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>

            <cue name="TRANSITION_not_operational_changed_room" instantiate="true">
              <conditions>
                <check_any>
                  <event_object_changed_room object="$NPC"/>
                  <event_object_signalled object="$NPC" param="staticbase"/>
                </check_any>
              </conditions>
              <actions>
                <!--reinitialise from new room-->
                <do_if value="@$DispatchTransitionStateChange">
                  <set_entity_traits entity="$NPC" hidden="false"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                </do_if>
                <do_else>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_move_to">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_move_to">
              <actions>
                <do_if value="STATE_move_to.$ParamTable?">
                  <set_value name="this.$startslot" exact="@STATE_move_to.$ParamTable.$startslot"/>
                  <set_value name="this.$destinationslot" exact="@STATE_move_to.$ParamTable.$slot"/>
                  <set_value name="this.$destinationcontext" exact="@STATE_move_to.$ParamTable.$context"/>
                  <set_value name="this.$destinationoffset" exact="@STATE_move_to.$ParamTable.$offset"/>
                  <set_value name="this.$destinationcontextroom" exact="@STATE_move_to.$ParamTable.$room"/>
                  <set_value name="this.$destinationrotation" exact="@STATE_move_to.$ParamTable.$rotation"/>
                  <set_value name="this.$destinationtags" exact="@STATE_move_to.$ParamTable.$destinationtags"/>
                  <set_value name="this.$preventanimation" exact="@STATE_move_to.$ParamTable.$preventanimation"/>
                  <set_value name="this.$checkonly" exact="@STATE_move_to.$ParamTable.$checkonly"/>

                  <do_if value="this.$destinationslot">
                    <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                      <param name="NPC" value="$NPC"/>
                      <param name="StartSlot" value="this.$startslot"/>
                      <param name="DestinationSlot" value="this.$destinationslot"/>
                      <param name="DestinationOffset" value="this.$destinationoffset"/>
                      <param name="DestinationRotation" value="this.$destinationrotation"/>
                      <param name="DestinationTags" value="this.$destinationtags"/>
                      <param name="AnimateAtEnd" value="not this.$preventanimation"/>
                      <param name="DebugChance" value="@$DebugChance"/>
                    </run_actions>
                  </do_if>
                  <do_elseif value="this.$destinationcontext and this.$destinationcontextroom">
                    <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToPosition">
                      <param name="NPC" value="$NPC"/>
                      <param name="DestinationContext" value="this.$destinationcontext"/>
                      <param name="DestinationContextRoom" value="this.$destinationcontextroom"/>
                      <param name="DestinationOffset" value="this.$destinationoffset"/>
                      <param name="DestinationRotation" value="this.$destinationrotation"/>
                      <param name="DestinationTags" value="this.$destinationtags" comment="List of floor tags at the destination position"/>
                      <param name="AnimateAtEnd" value="not this.$preventanimation"/>
                      <param name="DebugChance" value="@$DebugChance"/>
                    </run_actions>
                  </do_elseif>

                  <do_if value="this.$checkonly">
                    <signal_objects object="$NPC" param="'npc_statemachine_moveto'" param2="this.$pathtable != null"/>
                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </do_if>
                  <do_else>
                    <do_if value="this.$pathtable">
                      <set_value name="$pathtable" exact="this.$pathtable"/>
                      <do_if value="STATE_move_to.$ParamTable.$movementspeed?">
                        <set_value name="$pathtable.$speed" exact="STATE_move_to.$ParamTable.$movementspeed"/>
                      </do_if>
                      <do_else>
                        <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                      </do_else>
                      <do_if value="this.$destinationslot and this.$destinationslot.hastag.npc">
                        <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                      </do_if>
                      <do_else>
                        <clear_actor_roomslot actor="$NPC"/>
                      </do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_move_to_moving"/>
                    </do_if>
                    <do_else>
                      <do_if value="this.$destinationslot">
                        <run_actions ref="MoveFailedHandling_ToSlot">
                          <param name="NPC" value="$NPC"/>
                          <param name="DestinationSlot" value="this.$destinationslot"/>
                          <param name="DestinationOffset" value="this.$destinationoffset"/>
                          <param name="DestinationRotation" value="this.$destinationrotation"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>
                      </do_if>
                      <do_elseif value="this.$destinationcontext and this.$destinationcontextroom">
                        <run_actions ref="MoveFailedHandling_ToPosition">
                          <param name="NPC" value="$NPC"/>
                          <param name="DestinationContext" value="this.$destinationcontext"/>
                          <param name="DestinationContextRoom" value="this.$destinationcontextroom"/>
                          <param name="DestinationOffset" value="this.$destinationoffset"/>
                          <param name="DestinationRotation" value="this.$destinationrotation"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>
                      </do_elseif>
                      <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                    </do_else>
                  </do_else>
                </do_if>
                <do_else>
                  <debug_text text="player.age + ' ParamTable ' + @STATE_move_to.$ParamTable + ' Was not valid.'" filter="error"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_move_to" ref="EXIT_Empty"/>

            <!--Sub-states-->

            <cue name="STATE_move_to_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_move_to_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_move_to_moving_finished"/>
                  <param name="DebugChance" value="@$DebugChance"/>
                </cue>

                <cue name="EXIT_move_to_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_move_to_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_despawn">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
            <!--TODO @Owen #HACK Have some time to allow nav helpers to generate in cases such as a NPC leaving a S sized ship where the doors and ladders are animating-->
            <set_value name="$FailTimeout" exact="player.age + 10s"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_despawn">
              <actions>
                <signal_cue_instantly cue="ChangeState" param="STATE_despawn_find"/>
              </actions>
            </cue>

            <cue name="EXIT_despawn" ref="EXIT_Empty"/>

            <!--Sub-states-->
            <cue name="STATE_despawn_find">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_despawn_find">
                  <actions>
                    <set_value name="STATE_despawn.$Disconnect" exact="@STATE_despawn.$ParamTable.$disconnect"/>
                    <set_value name="STATE_despawn.$Reinit" exact="@STATE_despawn.$ParamTable.$reinit"/>
                    <!--TODO @Owen change the other parameters to also only be set if they exist so we can have better default behaviour?-->
                    <do_if value="STATE_despawn.$ParamTable.$hide?">
                      <set_value name="STATE_despawn.$Hide" exact="STATE_despawn.$ParamTable.$hide"/>
                    </do_if>
                    <set_value name="this.$fallbacktolocal" exact="false"/>
                    <do_if value="STATE_despawn.$ParamTable? and @STATE_despawn.$ParamTable.$slot">
                      <set_value name="this.$destinationslot" exact="STATE_despawn.$ParamTable.$slot"/>
                    </do_if>
                    <do_else>
                      <!--Find a despawn slot on the assigned object-->
                      <set_value name="this.$destinationslot" exact="null"/>
                      <do_if value="$NPC.controlpost">
                        <set_value name="this.$slotcontext" exact="$NPC.assignedcontrolled"/>
                      </do_if>
                      <do_elseif value="$NPC.role">
                        <set_value name="this.$slotcontext" exact="$NPC.roleobject"/>
                      </do_elseif>
                      <do_else>
                        <set_value name="this.$slotcontext" exact="$NPC.room"/>
                      </do_else>

                      <!--Attempt to find a despawn point on the slotcontext first. Otherwise fallback to the NPCs current object.-->
                      <do_if value="this.$slotcontext">
                        <debug_text text="'Will attempt to find despawn slot on ' + this.$slotcontext + ' ' + this.$slotcontext.knownname" chance="@$DebugChance"/>
                        <do_if value="not $NPC.hascontext.{this.$slotcontext}">
                          <find_npc_waypoint name="this.$destinationslot" object="this.$slotcontext" tags="[tag.npctransport, tag.npc_location_exit]"/>
                        </do_if>
                        <do_if value="not this.$destinationslot">
                          <find_npc_waypoint name="this.$destinationslot" object="this.$slotcontext" tags="tag.npctransport"/>
                        </do_if>
                        <set_value name="this.$fallbacktolocal" exact="true"/>
                      </do_if>
                    </do_else>

                    <do_if value="not this.$destinationslot">
                      <include_actions ref="FindLocalDespawnLocation"/>
                    </do_if>

                    <do_if value="this.$destinationslot">
                      <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                        <param name="NPC" value="$NPC"/>
                        <param name="DestinationSlot" value="this.$destinationslot"/>
                        <param name="DebugChance" value="@$DebugChance"/>
                      </run_actions>
                      <do_if value="not this.$pathtable and this.$fallbacktolocal">
                        <!--If no path found to the best despawn slot. Try a local despawn slot.-->
                        <debug_text text="'Unable to find path to despawn on destination object. Attempting on current local object.'" chance="@$DebugChance"/>
                        <include_actions ref="FindLocalDespawnLocation"/>
                        <do_if value="this.$destinationslot">
                          <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                            <param name="NPC" value="$NPC"/>
                            <param name="DestinationSlot" value="this.$destinationslot"/>
                            <param name="DebugChance" value="@$DebugChance"/>
                          </run_actions>
                        </do_if>
                      </do_if>

                      <do_if value="this.$pathtable">
                        <set_value name="$pathtable" exact="this.$pathtable"/>
                        <do_if value="STATE_despawn.$ParamTable? and @STATE_despawn.$ParamTable.$movementspeed">
                          <set_value name="$pathtable.$speed" exact="STATE_despawn.$ParamTable.$movementspeed"/>
                        </do_if>
                        <do_else>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                        </do_else>
                        <do_if value="this.$destinationslot.hastag.npc">
                          <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                        </do_if>
                        <do_else>
                          <clear_actor_roomslot actor="$NPC"/>
                        </do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_despawn_moving"/>
                      </do_if>
                      <do_elseif value="player.age lt $FailTimeout">
                        <debug_text text="'Unable to find path to despawn location. Attempts will continue for another ' + ($FailTimeout - player.age)" chance="@$DebugChance"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_despawn_wait"/>
                      </do_elseif>
                      <do_else>
                        <run_actions ref="MoveFailedHandling_ToSlot">
                          <param name="NPC" value="$NPC"/>
                          <param name="DestinationSlot" value="this.$destinationslot"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_despawn_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="player.age + ' Unable to find room slot with tag ' + tag.npctransport + ' - NPC will disappear instantly.'" filter="error"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_despawn_finished"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_despawn_find" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_despawn_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_despawn_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_despawn_moving_finished"/>
                  <param name="DebugChance" value="@$DebugChance"/>
                </cue>

                <cue name="EXIT_despawn_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_despawn_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_despawn_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_despawn_wait">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_despawn_wait">
                  <delay exact="1s"/>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_despawn_find"/>
                  </actions>
                </cue>

                <cue name="EXIT_despawn_wait" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_despawn_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_despawn_finished" checkinterval="1ms">
                  <conditions>
                    <!--Only kill NPC if there are no queued requests-->
                    <check_value value="@$QueuedTransitionRequests.count == 0 and not @$RequestedCue"/>
                  </conditions>
                  <actions>
                    <do_if value="@STATE_despawn.$Disconnect">
                      <debug_text text="'Despawn finished ' + $NPC + ' ' + $NPC.knownname + ' disconnecting NPC.'" chance="@$DebugChance"/>
                      <!--TODO @Owen should role object be cleared here?-->
                      <remove_actor_from_room actor="$NPC"/>
                      <cancel_cue cue="Base"/>
                    </do_if>
                    <do_elseif value="@STATE_despawn.$Reinit">
                      <debug_text text="'Despawn finished ' + $NPC + ' ' + $NPC.knownname + ' set to hidden and reinitialising NPC.'" chance="@$DebugChance"/>
                      <set_entity_traits entity="$NPC" hidden="if STATE_despawn.$Hide? then STATE_despawn.$Hide else true"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_elseif>
                    <do_elseif value="@STATE_despawn.$Hide">
                      <debug_text text="'Despawn finished ' + $NPC + ' ' + $NPC.knownname + ' set to hidden.'" chance="@$DebugChance"/>
                      <set_entity_traits entity="$NPC" hidden="true"/>
                    </do_elseif>
                    <do_else>
                      <debug_text text="'Despawn finished ' + $NPC + ' ' + $NPC.knownname + ' destroying NPC.'" chance="@$DebugChance"/>
                      <destroy_object object="$NPC"/>
                      <cancel_cue cue="Base"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_despawn_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_idle">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_idle">
              <actions>
                <set_value name="this.$allowpropinteraction" exact="true"/>
                <do_if value="@$NPC.$interacting_with_prop_slot">
                  <set_value name="this.$allowpropinteraction" exact="false"/>
                  <remove_value name="$NPC.$interacting_with_prop_slot"/>
                </do_if>
                <do_if value="this.$allowpropinteraction and $NPC.roomslot and $NPC.roomslot.hasanytag.[tag.pickup_locker, tag.coffeemachine, tag.vendingmachine]">
                  <signal_cue_instantly cue="ChangeState" param="STATE_idle_prop_interaction"/>
                </do_if>
                <do_else>
                  <signal_cue_instantly cue="ChangeState" param="STATE_idle_stay"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_idle">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <do_if value="$staytime?">
                  <remove_value name="$staytime"/>
                </do_if>
              </actions>
            </cue>

            <!--Sub-states-->
            <cue name="STATE_idle_stay">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_idle_stay">
                  <actions>
                    <set_value name="$force" exact="false"/>
                    <do_if value="@$NPC.$butler">
                      <do_if value="not @$NPC.roomslot.hastag.butler">
                        <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' is not at a valid slot. Find new destination.'" chance="@$DebugChance"/>
                        <set_value name="$staytime" exact="1ms"/>
                        <set_value name="$force" exact="true"/>
                      </do_if>
                      <do_else>
                        <set_value name="$staytime" min="5min" max="6min"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <do_if value="not @$NPC.roomslot.hastag.npc_generic">
                        <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' is not at a valid slot. Find new destination. ' + $NPC.attention" chance="@$DebugChance"/>
                        <set_value name="$staytime" exact="1ms"/>
                        <set_value name="$force" exact="true"/>
                      </do_if>
                      <do_elseif value="player.module == 'x4ep1_gamestart_hub'">
                        <!--TODO @Owen #Hack better way of controlling global idle times-->
                        <do_if value="player.age lt 10s">
                          <set_value name="$staytime" min="1s" max="10s"/>
                        </do_if>
                        <do_else>
                          <set_value name="$staytime" min="45s" max="90s"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="$NPC.attention lt attention.nearby">
                        <!--distant case-->
                        <set_value name="$staytime" min="5min" max="6min"/>
                      </do_elseif>
                      <do_else>
                        <!--near case-->
                        <set_value name="$staytime" min="2min" max="3min"/>
                      </do_else>
                    </do_else>
                  </actions>
                  <cues>
                    <cue name="ENTER_idle_stay_interrupt">
                      <delay exact="$staytime"/>
                      <actions>
                        <signal_objects object="$NPC" param="'idle_stay__end'" param2="@$force"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="EXIT_idle_stay_v2">
                  <conditions>
                    <event_cue_signalled cue="parent"/>
                    <check_value value="@event.param == 'exit'"/>
                  </conditions>
                  <actions>
                    <clear_actor_lookat actor="$NPC"/>
                    <remove_value name="$staytime"/>
                    <remove_value name="$force"/>
                  </actions>
                </cue>

                <!--Transitions-->
                <cue name="TRANSITION_idle_attempt_move">
                  <conditions>
                    <check_any>
                      <check_all>
                        <!--NPC moved into nearby attention-->
                        <event_object_changed_attention object="$NPC"/>
                        <check_value value="event.param2 lt attention.nearby and event.param ge attention.nearby"/>
                      </check_all>
                      <check_all>
                        <!--NPC was signalled to attempt to move. event.param2 = force-->
                        <event_object_signalled object="$NPC" param="'idle_stay__end'"/>
                        <check_value value="event.param2 or $NPC.attention ge attention.nearby"/>
                      </check_all>
                      <check_all>
                        <event_object_signalled object="$NPC" param="'moveto_roulette'"/>
                        <check_value value="event.param2.$roulette_dealer_slot?"/>
                      </check_all>
                    </check_any>
                  </conditions>
                  <delay min="0s" max="if event.name == 'event_object_changed_attention' then 10s else 1s"/>
                  <actions>
                    <include_actions ref="Validate_Usecase_Reservation"/>
                    <do_if value="@$UsecaseCue.exists">
                      <signal_cue_instantly cue="ChangeState" param="STATE_idle_stay" />
                    </do_if>
                    <do_else>
                      <set_value name="this.$destinationslot" exact="null"/>
                      <do_if value="event.param == 'moveto_roulette'">
                        <!--TODO @Owen group filter-->
                        <find_npc_slot name="this.$potentialslots" object="event.param2.$roulette_dealer_slot.component" tags="tag.roulette_player" multiple="true"/>
                        <shuffle_list list="this.$potentialslots"/>
                        <do_for_each name="$potentialslot" in="this.$potentialslots">
                          <do_if value="event.param2.$roulette_dealer_slot.group == $potentialslot.group">
                            <debug_text text="'Signalled NPC ' + $NPC + ' ' + $NPC.knownname + ' has found roulette player slot ' + $potentialslot + ' and will move there'" chance="@$DebugChance"/>
                            <set_value name="this.$destinationslot" exact="$potentialslot"/>
                            <break/>
                          </do_if>
                        </do_for_each>
                      </do_if>
                      <do_else>
                        <set_value name="this.$slotcomponents" exact="[]"/>
                        <do_if value="$NPC.roleobject.isclass.ship">
                          <append_to_list name="this.$slotcomponents" exact="$NPC.roleobject"/>
                        </do_if>
                        <do_else>
                          <append_to_list name="this.$slotcomponents" exact="$NPC.walkablemodule"/>
                          <append_to_list name="this.$slotcomponents" exact="$NPC.room"/>
                          <append_to_list name="this.$slotcomponents" exact="$NPC.container"/>
                        </do_else>
                        <set_value name="this.$wantedslottags" exact="[]"/>
                        <do_if value="@$NPC.$butler">
                          <append_to_list name="this.$wantedslottags" exact="tag.butler"/>
                        </do_if>
                        <do_else>
                          <append_to_list name="this.$wantedslottags" exact="tag.npc_generic"/>
                          <append_to_list name="this.$wantedslottags" exact="tag.pickup_locker"/>
                          <do_if value="not $NPC.hastool">
                            <append_to_list name="this.$wantedslottags" exact="tag.coffeemachine"/>
                            <append_to_list name="this.$wantedslottags" exact="tag.vendingmachine"/>
                          </do_if>
                        </do_else>
                        <shuffle_list list="this.$slotcomponents"/>
                        <shuffle_list list="this.$wantedslottags"/>
                        <do_for_each name="$wantedslottag" in="this.$wantedslottags">
                          <do_for_each name="$slotcomponent" in="this.$slotcomponents">
                            <do_if value="$slotcomponent">
                              <find_npc_slot name="this.$potentialslots" object="$slotcomponent" tags="$wantedslottag" multiple="true"/>
                              <shuffle_list list="this.$potentialslots"/>
                              <do_for_each name="$potentialslot" in="this.$potentialslots">
                                <do_if value="$potentialslot.hastag.roulette_player">
                                  <!--TODO @Owen group filter-->
                                  <find_npc_slot name="this.$dealerslots" object="$potentialslot.component" tags="tag.roulette_dealer" excludefilled="false" multiple="true"/>
                                  <do_for_each name="$dealerslot" in="this.$dealerslots">
                                    <do_if value="$dealerslot.group == $potentialslot.group">
                                      <set_value name="this.$dealer" exact="$dealerslot.component.slotactor.{$dealerslot}"/>
                                      <do_if value="this.$dealer and not this.$dealer.isintransit">
                                        <debug_text text="'Roulette player slot ' + $potentialslot + ' has table dealer ' + this.$dealer + ' ' + this.$dealer.knownname + ' ready'" chance="@$DebugChance"/>
                                        <set_value name="this.$destinationslot" exact="$potentialslot"/>
                                        <break/>
                                      </do_if>
                                    </do_if>
                                  </do_for_each>
                                  <do_if value="this.$destinationslot">
                                    <break/>
                                  </do_if>
                                </do_if>
                                <do_elseif value="$potentialslot.hasanytag.[tag.sit, tag.sit_bar, tag.sit_table] and ($NPC.hastool or $NPC.race == race.boron or $NPC.race == race.paranid)">
                                  <!--Prevent Boron, Paranid or characters holding tools from sitting-->
                                  <continue/>
                                </do_elseif>
                                <do_elseif value="$potentialslot.hastag.sit and $potentialslot.component.macro.id == 'room_gen_livingquarter_01_macro'">
                                  <!--HACK @Owen until these slots change their tag to sit_spawn-->
                                  <continue/>
                                </do_elseif>
                                <do_elseif value="@$NPC.roomslot.hasanytag.[tag.sit, tag.sit_bar, tag.sit_table] and $NPC.distanceto.{$potentialslot} lt 5m">
                                  <!--Don't stand from sitting just to move to another nearby sit slot-->
                                  <continue/>
                                </do_elseif>
                                <do_else>
                                  <set_value name="this.$destinationslot" exact="$potentialslot"/>
                                </do_else>

                                <do_if value="this.$destinationslot">
                                  <break/>
                                </do_if>
                              </do_for_each>
                            </do_if>
                            <do_if value="this.$destinationslot">
                              <break/>
                            </do_if>
                          </do_for_each>
                          <do_if value="this.$destinationslot">
                            <break/>
                          </do_if>
                        </do_for_each>
                      </do_else>
                      <do_if value="this.$destinationslot">
                        <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                          <param name="NPC" value="$NPC"/>
                          <param name="DestinationSlot" value="this.$destinationslot"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>
                        <do_if value="this.$pathtable">
                          <set_value name="$pathtable" exact="this.$pathtable"/>
                          <do_if value="this.$destinationslot.hastag.stand_terminal">
                            <do_if value="$NPC.room.parent.isclass.walkablemodule">
                              <set_value name="$pathtable.$speed" exact="$NPC.runspeed"/>
                            </do_if>
                            <do_else>
                              <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                            </do_else>
                          </do_if>
                          <do_else>
                            <set_value name="$pathtable.$speed" exact="[$NPC.slowwalkspeed, $NPC.walkspeed].random"/>
                          </do_else>
                          <do_if value="this.$destinationslot.hastag.npc">
                            <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                          </do_if>
                          <do_else>
                            <clear_actor_roomslot actor="$NPC"/>
                          </do_else>
                          <signal_cue_instantly cue="ChangeState" param="STATE_idle_moving"/>
                        </do_if>
                        <do_else>
                          <run_actions ref="MoveFailedHandling_ToSlot">
                            <param name="NPC" value="$NPC"/>
                            <param name="DestinationSlot" value="this.$destinationslot"/>
                            <param name="DebugChance" value="@$DebugChance"/>
                          </run_actions>
                          <signal_cue_instantly cue="ChangeState" param="STATE_idle_stay"/>
                        </do_else>
                      </do_if>
                      <do_else>
                        <do_if value="@$NPC.$butler">
                          <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' was a butler but the assigned object does not have butler slots. Removing butler flag'" chance="@$DebugChance"/>
                          <remove_value name="$NPC.$butler"/>
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                        <do_else>
                          <set_value name="this.$SlotControllable" exact="null"/>
                          <do_if value="$NPC.roomslot">
                            <set_value name="this.$SlotControllable" exact="if $NPC.roomslot.component.isclass.controllable then $NPC.roomslot.component else $NPC.roomslot.component.controllable"/>
                          </do_if>
                          <do_if value="this.$SlotControllable and this.$SlotControllable.controlpositions.list.indexof.{$NPC.roomslot}">
                            <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' is blocking a control position slot but can not find a generic slot. Moving to despawn'" filter="error"/>
                            <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
                          </do_if>
                          <do_else>
                            <signal_cue_instantly cue="ChangeState" param="STATE_idle_stay"/>
                          </do_else>
                        </do_else>
                      </do_else>

                    </do_else>
                    <!--Standard tranition exit handling-->
                    <include_actions ref="Transition_Exit"/>
                  </actions>
                </cue>

                <cue name="TRANSITION_idle_distant">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'idle_stay__end'"/>
                    <!--if forced (event.param2 == true) then have TRANSITION_idle_attempt_move handle the signal-->
                    <check_value value="not event.param2 and $NPC.attention lt attention.nearby"/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_idle_stay"/>

                    <!--Standard tranition exit handling-->
                    <include_actions ref="Transition_Exit"/>
                  </actions>
                </cue>

                <!--Generic cue to handle a number of animation requests from outside sources-->
                <cue name="TRANSITION_idle_animation_event" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC"/>
                    <check_any>
                      <check_value value="event.param == 'roulette_start'"/>
                      <check_value value="event.param == 'roulette_win'"/>
                      <check_value value="event.param == 'roulette_lose'"/>
                    </check_any>
                    <check_value value="$NPC.hasbody"/>
                  </conditions>
                  <actions>
                    <set_value name="this.$Emote" exact="null"/>
                    <set_value name="this.$PerformAnimation" exact="@$NPC.roomslot.hastag.stand"/>
                    <do_if value="event.param == 'roulette_start'">
                      <do_if value="this.$PerformAnimation">
                        <do_any>
                          <set_value name="this.$Emote" exact="'gesticulate01'" weight="20"/>
                          <set_value name="this.$Emote" exact="'gesticulate03'" weight="20"/>
                          <set_value name="this.$Emote" exact="'gesticulate04'" weight="20"/>
                          <set_value name="this.$Emote" exact="'crossarms01'" weight="20"/>
                          <set_value name="this.$Emote" exact="'thinking01'" weight="20"/>
                          <set_value name="this.$Emote" exact="null" weight="50"/>
                        </do_any>
                      </do_if>
                      <set_actor_lookat actor="$NPC" component="event.param2.component.slotactor.{event.param2}" chance="30"/>
                    </do_if>
                    <do_elseif value="event.param == 'roulette_win'">
                      <do_if value="this.$PerformAnimation">
                        <do_any>
                          <set_value name="this.$Emote" exact="'punchhand01'" weight="20"/>
                          <set_value name="this.$Emote" exact="'nod01'" weight="20"/>
                          <set_value name="this.$Emote" exact="null" weight="5"/>
                        </do_any>
                      </do_if>
                      <speak actor="$NPC" line="1006" chance="if $NPC.room == player.room then 10 else 0"/>
                      <clear_actor_lookat actor="$NPC"/>
                    </do_elseif>
                    <do_elseif value="event.param == 'roulette_lose'">
                      <do_if value="this.$PerformAnimation">
                        <do_any>
                          <set_value name="this.$Emote" exact="'disapproval01'" weight="20"/>
                          <set_value name="this.$Emote" exact="'facepalm01'" weight="20"/>
                          <set_value name="this.$Emote" exact="'rolleyes01'" weight="20"/>
                          <set_value name="this.$Emote" exact="'rolleyes02'" weight="20"/>
                          <set_value name="this.$Emote" exact="null" weight="5"/>
                        </do_any>
                      </do_if>
                      <clear_actor_lookat actor="$NPC"/>
                      <speak actor="$NPC" line="1001" chance="if $NPC.room == player.room then 10 else 0"/>
                    </do_elseif>

                    <do_if value="this.$Emote">
                      <set_actor_emotion actor="$NPC" emotion="this.$Emote"/>
                    </do_if>
                  </actions>
                </cue>

                <cue name="TRANSITION_idle_alert_changed">
                  <conditions>
                    <event_alert_level_changed object="$NPC.roleobject" check="false"/>
                  </conditions>
                  <actions>
                    <do_if value="event.param == 'red'">
                      <do_if value="($NPC.role == entityrole.service or $NPC.role == entityrole.marine) and not @$NPC.$butler">
                        <debug_text text="'Object ' + $NPC.roleobject + ' is condition red and NPC ' + $NPC + ' ' + $NPC.knownname + ' will leave casual behavior'" chance="@$DebugChance"/>
                        <remove_value name="$NPC.$casual"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                      </do_if>
                    </do_if>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_idle_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_idle_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_idle_moving_finished"/>
                  <param name="DebugChance" value="@$DebugChance"/>
                </cue>

                <cue name="EXIT_idle_moving_finished" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_idle_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_idle_move_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_idle_move_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_idle_move_finished">
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                  </actions>
                </cue>

                <cue name="EXIT_idle_move_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <!--Single stage interaction. Start animation, optionally have a tool attach after a duration, finish animation and move away-->
            <cue name="STATE_idle_prop_interaction">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_idle_prop_interaction">
                  <actions>
                    <do_if value="$NPC.hasbody">
                      <set_value name="$NPC.$interacting_with_prop_slot" exact="true"/>
                      <set_value name="$endanimation" exact="null"/>
                      <set_value name="$attachanimation" exact="null"/>
                      <set_value name="$finishdelay" exact="0.3s" comment="Delay after the $endanimation has finished to restart the idle state and move on"/>
                      <set_value name="this.$animationstarted" exact="false"/>
                      <set_value name="$attachdelay" exact="1ms"/>
                      <set_value name="$activationdelay" exact="1s"/>
                      <set_value name="this.$type" exact="null"/>
                      <set_value name="this.$behaviour" exact="null"/>
                      <do_if value="$NPC.roomslot.hastag.pickup_locker">
                        <do_if value="$NPC.hastool">
                          <set_value name="this.$type" exact="'tool_putin_locker'"/>
                          <set_value name="this.$behaviour" exact="'generic'"/>
                          <set_value name="$endanimation" exact="'anim_locker_putin'"/>
                          <set_value name="$activationdelay" exact="0.1s"/>
                          <set_value name="$attachanimation" exact="'anim_locker_putin'"/>
                          <set_value name="$attachdelay" exact="2.8s" comment="remove prop"/>
                        </do_if>
                        <do_else>
                          <set_value name="this.$type" exact="'tool_takeout_locker'"/>
                          <set_value name="this.$behaviour" exact="'generic'"/>
                          <set_value name="$endanimation" exact="'anim_locker_takeout'"/>
                          <set_value name="$activationdelay" exact="0.1s"/>
                          <set_value name="$attachanimation" exact="'anim_locker_takeout'"/>
                          <set_value name="$attachdelay" exact="0.9s"/>
                        </do_else>
                      </do_if>
                      <do_elseif value="$NPC.roomslot.hastag.coffeemachine">
                        <set_value name="this.$type" exact="'coffeemachine_use'"/>
                        <set_value name="this.$behaviour" exact="'generic'"/>
                        <set_value name="$endanimation" exact="'coffeemachine_takeout'"/>
                        <set_value name="$activationdelay" exact="4.0s"/>
                        <set_value name="$attachanimation" exact="'coffeemachine_takeout'"/>
                        <set_value name="$attachdelay" exact="1.6s"/>
                      </do_elseif>
                      <do_elseif value="$NPC.roomslot.hastag.vendingmachine">
                        <set_value name="this.$type" exact="'vendingmachine_use'"/>
                        <set_value name="this.$behaviour" exact="'generic'"/>
                        <set_value name="$endanimation" exact="'vending_takeout'"/>
                        <set_value name="$activationdelay" exact="2.2s"/>
                        <set_value name="$attachanimation" exact="'vending_takeout'"/>
                        <set_value name="$attachdelay" exact="1.6s"/>
                      </do_elseif>
                      <do_else>
                        <debug_text text="'NPC: ' + $NPC.knownname + ' ' + $NPC + ' is at a slot that does not have tags the state machine recognises for prop interaction. Tags: ' + @$NPC.roomslot.tags" filter="error" />
                      </do_else>

                      <do_if value="this.$type and this.$behaviour and $endanimation">
                        <start_actor_sequence actor="$NPC" type="this.$type" behavior="this.$behaviour" transition="true" result="this.$animationstarted" />
                        <do_if value="this.$animationstarted">
                          <debug_text text="player.age + ' NPC: ' + $NPC.knownname + ' ' + $NPC + ' started animation ' + this.$type + ' ' + this.$behaviour" chance="@$DebugChance" />
                        </do_if>
                        <do_else>
                          <set_value name="$endanimation" exact="null"/>
                          <debug_text text="player.age + ' NPC: ' + $NPC.knownname + ' ' + $NPC + ' unable to start animation ' + this.$type + ' behaviour ' + this.$behaviour" filter="error"/>
                          <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                        </do_else>
                      </do_if>
                      <do_else>
                        <set_value name="$endanimation" exact="null"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <set_value name="$endanimation" exact="null"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_idle_prop_interaction">
                  <conditions>
                    <event_cue_signalled cue="parent"/>
                    <check_value value="@event.param == 'exit'"/>
                  </conditions>
                  <actions>
                    <remove_value name="$activationdelay"/>
                    <remove_value name="$attachdelay"/>
                    <remove_value name="$finishdelay"/>
                    <remove_value name="$endanimation"/>
                    <remove_value name="$attachanimation"/>
                  </actions>
                </cue>

                <!-- Transitions -->
                <cue name="TRANSITION_idle_prop_interaction_started">
                  <conditions>
                    <event_character_animation_started object="$NPC" />
                    <check_value value="$endanimation"/>
                  </conditions>
                  <actions>
                    <trigger_animation object="$NPC.roomslot.component" trigger="activate" delay="$activationdelay" />
                  </actions>
                </cue>

                <cue name="TRANSITION_idle_prop_attach_animation_started">
                  <conditions>
                    <event_character_animation_started object="$NPC" />
                    <check_value value="$attachanimation and event.param == $attachanimation"/>
                  </conditions>
                  <delay exact="$attachdelay"/>
                  <actions>
                    <do_if value="$NPC.hastool">
                      <clear_actor_tool actor="$NPC"/>
                    </do_if>
                    <do_else>
                      <do_if value="$endanimation == 'anim_locker_takeout'">
                        <set_actor_tool actor="$NPC" name="'lunch1hand'" />
                      </do_if>
                      <do_elseif value="$endanimation == 'coffeemachine_takeout'">
                        <set_actor_tool actor="$NPC" name="'mug1hand'" />
                      </do_elseif>
                      <do_elseif value="$endanimation == 'vending_takeout'">
                        <set_actor_tool actor="$NPC" name="'lunch1hand'" />
                      </do_elseif>
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_idle_prop_interaction_finished">
                  <conditions>
                    <event_character_animation_finished object="$NPC" />
                    <check_value value="$endanimation and event.param == $endanimation"/>
                  </conditions>
                  <actions>
                    <trigger_animation object="$NPC.roomslot.component" trigger="deactivate" />
                  </actions>
                  <delay exact="$finishdelay"/>
                  <actions>
                    <!--Restart the idle state to move on-->
                    <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="TRANSITION_control_dismissed" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc__control_dismissed'" comment="event.param2 = replacement NPC actor or npctemplate (optional), event.param3 = controllable for event.param2 if npctemplate"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_control_dismissed"/>
              <set_value name="ChangeState.$ParamTable" exact="table[$replacement = event.param2.{2}, $replacementroleobject = event.param2.{3}]"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <!--TODO @Owen - can we remove the whole state? move the dismiss_control_entity to the caller and then trigger a despawn. No need for the replacement logic.-->
        <cue name="STATE_control_dismissed">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_STATE_control_dismissed">
              <actions>
                <set_value name="this.$Controlled" exact="$NPC.assignedcontrolled"/>
                <do_if value="this.$Controlled">
                  <debug_text text="'Preparing to dismiss NPC ' + $NPC.knownname + ' ' + $NPC + ' from ' + this.$Controlled.knownname + ' ' + this.$Controlled + ' params: ' + STATE_control_dismissed.$ParamTable" chance="@$DebugChance"/>
                  <set_value name="this.$assignment" exact="$NPC.controlpost"/>
                  <!--Fallback role for the dismissed NPC to take so they are not lost. Can be overwritten by the replacement NPCs old role-->
                  <set_value name="this.$FallbackRole" exact="null"/>
                  <set_value name="this.$ReplacementNPC" exact="null"/>
                  <set_value name="this.$ReplacementTemplate" exact="null"/>
                  <set_value name="this.$ReplacementRoleObject" exact="null"/>
                  <set_value name="this.$FoundExistingNPC" exact="false"/>

                  <do_if value="@STATE_control_dismissed.$ParamTable.$replacement">
                    <do_if value="typeof STATE_control_dismissed.$ParamTable.$replacement == datatype.npctemplate">
                      <set_value name="this.$ReplacementTemplate" exact="STATE_control_dismissed.$ParamTable.$replacement"/>
                      <set_value name="this.$ReplacementRoleObject" exact="STATE_control_dismissed.$ParamTable.$replacementroleobject"/>
                      <debug_text text="'Replacement NPC is the NPC template ' + this.$ReplacementTemplate + ' on ' + this.$ReplacementRoleObject" chance="@$DebugChance"/>
                      <assert value="this.$ReplacementRoleObject.exists" text="'Invalid role object: ' + this.$ReplacementRoleObject + ' - [Owen]'"/>
                      <do_if value="this.$ReplacementRoleObject.people.{this.$ReplacementTemplate}.exists">
                        <!--Set the fallback role to the current role of the replacement (note, this $NPC prefer to stay on their current object instead of move to the $ReplacementRoleObject)-->
                        <!--TODO @Owen - better logbook messages of where who went and what they changed to-->
                        <set_value name="this.$FallbackRole" exact="this.$ReplacementRoleObject.people.{this.$ReplacementTemplate}.role"/>
                        <assert value="this.$FallbackRole" text="'Replacing NPC ' + $NPC + ' ' + $NPC.knownname + ' with person ' + this.$ReplacementTemplate + ' but they do not have a role. Defaulting to service [Owen]'"/>
                        <do_if value="not this.$FallbackRole">
                          <set_value name="this.$FallbackRole" exact="entityrole.service"/>
                        </do_if>
                        <debug_text text="'Attempting to find replacement NPC with template ' + this.$ReplacementTemplate" chance="@$DebugChance"/>
                        <set_value name="this.$ReplacementNPC" exact="this.$ReplacementRoleObject.roleentity.{this.$ReplacementTemplate}"/>
                        <set_value name="this.$FoundExistingNPC" exact="this.$ReplacementNPC.exists"/>
                        <do_if value="not this.$FoundExistingNPC">
                          <!--We will attempt to create the replacement actor from the this.$ReplacementTemplate and this.$ReplacementRoleObject-->
                          <find_npc_waypoint name="this.$SpawnSlot" object="this.$ReplacementRoleObject.controlroom" tags="tag.npctransport"/>
                          <do_if value="not this.$SpawnSlot">
                            <find_npc_waypoint name="this.$SpawnSlot" object="this.$ReplacementRoleObject" tags="tag.npctransport"/>
                          </do_if>
                          <do_if value="not this.$SpawnSlot">
                            <debug_text text="'Unable to find a spawn slot for the replacement actor on their old role object ' + this.$ReplacementRoleObject + ' ' + this.$ReplacementRoleObject.knownname + ' - trying on their destination object ' + this.$Controlled + ' ' + this.$Controlled.knownname" filter="error"/>
                            <find_npc_waypoint name="this.$SpawnSlot" object="this.$Controlled" tags="tag.npctransport"/>
                          </do_if>
                          <do_if value="this.$SpawnSlot">
                            <create_npc_from_template name="this.$ReplacementNPC" object="this.$ReplacementRoleObject" template="this.$ReplacementTemplate" slot="this.$SpawnSlot" owner="this.$Controlled.owner"/>
                            <debug_text text="'Attempt to instantiate replacement control entity: ' + this.$ReplacementNPC + ' at ' + this.$SpawnSlot" chance="@$DebugChance"/>
                          </do_if>
                          <do_else>
                            <create_npc_from_template name="this.$ReplacementNPC" object="this.$ReplacementRoleObject" template="this.$ReplacementTemplate" owner="this.$Controlled.owner" required="true"/>
                            <debug_text text="'Attempt to instantiate replacement control entity: ' + this.$ReplacementNPC + ' on any free slot on: ' + this.$ReplacementRoleObject + ' ' + this.$ReplacementRoleObject.knownname" chance="@$DebugChance"/>
                          </do_else>

                          <!--Check if the replacement was instanced correctly. They could either be on their old role object or the destination if there were no suitable slots-->
                          <do_if value="this.$ReplacementNPC.exists">
                            <set_entity_traits entity="this.$ReplacementNPC" hidden="true"/>
                            <debug_text text="'Created instance of template ' + this.$ReplacementTemplate + ' - ' + this.$ReplacementNPC + ' at ' + this.$SpawnSlot"/>
                          </do_if>
                          <do_else>
                            <destroy_object object="this.$ReplacementNPC"/>
                            <set_value name="this.$ReplacementNPC" exact="null"/>
                          </do_else>
                        </do_if>
                      </do_if>
                      <do_else>
                        <debug_text text="'NPC template ' + this.$ReplacementTemplate + ' does not exist on object ' + this.$ReplacementRoleObject" chance="@$DebugChance"/>
                      </do_else>
                    </do_if>
                    <do_elseif value="STATE_control_dismissed.$ParamTable.$replacement.isclass.npc">
                      <set_value name="this.$ReplacementNPC" exact="STATE_control_dismissed.$ParamTable.$replacement"/>
                      <set_value name="this.$FoundExistingNPC" exact="true"/>
                      <debug_text text="'Replacement NPC is the existing NPC ' + this.$ReplacementNPC + ' ' + this.$ReplacementNPC.knownname" chance="@$DebugChance"/>
                    </do_elseif>
                    <do_else>
                      <assert value="typeof STATE_control_dismissed.$ParamTable.$replacement == datatype.npctemplate or STATE_control_dismissed.$ParamTable.$replacement.isclass.npc"
                              text="'Provided replacement for ' + $NPC + ' ' + $NPC.knownname + ' is neither a NPC nor a NPC Template. $replacement: ' + $replacement + ' - [Owen]'"/>
                    </do_else>
                  </do_if>
                  <!--Remove ReplacementNPC from their old role object-->
                  <do_if value="this.$ReplacementTemplate and this.$ReplacementRoleObject">
                    <debug_text text="'Successfully instanced or found an instance of a temporary NPC. Remove as a role NPC of its old role object. Instance: ' + @this.$ReplacementNPC + ' Template: ' + this.$ReplacementTemplate + ' Old role object: ' + this.$ReplacementRoleObject + ' ' + this.$ReplacementRoleObject.knownname" chance="@$DebugChance"/>
                    <remove_npc_template object="this.$ReplacementRoleObject" template="this.$ReplacementTemplate"/>
                    <do_if value="this.$ReplacementNPC">
                      <clear_entity_role entity="this.$ReplacementNPC"/>
                    </do_if>
                  </do_if>
                  <do_if value="this.$ReplacementNPC and this.$ReplacementNPC.assignedcontrolled">
                    <debug_text text="'Dismissing the replacement NPC ' + this.$ReplacementNPC + ' ' + this.$ReplacementNPC.knownname + ' from their old object ' + this.$ReplacementNPC.assignedcontrolled + ' ' + this.$ReplacementNPC.assignedcontrolled.knownname" chance="@$DebugChance"/>
                    <dismiss_control_entity actor="this.$ReplacementNPC" object="this.$ReplacementNPC.assignedcontrolled"/>
                  </do_if>
                  <!--Remove $NPC from their control post and reassign them a role if possible-->
                  <dismiss_control_entity actor="$NPC" object="this.$Controlled"/>
                  <do_if value="this.$FallbackRole">
                    <do_if value="this.$Controlled.people.free gt 0">
                      <create_npc_template object="this.$Controlled" entity="$NPC" role="this.$FallbackRole"/>
                      <debug_text text="'Dismissed NPC ' + $NPC + ' ' + $NPC.knownname + ' is now assigned to their old object: ' + this.$Controlled + ' ' + this.$Controlled.knownname + ' as ' + this.$FallbackRole" chance="@$DebugChance"/>
                    </do_if>
                    <do_elseif value="this.$ReplacementRoleObject and this.$ReplacementRoleObject.people.free gt 0">
                      <create_npc_template object="this.$ReplacementRoleObject" entity="$NPC" role="this.$FallbackRole"/>
                      <debug_text text="'Dismissed NPC ' + $NPC + ' ' + $NPC.knownname + ' is now assigned to the old object of their replacement: ' + this.$ReplacementRoleObject + ' ' + this.$ReplacementRoleObject.knownname + ' as ' + this.$FallbackRole" chance="@$DebugChance"/>
                    </do_elseif>
                    <do_else>
                      <assert value="false" text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' was dismissed but has no where to go. [Owen]'"/>
                    </do_else>
                    <set_entity_traits entity="$NPC" temporary="true"/>
                    <set_entity_role entity="$NPC" role="this.$FallbackRole"/>
                  </do_if>

                  <!--Set the replacement NPC to the old control post of $NPC-->
                  <do_if value="this.$ReplacementNPC">
                    <assign_control_entity actor="this.$ReplacementNPC" object="this.$Controlled" post="this.$assignment" init="false"/>
                    <do_if value="this.$assignment == controlpost.shiptrader">
                      <signal_cue_instantly cue="md.NPC_Shiptrader.Base" param="this.$ReplacementNPC"/>
                    </do_if>

                    <!--Transfer inventory wares from $NPC to the replacement NPC.-->
                    <set_value name="this.$NPCInventory" exact="$NPC.inventory.list"/>
                    <do_all exact="this.$NPCInventory.count" counter="$i">
                      <set_value name="this.$InventoryAmount" exact="$NPC.inventory.{this.$NPCInventory.{$i}}.count"/>
                      <debug_text text="'Transfering ' + this.$InventoryAmount + ' of inventory ware: ' + this.$NPCInventory.{$i} + ' from ' + $NPC + ' ' + $NPC.knownname + ' to ' + this.$ReplacementNPC + ' ' + this.$ReplacementNPC.knownname" chance="@$DebugChance"/>
                      <add_inventory entity="this.$ReplacementNPC" ware="this.$NPCInventory.{$i}" exact="this.$InventoryAmount"/>
                      <remove_inventory entity="$NPC" ware="this.$NPCInventory.{$i}" exact="this.$InventoryAmount"/>
                    </do_all>

                    <debug_text text="this.$assignment.name + ' is now ' + this.$ReplacementNPC + ' ' + this.$ReplacementNPC.knownname" chance="@$DebugChance"/>
                    <do_if value="this.$FoundExistingNPC">
                      <signal_objects object="this.$ReplacementNPC" param="'npc_state_reinit'"/>
                      <clear_entity_role_object entity="this.$ReplacementNPC"/>
                    </do_if>
                  </do_if>
                  <do_if value="this.$FallbackRole">
                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </do_if>
                  <do_else>
                    <set_owner object="$NPC" faction="faction.civilian"/>
                    <set_value name="$DespawnSlot" exact="null"/>
                    <do_if value="this.$Controlled.object">
                      <find_npc_waypoint name="$DespawnSlot" object="this.$Controlled.object" tags="tag.npctransport"/>
                    </do_if>
                    <do_if value="$DespawnSlot">
                      <signal_objects object="$NPC" param="'npc_despawn'" param2="table[$slot = $DespawnSlot]"/>
                    </do_if>
                    <do_else>
                      <signal_objects object="$NPC" param="'npc_despawn'"/>
                    </do_else>
                  </do_else>
                </do_if>
                <do_else>
                  <debug_text text="'Dismissing role NPC ' + $NPC + ' ' + $NPC.knownname + ' - Clearing role and owner'" chance="@$DebugChance"/>
                  <set_value name="$roleobject" exact="$NPC.roleobject"/>
                  <do_if value="$roleobject">
                    <remove_npc_template object="$roleobject" template="$NPC.npctemplate"/>
                    <clear_entity_role_object entity="$NPC"/>
                  </do_if>
                  <clear_entity_role entity="$NPC"/>
                  <set_owner object="$NPC" faction="faction.civilian"/>
                  <set_value name="$DespawnSlot" exact="null"/>
                  <do_if value="$roleobject.object">
                    <find_npc_waypoint name="$DespawnSlot" object="$roleobject.object" tags="tag.npctransport"/>
                  </do_if>
                  <do_if value="$DespawnSlot">
                    <signal_objects object="$NPC" param="'npc_despawn'" param2="table[$slot = $DespawnSlot]"/>
                  </do_if>
                  <do_else>
                    <signal_objects object="$NPC" param="'npc_despawn'"/>
                  </do_else>
                </do_else>
                <raise_lua_event name="'info_updatePeople'"/>
              </actions>
            </cue>
            <cue name="EXIT_ai_pilot_control_dismissed" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_ai_pilot">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_ai_pilot" version="2">
              <actions>
                <do_if value="$NPC.controlled">
                  <do_if value="$NPC.controlled == player.controlled">
                    <assert value="$NPC.controlled != player.controlled" text="'Pilot ' + $NPC + ' ' + $NPC.knownname + ' is controlling ' + $NPC.controlled + ' ' + $NPC.controlled.knownname + ' at the same time as the player'"/>
                    <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post" />
                  </do_if>
                  <do_else>
                    <!--NPC is already controlling-->
                    <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post" />
                  </do_else>
                </do_if>
                <do_else>
                  <set_value name="this.$AssignedControlled" exact="$NPC.assignedcontrolled"/>
                  <do_if value="this.$AssignedControlled and this.$AssignedControlled.assignedcontrolentity.{controlpost.aipilot} == $NPC">
                    <!--TODO @Owen check they're on the right object to be busy on-->
                    <do_if value="$NPC.isbusy">
                      <do_if value="$NPC.ishidden">
                        <!--NPC is hidden and busy-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_busy" />
                      </do_if>
                      <do_elseif value="$NPC.roomslot and ($NPC.roomslot.component == this.$AssignedControlled or $NPC.roomslot.component.hascontext.{this.$AssignedControlled}) and $NPC.roomslot.hastag.service">
                        <!--NPC is at a service position and will wait until needed-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_busy" />
                      </do_elseif>
                      <do_else>
                        <!--Have them vacate the pilot position-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post" />
                      </do_else>
                    </do_if>
                    <!--$ship.pilot is either the assigned AI pilot or the currently controlling player-->
                    <do_elseif value="this.$AssignedControlled.assignedpilot == $NPC">
                      <!--NPC is the assigned pilot but not currently in control-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_return_to_post" />
                    </do_elseif>
                  </do_if>
                  <do_else>
                    <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' is no longer a pilot. Re-init.'" chance="@$DebugChance"/>
                    <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                  </do_else>
                </do_else>
              </actions>
              <patch sinceversion="2" state="complete">
                <remove_value name="$NPCSlot"/>
                <remove_value name="$NPCSpeed"/>
              </patch>
            </cue>

            <cue name="EXIT_ai_pilot">
              <conditions>
                <event_cue_signalled cue="parent" />
                <check_value value="@event.param == 'exit'" />
              </conditions>
              <actions>
                <!--<remove_value name="$NPCSlot" />-->
              </actions>
            </cue>

            <!--Transitions-->
            <cue name="TRANSITION_ai_pilot_leave_post" instantiate="true">
              <conditions>
                <event_object_signalled object="$NPC"/>
                <check_any>
                  <check_value value="event.param == 'npc__leave_post'"/>
                  <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post"/>
                </do_if>
                <do_else>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>

            <!--TODO @Owen return to post when a new order is added and player is not controlling or if player is no longer on the ship -->
            <cue name="TRANSITION_ai_pilot_return_to_post" instantiate="true">
              <conditions>
                <event_object_signalled object="$NPC"/>
                <check_any>
                  <check_value value="event.param == 'npc__return_to_post'"/>
                  <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_return_to_post"/>
                </do_if>
                <do_else>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>

            <!--Sub-states-->

            <cue name="STATE_ai_pilot_busy">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="EXIT_ai_pilot_busy" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_ai_pilot_move_to_post">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!-- Enter / Exit actions -->
                <cue name="ENTER_ai_pilot_move_to_post">
                  <actions>
                    <do_if value="$NPC.controlpost != controlpost.aipilot">
                      <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                    </do_if>
                    <do_if value="$NPC.controlled">
                      <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is already controlling ' + $NPC.controlled + ' ' + $NPC.controlled.knownname + ' - No need to move.'" chance="@$DebugChance" />
                      <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post" />
                    </do_if>
                    <do_elseif value="$NPC.assignedcontrolled">
                      <set_value name="$Assigned" exact="$NPC.assignedcontrolled" />

                      <do_if value="$Assigned.pilot and $Assigned.pilot != $NPC">
                        <do_if value="$Assigned.pilot == player.entity">
                          <!--Player is currently piloting this object.-->
                          <debug_text text="'Player is currently piloting ' + $Assigned + ' ' + $Assigned.knownname + ' have the pilot go to standby.'" chance="@$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post" />
                        </do_if>
                        <do_else>
                          <assert value="$Assigned.pilot == player.entity or $Assigned.pilot == $NPC" text="'Current pilot of ship ' + $Assigned + ' ' + $Assigned.knownname + ' is ' + $Assigned.pilot + ' ' + $Assigned.pilot.knownname + ' - Not this NPC ' + $NPC + ' [Owen]'"/>
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_else>
                      </do_if>
                      <do_else>
                        <!--Have the pilot move to the pilot slot-->
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is pilot of ' + $Assigned.knownname + ' ({' + $Assigned + '}) - safe to continue'" chance="@$DebugChance" />
                        <find_npc_slot name="this.$destinationslot" object="$Assigned" post="controlpost.aipilot"/>

                        <set_value name="this.$AwaitingBusySlot" exact="false"/>
                        <do_if value="not this.$destinationslot">
                          <!--Check if the filled slot is simply not just blocked by this NPC-->
                          <find_npc_slot name="this.$potentialdestinationslot" object="$Assigned" post="controlpost.aipilot" excludefilled="false"/>
                          <do_if value="this.$potentialdestinationslot">
                            <do_if value="this.$potentialdestinationslot == $NPC.roomslot">
                              <set_value name="this.$destinationslot" exact="this.$potentialdestinationslot"/>
                            </do_if>
                            <do_else>
                              <set_value name="this.$BlockingEntity" exact="this.$potentialdestinationslot.component.controlposition.{this.$potentialdestinationslot.controlposition}.entity"/>
                              <do_if value="this.$BlockingEntity">
                                <!--Check the blackboard of the blocking entity to see if they're waiting for us-->
                                <do_if value="@this.$BlockingEntity.$BlockingEntity.{1} == $NPC">
                                  <debug_text text="'The pilot room slot is currently engaged by another entity: ' + this.$BlockingEntity + ' but they are waiting for us, so we shall move first.'" chance="@$DebugChance"/>
                                  <clear_actor_roomslot actor="this.$BlockingEntity"/>
                                  <set_value name="this.$destinationslot" exact="this.$potentialdestinationslot"/>
                                </do_if>
                                <do_else>
                                  <debug_text text="'The pilot room slot is currently engaged by another entity: ' + this.$BlockingEntity + ' they must either leave in the next frame or begin getting out of the chair.'" chance="@$DebugChance"/>
                                  <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_await_moving_to_post" />
                                  <set_value name="this.$AwaitingBusySlot" exact="true"/>
                                  <set_value name="$NPC.$BlockingEntity" exact="[this.$BlockingEntity, player.age]"/>
                                </do_else>
                              </do_if>
                              <do_else>
                                <set_value name="this.$destinationslot" exact="this.$potentialdestinationslot"/>
                              </do_else>
                            </do_else>
                          </do_if>
                        </do_if>
                        <do_else>
                          <debug_text text="this.$destinationslot + ' is free '" chance="@$DebugChance"/>
                        </do_else>

                        <assert value="this.$destinationslot or this.$AwaitingBusySlot" text="'No pilot slot found on ' + $Assigned + ' ' + $Assigned.knownname + ' [Owen]'"/>

                        <do_if value="this.$destinationslot">
                          <set_entity_traits entity="$NPC" busy="false" intransit="true" />
                          <!-- hidden="false" -->
                          <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                            <param name="NPC" value="$NPC"/>
                            <param name="DestinationSlot" value="this.$destinationslot"/>
                            <param name="AnimateAtEnd" value="false" comment="The following states will take care of the animations"/>
                            <param name="DebugChance" value="@$DebugChance"/>
                          </run_actions>
                          <do_if value="this.$pathtable">
                            <set_value name="$pathtable" exact="this.$pathtable" />
                            <!-- If a speed was passed into the state machine, use it -->
                            <do_if value="@$NPCSpeed">
                              <set_value name="$pathtable.$speed" exact="$NPCSpeed" />
                            </do_if>
                            <!-- Else, select one at random -->
                            <do_else>
                              <do_if value="$NPC.room.parent.isclass.walkablemodule">
                                <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                              </do_if>
                              <do_else>
                                <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                              </do_else>
                            </do_else>
                            <do_if value="this.$destinationslot.hastag.npc">
                              <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot" />
                            </do_if>
                            <do_else>
                              <clear_actor_roomslot actor="$NPC" />
                            </do_else>
                            <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_moving_to_post" />
                          </do_if>
                          <do_else>
                            <run_actions ref="MoveFailedHandling_ToSlot">
                              <param name="NPC" value="$NPC"/>
                              <param name="DestinationSlot" value="this.$destinationslot"/>
                              <param name="DebugChance" value="@$DebugChance"/>
                            </run_actions>
                            <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post_finished" />
                          </do_else>
                        </do_if>
                        <do_elseif value="not this.$AwaitingBusySlot">
                          <!--No pilot slot found-->
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post" />
                        </do_elseif>
                      </do_else>
                    </do_elseif>
                    <do_else>
                      <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) had no assigned ship to pilot. Reinitialise'" filter="error" />
                      <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_ai_pilot_move_to_post_v2">
                  <conditions>
                    <event_cue_signalled cue="parent"/>
                    <check_value value="@event.param == 'exit'"/>
                  </conditions>
                  <actions>
                    <remove_value name="$NPC.$BlockingEntity" />
                  </actions>
                </cue>

                <!-- Sub-states -->

                <cue name="STATE_ai_pilot_await_moving_to_post">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_ai_pilot_await_moving_to_post">
                      <actions>
                        <set_value name="STATE_ai_pilot_await_moving_to_post.$Controllable" exact="$NPC.assignedcontrolled"/>
                        <do_if value="@STATE_ai_pilot_await_moving_to_post.$Controllable.assignedcontrolentity.{controlpost.aipilot} == $NPC">
                          <find_npc_slot name="STATE_ai_pilot_await_moving_to_post.$Slot" object="STATE_ai_pilot_await_moving_to_post.$Controllable" post="controlpost.aipilot" excludefilled="false"/>
                          <assert value="STATE_ai_pilot_await_moving_to_post.$Slot" text="'Unable to find pilot slot [Owen]'"/>
                          <do_if value="STATE_ai_pilot_await_moving_to_post.$Slot">
                            <set_value name="this.$BlockingEntity" exact="STATE_ai_pilot_await_moving_to_post.$Slot.component.slotactor.{STATE_ai_pilot_await_moving_to_post.$Slot}"/>
                            <do_if value="this.$BlockingEntity">
                              <do_if value="this.$BlockingEntity == $NPC">
                                <assert value="this.$BlockingEntity != $NPC" text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' is in a state waiting for someone to get out of the pilot chair, where that person is themelves. Reinitialising. [Owen]'"/>
                                <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                              </do_if>
                              <do_else>
                                <do_if value="this.$BlockingEntity.isclass.player">
                                  <do_if value="this.$BlockingEntity.controlled == STATE_ai_pilot_await_moving_to_post.$Controllable">
                                    <assert value="this.$BlockingEntity.controlled != STATE_ai_pilot_await_moving_to_post.$Controllable"
                                            text="'Player is still controlling ' + STATE_ai_pilot_await_moving_to_post.$Controllable + ' ' + STATE_ai_pilot_await_moving_to_post.$Controllable.knownname + ' while NPC ' + $NPC + ' ' + $NPC.knownname + ' wants control'"/>
                                  </do_if>
                                  <do_else>
                                    <debug_text text="'Clearing player roomslot for ' + STATE_ai_pilot_await_moving_to_post.$Controllable + ' ' + STATE_ai_pilot_await_moving_to_post.$Controllable.knownname + ' so NPC ' + $NPC + ' ' + $NPC.knownname + ' can take control'" chance="@$DebugChance"/>
                                    <clear_actor_roomslot actor="this.$BlockingEntity"/>
                                  </do_else>
                                </do_if>
                                <do_else>
                                  <do_if value="not this.$BlockingEntity.isintransit and @$NPC.$BlockingEntity.{1} == this.$BlockingEntity and player.age lt @$NPC.$BlockingEntity.{2} + 1s">
                                    <debug_text text="'Giving blocking entity ' + this.$BlockingEntity + ' ' + this.$BlockingEntity.knownname + ' time to begin leaving'" chance="@$DebugChance"/>
                                    <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_await_moving_to_post" />
                                  </do_if>
                                  <do_else>
                                    <do_if value="not this.$BlockingEntity.isintransit">
                                      <assert value="this.$BlockingEntity.isintransit" text="'NPC ' + this.$BlockingEntity + ' ' + this.$BlockingEntity.knownname + ' is blocking the pilot chair for ' + $NPC + ' ' + $NPC.knownname + ' - Forcing reinitialisation [Owen]'"/>
                                      <signal_objects object="this.$BlockingEntity" param="'npc_state_reinit'"/>
                                    </do_if>
                                    <do_if value="STATE_ai_pilot_await_moving_to_post.$Controllable.ischairslot.{STATE_ai_pilot_await_moving_to_post.$Slot}">
                                      <!--allow the transition below to handle waiting for the chair to be free-->
                                    </do_if>
                                    <do_else>
                                      <!--Pilot slot is not a chair slot. Move towards it right away.-->
                                      <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post" />
                                    </do_else>
                                  </do_else>
                                </do_else>
                              </do_else>
                            </do_if>
                            <do_else>
                              <!--No NPC in the chair. Move towards it right away.-->
                              <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post" />
                            </do_else>
                          </do_if>
                          <do_else>
                            <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'$NPC ' + $NPC.knownname + ' ' + $NPC + ' is not assigned as a pilot. Reinitialise'" chance="@$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_ai_pilot_await_moving_to_post" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_ai_pilot_await_moving_to_post_finish" checkinterval="1ms">
                      <conditions>
                        <check_any>
                          <!--Check if the chair has been vacated-->
                          <check_value value="STATE_ai_pilot_await_moving_to_post.$Slot? and not STATE_ai_pilot_await_moving_to_post.$Slot.component.slotactor.{STATE_ai_pilot_await_moving_to_post.$Slot}" />
                          <check_all>
                            <!--Timeout if the chair entity has not left in a suitable amount of time-->
                            <check_value value="STATE_ai_pilot_await_moving_to_post.time + 10s lt player.age"/>
                            <debug_text text="'NPC ' + STATE_ai_pilot_await_moving_to_post.$Slot.component.slotactor.{STATE_ai_pilot_await_moving_to_post.$Slot} + 
                                        ' took too long to leave the chair which ' + $NPC + ' ' + $NPC.knownname + ' is moving to.'" filter="error"/>
                          </check_all>
                        </check_any>
                      </conditions>
                      <actions>
                        <debug_text text="'NPC ' + $NPC.knownname + ' ' + $NPC + ' is now set to move to the chair.'" chance="@$DebugChance" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_ai_pilot_moving_to_post">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_ai_pilot_moving_to_post" ref="PerformPath">
                      <param name="NPC" value="$NPC" />
                      <param name="pathtable" value="$pathtable" />
                      <param name="signalcue" value="TRANSITION_ai_pilot_moving_to_post_finished" />
                      <param name="DebugChance" value="@$DebugChance" />
                    </cue>

                    <cue name="EXIT_ai_pilot_moving_to_post" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_ai_pilot_moving_to_post_finished">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <debug_text text="'PerformPath (pilot_moving_to_post) finished'" chance="@$DebugChance" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post_finished" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_ai_pilot_move_to_post_finished">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <cue name="ENTER_ai_pilot_move_to_post_finished">
                      <actions>
                        <set_entity_traits entity="$NPC" busy="false" intransit="false" hidden="false"/>
                        <initialise_control_entity actor="$NPC"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post" />
                      </actions>
                    </cue>

                    <cue name="EXIT_ai_pilot_move_to_post_finished" ref="EXIT_Empty" />
                  </cues>
                </cue>
              </cues>
            </cue>

            <!--TODO @Owen - Rename?
            STATE_ai_pilot_working may be a better name. The pilot is the current active pilot of the ship and should move to the control post. (TODO Potential to wander around however in special cases.)-->
            <cue name="STATE_ai_pilot_at_post" version="2">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <patch sinceversion="2">
                <do_if value="$NPC.controlled and $NPC.controlled == player.controlled">
                  <debug_text text="'Pilot ' + $NPC + ' ' + $NPC.knownname + ' is controlling ' + $NPC.controlled + ' ' + $NPC.controlled.knownname + ' at the same time as the player. Have them leave the post.'" filter="savegame"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post" />
                </do_if>
              </patch>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_ai_pilot_at_post">
                  <actions>
                    <do_if value="$NPC.controlled">
                      <do_if value="$NPC.isplayerowned and global.$LastPlayerShip? and @global.$LastPlayerShip != $NPC.controlled">
                        <signal_objects object="$NPC.controlled" param="'playerownedship_proceed'"/>
                      </do_if>
                      <do_if value="$NPC.controlled.istemptraffic or not $NPC.roomslot">
                        <!--Optimisation - Pilot is not in an object with a positioned pilot slot, so we put them in a very basic state.-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_invisible" />
                      </do_if>
                      <do_else>
                        <do_if value="$NPC.attention ge attention.nearby">
                          <do_if value="$NPC.assignedcontrolled.parent.isclass.dockingbay and $NPC.assignedcontrolled.parent.dockstate == dockstate.default">
                            <precache_actor_animation_hint actor="$NPC" type="'idle'" slot="$NPC.roomslot"/>
                          </do_if>
                          <do_else>
                            <precache_actor_animation_hint actor="$NPC" type="'busy'" slot="$NPC.roomslot"/>
                          </do_else>
                        </do_if>
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post_default" />
                      </do_else>
                    </do_if>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post" />
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_ai_pilot_at_post" ref="EXIT_Empty"/>

                <!-- Sub-states -->
                <cue name="STATE_ai_pilot_invisible">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="EXIT_ai_pilot_invisible" ref="EXIT_Empty" />
                  </cues>
                </cue>

                <cue name="STATE_ai_pilot_at_post_default">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!--Allow usecases
                    If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                    Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                    <cue name="USECASE_CHECK_ai_pilot_at_post_default" instantiate="true">
                      <conditions>
                        <event_cue_signalled cue="parent"/>
                        <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                      </conditions>
                      <actions>
                        <include_actions ref="Allow_Usecase"/>
                      </actions>
                    </cue>

                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_ai_pilot_at_post_default">
                      <actions>
                        <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' ' + $NPC.attention + ' ENTER_ai_pilot_at_post_default'" chance="@$DebugChance"/>
                        <do_if value="$NPC.controlled and ($NPC.controlled.istemptraffic or not $NPC.roomslot)">
                          <!--Pilot is not in an object with a positioned pilot slot, so we put them in a very basic state.-->
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_invisible" />
                        </do_if>
                        <do_else>
                          <do_if value="$NPC.hasbody">
                            <!-- If the ship is currently docked, pilot / commander is allowed to idle -->
                            <debug_text text="'Checking whether ship is docked: ' + $NPC.knownname + ' ({' + $NPC + '})'" chance="@$DebugChance" />
                            <do_if value="$NPC.assignedcontrolled.parent.isclass.dockingbay and $NPC.assignedcontrolled.parent.dockstate == dockstate.default">
                              <debug_text text="'Ship is docked - NPC can idle'" chance="@$DebugChance" />
                              <set_value name="$AnimationType" exact="'idle'" />
                            </do_if>
                            <do_else>
                              <debug_text text="'Ship is not docked - NPC must look busy'" chance="@$DebugChance" />
                              <set_value name="$AnimationType" exact="'busy'" />
                              <do_if value="$NPC.roomslot.component.ischairslot.{$NPC.roomslot}">
                                <do_if value="($NPC.race == race.paranid)">
                                  <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="activate_chair_steering_par" />
                                </do_if>
                                <do_else>
                                  <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="activate_chair_steering" />
                                </do_else>
                              </do_if>
                              <do_else>
                                <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="activate" />
                              </do_else>
                            </do_else>
                            <debug_text text="'$AnimationType set to ' + $AnimationType" chance="@$DebugChance" />

                            <!-- TODO (@Lorraine): remove behaviour check here when a) all ships use sit_pilot / stand_terminal_forward and b) piloting animations and sequences exist (means they can just use default 'busy') -->
                            <set_value name="$Behaviour" exact="null" />
                            <set_value name="$CurrentSlot" exact="$NPC.roomslot" />

                            <!--TODO @Owen we do not have sequences set up for pilots also using terminals-->
                            <do_if value="$CurrentSlot.hastag.sit_pilot">
                              <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '})' + ' is sitting to pilot'" chance="@$DebugChance" />
                              <set_value name="$Behaviour" exact="'sit_pilot'" />
                            </do_if>
                            <do_elseif value="$CurrentSlot.hastag.stand_terminal_forward">
                              <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '})' + ' is standing to pilot'" chance="@$DebugChance" />
                              <set_value name="$Behaviour" exact="'stand_terminal_captain'" />
                            </do_elseif>

                            <do_if value="not $Behaviour">
                              <do_if value="$CurrentSlot.component.ischairslot.{$CurrentSlot}">
                                <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '})' + ' is sitting down'" chance="@$DebugChance" />
                                <set_value name="$Behaviour" exact="'sit'" />
                              </do_if>
                              <do_else>
                                <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '})' + ' is standing up'" chance="@$DebugChance" />
                                <set_value name="$Behaviour" exact="'stand_terminal_captain'" />
                              </do_else>
                            </do_if>
                            <debug_text text="'$AnimationType ' + $AnimationType + ' $Behaviour ' + $Behaviour" chance="@$DebugChance"/>
                            <start_actor_sequence actor="$NPC" type="$AnimationType" behavior="$Behaviour" transition="true" immediate="true" result="this.$animationstarted" />
                            <do_if value="not this.$animationstarted">
                              <do_if value="$AnimationType" exact="'idle'">
                                <debug_text text="'Unable to start idle animation sequence for ' + $NPC.name + ' ' + $NPC" filter="error" />
                              </do_if>
                              <do_else>
                                <debug_text text="'Unable to start piloting animation sequence for ' + $NPC.name + ' ' + $NPC + ' - behaviour: ' + $Behaviour" filter="error" />
                              </do_else>
                            </do_if>
                            <remove_value name="$AnimationType"/>
                            <remove_value name="$Behaviour"/>
                            <remove_value name="$CurrentSlot"/>
                          </do_if>
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_ai_pilot_at_post_default" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_ai_pilot_at_post_undock" instantiate="true">
                      <conditions>
                        <event_object_signalled object="$NPC"/>
                        <!--TODO @Owen only queue transition if there are no other queued transitions? Otherwise, this may seem too late.-->
                        <check_any>
                          <check_value value="event.param == 'manage_undock'"/>
                          <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                        </check_any>
                      </conditions>
                      <actions>
                        <debug_text text="'UNDOCK TRANSITION NPC ' + $NPC.name + ' ({' + $NPC + '})'" chance="@$DebugChance" />
                        <do_if value="@$DispatchTransitionStateChange">
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post_undock"/>
                        </do_if>
                        <do_else>
                          <debug_text text="'Requesting queued transition to state STATE_ai_pilot_at_post_undock'" chance="@$DebugChance" />
                          <include_actions ref="QueueTransitionRequest"/>
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="TRANSITION_ai_pilot_at_post_dock" instantiate="true">
                      <conditions>
                        <event_object_signalled object="$NPC"/>
                        <!--TODO @Owen only queue transition if there are no other queued transitions? Otherwise, this may seem too late.-->
                        <check_any>
                          <check_value value="event.param == 'manage_dock'"/>
                          <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                        </check_any>
                      </conditions>
                      <actions>
                        <debug_text text="'DOCK TRANSITION NPC ' + $NPC.name + ' ({' + $NPC + '})'" chance="@$DebugChance" />
                        <do_if value="@$DispatchTransitionStateChange">
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post_dock"/>
                        </do_if>
                        <do_else>
                          <debug_text text="'Requesting queued transition to state STATE_ai_pilot_at_post_dock'" chance="@$DebugChance" />
                          <include_actions ref="QueueTransitionRequest"/>
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="TRANSITION_ai_pilot_nearby" instantiate="true">
                      <conditions>
                        <event_object_changed_attention object="$NPC"/>
                        <check_value value="event.param ge attention.nearby and event.param2 lt attention.nearby"/>
                      </conditions>
                      <actions>
                        <debug_text text="'Pilot changed attention to nearby ' + $NPC.name + ' ({' + $NPC + '})'" chance="@$DebugChance" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post_default" />
                      </actions>
                    </cue>

                    <!-- Sub-states -->
                    <cue name="STATE_ai_pilot_at_post_undock">
                      <conditions>
                        <event_cue_signalled />
                        <check_value value="not @event.param" />
                      </conditions>
                      <actions>
                        <include_actions ref="Init_State" />
                      </actions>
                      <cues>
                        <!-- Enter / Exit actions -->
                        <cue name="ENTER_ai_pilot_at_post_undock">
                          <actions>
                            <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is now entering STATE_ai_pilot_at_post_undock'" chance="@$DebugChance" />

                            <do_if value="$NPC.hasbody">
                              <set_value name="$RoomSlot" exact="$NPC.roomslot" />
                              <set_value name="$Tags" exact="$RoomSlot.tags" />

                              <!-- Is the NPC sitting down... -->
                              <do_if value="$RoomSlot.component.ischairslot.{$RoomSlot}">
                                <debug_text text="'$NPC is sat down - focusing on sitting terminals'" chance="@$DebugChance" />

                                <set_value name="$Behaviour" exact="'sit_pilot'" />
                              </do_if>

                              <!-- Or standing up? -->
                              <do_else>
                                <debug_text text="'$NPC is stood up - focusing on standing terminals'" chance="@$DebugChance" />

                                <set_value name="$Behaviour" exact="'stand_terminal_captain'" />
                              </do_else>

                              <!--set_value name="$Behaviour" exact="'sit_terminal_left'" /-->
                              <debug_text text="'Behaviour: ' + $Behaviour" chance="@$DebugChance" />
                              <start_actor_sequence actor="$NPC" type="'busy'" behavior="$Behaviour" transition="true" immediate="true" result="this.$animationstarted" />
                              <do_if value="not this.$animationstarted">
                                <debug_text text="'Unable to start busy animation sequence for ' + $NPC.name + ' ' + $NPC" filter="error" />
                              </do_if>
                              <do_else>
                                <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '}) has started busy animation sequence'" chance="@$DebugChance" />
                                <do_if value="$RoomSlot.component.ischairslot.{$RoomSlot}">
                                  <do_if value="($NPC.race == race.paranid)">
                                    <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="activate_chair_steering_par" />
                                  </do_if>
                                  <do_else>
                                    <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="activate_chair_steering" />
                                  </do_else>
                                </do_if>
                                <do_else>
                                  <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="activate" />
                                </do_else>
                              </do_else>
                            </do_if>
                          </actions>
                        </cue>

                        <cue name="EXIT_ai_pilot_at_post_undock" ref="EXIT_Empty" />
                      </cues>
                    </cue>

                    <cue name="STATE_ai_pilot_at_post_dock">
                      <conditions>
                        <event_cue_signalled />
                        <check_value value="not @event.param" />
                      </conditions>
                      <actions>
                        <include_actions ref="Init_State" />
                      </actions>
                      <cues>
                        <!-- Enter / Exit actions -->
                        <cue name="ENTER_ai_pilot_at_post_dock">
                          <actions>
                            <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is now entering STATE_ai_pilot_at_post_dock'" chance="@$DebugChance" />
                            <do_if value="$NPC.hasbody">
                              <set_value name="$RoomSlot" exact="$NPC.roomslot" />
                              <set_value name="$Tags" exact="$RoomSlot.tags" />
                              <do_if value="$RoomSlot.component.ischairslot.{$RoomSlot}">
                                <debug_text text="'$NPC is sat down'" chance="@$DebugChance" />
                                <set_value name="$Behaviour" exact="'sit'" />
                              </do_if>
                              <do_else>
                                <debug_text text="'$NPC is stood up'" chance="@$DebugChance" />
                                <set_value name="$Behaviour" exact="'stand_terminal_captain'" />
                              </do_else>
                              <debug_text text="'Behaviour: ' + $Behaviour" chance="@$DebugChance" />
                              <start_actor_sequence actor="$NPC" type="'idle'" behavior="$Behaviour" transition="true" immediate="true" result="this.$animationstarted" />
                              <do_if value="not this.$animationstarted">
                                <debug_text text="'Unable to start idle animation sequence for ' + $NPC.name + ' ' + $NPC" filter="error" />
                              </do_if>
                              <do_else>
                                <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '}) has started idle animation sequence'" chance="@$DebugChance" />
                                <do_if value="$RoomSlot.component.ischairslot.{$RoomSlot}">
                                  <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="deactivate_chair_steering" />
                                </do_if>
                                <do_else>
                                  <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="deactivate" />
                                </do_else>
                              </do_else>
                            </do_if>
                          </actions>
                        </cue>

                        <cue name="EXIT_ai_pilot_at_post_dock" ref="EXIT_Empty" />
                      </cues>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <!-- Move to inside at_post? -->
            <cue name="STATE_ai_pilot_leave_post">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_ai_pilot_leave_post">
                  <actions>
                    <set_value name="this.$assignedcontrolled" exact="$NPC.assignedcontrolled"/>
                    <do_if value="this.$assignedcontrolled and this.$assignedcontrolled.assignedcontrolentity.{controlpost.aipilot} == $NPC">
                      <!-- set_value name="$DebugChance" exact="100"/ -->
                      <debug_text text="'Attempting to tell NPC ' + $NPC + ' ' + $NPC.knownname + ' to leave its pilot post'" chance="@$DebugChance"/>
                      <assert value="not @$NPC.controlled.order or $NPC.controlled.order.canplayercancel" text="'NPC pilot told to leave post during a non-cancellable order [Owen]'"/>

                      <set_value name="this.$postslot" exact="this.$assignedcontrolled.controlpostslot.{controlpost.aipilot}"/>
                      <do_if value="this.$postslot.component.ischairslot.{this.$postslot}">
                        <trigger_animation object="this.$postslot.component" group="this.$postslot.group" trigger="deactivate_chair_steering" />
                      </do_if>
                      <do_else>
                        <trigger_animation object="this.$postslot.component" group="this.$postslot.group" trigger="deactivate" />
                      </do_else>

                      <!--find a suitable this.$destinationslot-->
                      <set_value name="this.$destinationslot" exact="null"/>
                      <set_value name="this.$pilotslot" exact="this.$assignedcontrolled.controlpostslot.{controlpost.aipilot}"/>
                      <set_value name="this.$controlroom" exact="this.$assignedcontrolled.controlroom"/>
                      <do_if value="this.$pilotslot">
                        <do_if value="this.$controlroom.slotcontext == this.$controlroom">
                          <!--Control room has its own NPC slots. Try to find a npctransport slot with it-->
                          <find_npc_waypoint name="this.$destinationslot" object="this.$controlroom" tags="tag.npctransport"/>
                        </do_if>
                        <do_else>
                          <!--TODO @Owen look for another tag?-->
                          <find_npc_waypoint name="this.$destinationslots" object="this.$assignedcontrolled" tags="tag.npctransport" multiple="true"/>
                          <do_if value="this.$destinationslots.count">
                            <sort_list list="this.$destinationslots" sortbyvalue="loop.element.distanceto.{this.$pilotslot}" sortdescending="false"/>
                            <set_value name="this.$destinationslot" exact="this.$destinationslots.{1}"/>
                          </do_if>
                        </do_else>
                      </do_if>
                      <do_if value="@this.$destinationslot.distanceto.{this.$pilotslot} gt 20m">
                        <do_if value="this.$controlroom.slotcontext == this.$controlroom">
                          <debug_text text="'Distance to transporter location ' + this.$destinationslot + ' ' + this.$destinationslot.distanceto.{this.$pilotslot} + ' from the pilot slot. Look for a service slot in control room ' + this.$controlroom" chance="@$DebugChance"/>
                          <find_npc_slot name="this.$destinationslots" object="this.$controlroom" tags="tag.service" multiple="true"/>
                        </do_if>
                        <do_else>
                          <debug_text text="'Distance to transporter location ' + this.$destinationslot + ' ' + this.$destinationslot.distanceto.{this.$pilotslot} + ' from the pilot slot. Look for a service slot on object ' + this.$assignedcontrolled" chance="@$DebugChance"/>
                          <find_npc_slot name="this.$destinationslots" object="this.$assignedcontrolled" tags="tag.service" multiple="true"/>
                        </do_else>
                        <do_if value="this.$destinationslots.count">
                          <sort_list list="this.$destinationslots" sortbyvalue="loop.element.distanceto.{this.$pilotslot}" sortdescending="false"/>
                          <set_value name="this.$tempdestinationslot" exact="this.$destinationslots.{1}"/>
                        </do_if>

                        <do_if value="@this.$tempdestinationslot">
                          <set_value name="this.$destinationslot" exact="this.$tempdestinationslot"/>
                          <debug_text text="'selected service slot ' + this.$destinationslot" chance="@$DebugChance"/>
                        </do_if>
                      </do_if>

                      <do_if value="not this.$destinationslot">
                        <find_npc_waypoint name="this.$destinationslot" object="this.$assignedcontrolled" tags="tag.npctransport"/>
                      </do_if>
                      <do_if value="not this.$destinationslot">
                        <include_actions ref="FindLocalDespawnLocation"/>
                      </do_if>

                      <!-- NOTE: The AI pilot is still a control entity. Normally that means that the order script keeps running, but we have to stop it here. -->
                      <!-- When pilot assumes control again (i.e. stops being "busy"), initialise_control_entity will start the script again. -->
                      <abort_scripts entity="$NPC"/>
                      <set_entity_traits entity="$NPC" busy="true"/>
                      <do_if value="this.$destinationslot">
                        <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                          <param name="NPC" value="$NPC"/>
                          <param name="DestinationSlot" value="this.$destinationslot"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>
                        <do_if value="this.$pathtable">
                          <set_value name="$pathtable" exact="this.$pathtable"/>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                          <do_if value="this.$destinationslot.hastag.npc">
                            <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                          </do_if>
                          <do_else>
                            <clear_actor_roomslot actor="$NPC"/>
                          </do_else>
                          <!-- debug_text text="$pathtable"/ -->
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post_moving"/>
                        </do_if>
                        <do_else>
                          <run_actions ref="MoveFailedHandling_ToSlot">
                            <param name="NPC" value="$NPC"/>
                            <param name="DestinationSlot" value="this.$destinationslot"/>
                            <param name="DebugChance" value="@$DebugChance"/>
                          </run_actions>
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post_finished"/>
                        </do_else>
                      </do_if>
                      <do_else>
                        <debug_text text="player.age + ' Unable to find room slot with tag ' + tag.npctransport + ' - NPC will disappear instantly.'" filter="error"/>
                        <set_entity_traits entity="$NPC" hidden="true"/>
                        <add_actor_to_room actor="$NPC" slot="this.$destinationslot"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'Attempting to tell NPC ' + $NPC + ' ' + $NPC.knownname + ' to leave its pilot post but it is not currently an assigned pilot. Reinitialise.'" chance="@$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_ai_pilot_leave_post" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_ai_pilot_leave_post_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_ai_pilot_leave_post_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_ai_pilot_leave_post_moving_finished"/>
                  <param name="DebugChance" value="@$DebugChance"/>
                </cue>

                <cue name="EXIT_ai_pilot_leave_post_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_ai_pilot_leave_post_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_ai_pilot_leave_post_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_ai_pilot_leave_post_finished">
                  <actions>
                    <do_if value="not @$NPC.roomslot.hastag.npc">
                      <!--TODO @Owen what if they're moved into a position in a room, not a transporter?-->
                      <set_entity_traits entity="$NPC" hidden="true"/>
                    </do_if>
                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </actions>
                </cue>

                <cue name="EXIT_ai_pilot_leave_post_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_ai_pilot_return_to_post">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_ai_pilot_return_to_post">
                  <actions>
                    <do_if value="$NPC.assignedcontrolled.pilot">
                      <debug_text text="'Unable to return to control post as ' + $NPC.assignedcontrolled.pilot.knownname + ' ' + $NPC.assignedcontrolled.pilot + ' is there'" chance="@$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_ai_pilot_return_to_post" ref="EXIT_Empty"/>
              </cues>
            </cue>

          </cues>
        </cue>

        <!--TODO @Owen - manager is currently only in the controlroom with nowhere to walk to. Is this enough? Hiring/Firing usecase.-->
        <cue name="STATE_manager" version="3">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <patch sinceversion="2" state="complete">
            <do_if value="not $NPC.controlled">
              <debug_text text="'Manager ' + $NPC + ' ' + $NPC.knownname + ' owned by ' + $NPC.owner + ' did not initialise properly for ' + $NPC.assignedcontrolled + ' ' + $NPC.assignedcontrolled.knownname + ' - Reinitialising'" filter="savegame"/>
              <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
            </do_if>
          </patch>
          <patch sinceversion="3" state="complete">
            <do_if value="$NPC.ishidden">
              <set_entity_traits entity="$NPC" hidden="false"/>
            </do_if>
          </patch>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_manager">
              <actions>
                <do_if value="$NPC.controlled">
                  <!--If activly controlling, the NPC should not be hidden, even if in the invisible control room-->
                  <set_entity_traits entity="$NPC" hidden="false"/>
                </do_if>
                <do_elseif value="$NPC.assignedcontrolled">
                  <do_if value="$NPC.exists">
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                  </do_if>
                  <do_else>
                    <assign_control_entity actor="$NPC" object="$NPC.assignedcontrolled" post="controlpost.manager" transfer="true"/>
                  </do_else>
                </do_elseif>
                <do_else>
                  <assert value="$NPC.assignedcontrolled" text="'Manager control entity ' + $NPC + ' ' + $NPC.knownname + ' does not have an assigned controllable [Owen]'"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_manager" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_shiptrader" version="2">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <patch sinceversion="2" state="complete">
            <do_if value="$NPC.ishidden">
              <set_entity_traits entity="$NPC" hidden="false"/>
            </do_if>
          </patch>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_shiptrader">
              <actions>
                <do_if value="$NPC.controlled">
                  <!--If activly controlling, the NPC should not be hidden, even if in the invisible control room-->
                  <set_entity_traits entity="$NPC" hidden="false"/>
                </do_if>
                <do_elseif value="$NPC.assignedcontrolled">
                  <do_if value="$NPC.exists">
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                  </do_if>
                  <do_else>
                    <assign_control_entity actor="$NPC" object="$NPC.assignedcontrolled" post="controlpost.shiptrader" transfer="true"/>
                  </do_else>
                </do_elseif>
                <do_else>
                  <assert value="$NPC.assignedcontrolled" text="'Shiptrader control entity ' + $NPC + ' ' + $NPC.knownname + ' does not have an assigned controllable [Owen]'"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_shiptrader" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_trainee_individual">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_trainee_individual">
              <actions>
                <do_if value="$NPC.controlled">
                  <!--NPC is already controlling but make sure they're in the right place.-->
                  <add_actor_to_post_location actor="$NPC"/>
                </do_if>
                <do_elseif value="$NPC.assignedcontrolled">
                  <do_if value="$NPC.exists and not $NPC.ishidden">
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                  </do_if>
                  <do_else>
                    <assign_control_entity actor="$NPC" object="$NPC.assignedcontrolled" post="controlpost.trainee_individual" transfer="true"/>
                  </do_else>
                </do_elseif>
                <do_else>
                  <assert value="$NPC.assignedcontrolled" text="'Trainee individual control entity ' + $NPC + ' ' + $NPC.knownname + ' does not have an assigned controllable [Owen]'"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_trainee_individual" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_trainee_group">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_trainee_group">
              <actions>
                <do_if value="not $NPC.roleobject">
                  <do_if value="$NPC.controllable.people.{$NPC.npctemplate}.exists">
                    <set_entity_role_object entity="$NPC" object="$NPC.controllable"/>
                  </do_if>
                </do_if>
                <assert value="$NPC.role" text="'Entity does not have a role in this NPC state'"/>
                <do_if value="$NPC.roleobject.exists">
                  <debug_text text="'$NPC.controllable ' + $NPC.controllable + ' $NPC.roleobject ' + $NPC.roleobject" chance="@$DebugChance"/>
                  <do_if value="$NPC.controllable == $NPC.roleobject">
                    <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
                  </do_if>
                  <do_else>
                    <!--Not on-board object-->
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                  </do_else>
                </do_if>
                <do_else>
                  <assert value="$NPC.roleobject.exists" text="'Entity does not know what object it has a role for. It is on board controllable ' + $NPC.controllable + ' ' + @$NPC.controllable.knownname"/>
                  <destroy_object object="$NPC"/>
                </do_else>

                <set_value name="$NPCSlot" exact="null" comment="This is a valid scenario - it later tells the state machine that it is free to choose a valid slot at random" />
                <set_value name="$NPCSpeed" exact="null" comment="This is a valid scenario - it later tells the state machine that it is free to choose a speed at random" />
              </actions>
            </cue>

            <cue name="EXIT_trainee_group" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <!--Simple state machine to not have the NPC wander around-->
        <cue name="STATE_stay">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->

            <!--<cue name="ENTER_stay"/>-->

            <cue name="EXIT_stay" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_worker">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_worker">
              <actions>
                <do_if value="not $NPC.roleobject">
                  <do_if value="$NPC.controllable.people.{$NPC.npctemplate}.exists">
                    <set_entity_role_object entity="$NPC" object="$NPC.controllable"/>
                  </do_if>
                </do_if>
                <assert value="$NPC.role" text="'Entity does not have a role in this NPC state'"/>
                <do_if value="$NPC.roleobject.exists">
                  <debug_text text="'$NPC.controllable ' + $NPC.controllable + ' $NPC.roleobject ' + $NPC.roleobject" chance="@$DebugChance"/>
                  <do_if value="$NPC.controllable == $NPC.roleobject">
                    <do_if value="$NPC.roomslot and $NPC.roomslot.hastag.{$NPC.role.tag}">
                      <do_if value="([race.argon, race.terran, race.teladi, race.paranid, race.boron].indexof.{$NPC.race} or ($NPC.race == race.split and $NPC.isfemale)) and $NPC.hasbody and not md.$ExcludedWeldingNPCMacros.indexof.{$NPC.macro}">
                        <debug_text text="'ENTER_worker deciding what to do.'" chance="@$DebugChance"/>
                        <do_any>
                          <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post" weight="50" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_welder" weight="5" />
                          <!-- signal_cue_instantly cue="ChangeState" param="STATE_worker_with_tool" weight="1" / -->
                        </do_any>
                      </do_if>
                      <do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post" />
                      </do_else>
                    </do_if>
                    <do_else>
                      <do_if value="$NPC.roleobject.isclass.ship" chance="20">
                        <set_value name="$destinationslot" exact="null"/>
                        <find_npc_slot name="$destinationslots" object="$NPC.roleobject" role="$NPC.role" multiple="true"/>
                        <do_if value="$destinationslots.count">
                          <shuffle_list list="$destinationslots"/>
                          <do_for_each name="$potentialslot" in="$destinationslots">
                            <do_if value="$potentialslot.controlposition">
                              <set_value name="$destinationslot" exact="$potentialslot"/>
                              <break/>
                            </do_if>
                          </do_for_each>
                          <do_if value="not $destinationslot">
                            <set_value name="$destinationslot" exact="$destinationslots.{1}"/>
                          </do_if>
                        </do_if>
                        <remove_value name="$destinationslots"/>
                      </do_if>
                      <do_else>
                        <find_npc_slot name="$destinationslot" object="$NPC.roleobject" role="$NPC.role"/>
                      </do_else>
                      <do_if value="$destinationslot">
                        <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                      </do_if>
                      <do_else>
                        <!--No available room slot, stay for now-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post"/>
                      </do_else>
                    </do_else>
                  </do_if>
                  <do_else>
                    <!--Not on-board object-->
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                  </do_else>
                </do_if>
                <do_else>
                  <assert value="$NPC.roleobject.exists" text="'Entity does not know what object it has a role for. It is on board controllable ' + $NPC.controllable + ' ' + @$NPC.controllable.knownname"/>
                  <destroy_object object="$NPC"/>
                </do_else>

                <set_value name="$NPCSlot" exact="null" comment="This is a valid scenario - it later tells the state machine that it is free to choose a valid slot at random" />
                <set_value name="$NPCSpeed" exact="null" comment="This is a valid scenario - it later tells the state machine that it is free to choose a speed at random" />
              </actions>
            </cue>

            <cue name="EXIT_worker">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <do_if value="$staytime?">
                  <remove_value name="$staytime"/>
                </do_if>
                <remove_value name="$NPCSlot" />
              </actions>
            </cue>

            <!-- Transitions -->

            <cue name="TRANSITION_worker_to_post" instantiate="true">
              <conditions>
                <event_object_signalled object="$NPC"/>
                <check_any>
                  <check_value value="event.param == 'npc_to_post'" comment="event.param2 = table[$NPCSlot = Target slot (optional)]"/>
                  <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post"/>
                  <set_value name="ChangeState.$ParamTable" exact="event.param2.{2}"/>
                </do_if>
                <do_else>
                  <!--TODO @Owen the slot is not reserved at this point. should it be?-->
                  <do_if value="event.param2.$DebugChance?">
                    <set_value name="$DebugChance" exact="event.param2.$DebugChance" />
                  </do_if>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>

                <!--TODO @Owen check if we still need the $ActiveStates safeguard. We don't know what states will be active once this queued state transition happens. Just bulletproof the requested state?-->
                <!--
                <set_value name="$NPCSlot" exact="event.param2.$Slot" />
                <set_value name="$DebugChance" exact="event.param2.$DebugChance" />
                
                <do_if value="not $ActiveStates.indexof.{STATE_worker_at_post}" comment="Only signal entering sub-state if the pilot is not already at their post">
                  <debug_text text="'Signalling service personnel to enter STATE_worker_at_post'" chance="@$DebugChance" />
                  <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post" />
                </do_if>-->
              </actions>
            </cue>

            <cue name="TRANSITION_worker_leave_post" instantiate="true">
              <conditions>
                <event_object_signalled object="$NPC"/>
                <check_any>
                  <check_value value="event.param == 'npc__leave_post'"/>
                  <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <find_npc_slot name="this.$destinationslot" object="$NPC.roleobject" role="$NPC.role"/>
                  <do_if value="this.$destinationslot">
                    <signal_objects object="$NPC" param="'npc_to_post'" param2="table[$NPCSlot = this.$destinationslot]" delay="1ms"/>
                  </do_if>
                  <do_else>
                    <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
                  </do_else>
                </do_if>
                <do_else>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>

            <!--Sub-states-->
            <cue name="STATE_worker_at_post">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_worker_at_post">
                  <actions>
                    <set_value name="$NPCSlot" exact="@parent.$ParamTable.$NPCSlot"/>

                    <set_value name="$NPCAtPost" exact="false" />
                    <!-- Check to see whether NPC is already at their post or whether they need to be moved there -->
                    <do_if value="$NPCSlot">
                      <debug_text text="'A predefined slot has been passed into the state machine - checking to see whether NPC is there or not'" chance="@$DebugChance" />
                      <do_if value="$NPC.roomslot == $NPCSlot and not $NPC.isintransit">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is already in position'" chance="@$DebugChance" />
                        <!-- The NPC is already in position, we do not need to move them and can move straight into STATE_worker_at_post_default -->
                        <set_value name="$NPCAtPost" exact="true" />
                      </do_if>
                      <do_elseif value="$NPC.isintransit">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is already on their way to their post'" chance="@$DebugChance" />
                        <!-- We should leave $NPCAtPost as it is, this will fall into STATE_worker_move_to_post, which can track when the $NPC actually reaches the slot -->
                      </do_elseif>
                      <do_elseif value="$NPC.roomslot != $NPCSlot">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is in wrong position'" chance="@$DebugChance" />
                        <!-- We can leave $NPCAtPost as it is - STATE_worker_move_to_post should still be able to access $NPCSlot, so should be able to put $NPC in correct slot -->
                      </do_elseif>
                    </do_if>
                    <do_else>
                      <debug_text text="'No predefined slot has been passed in - check to see whether NPC is in a valid slot'" chance="@$DebugChance" />
                      <set_value name="$CurrentSlot" exact="$NPC.roomslot" />
                      <debug_text text="'$CurrentSlot set to ' + $CurrentSlot" chance="@$DebugChance" />

                      <do_if value="$CurrentSlot and $CurrentSlot.hastag.{$NPC.role.tag}">
                        <debug_text text="'$CurrentSlot is valid!'" chance="@$DebugChance" />
                        <set_value name="$InValidSlot" exact="true" />
                      </do_if>
                      <do_else>
                        <debug_text text="'$CurrentSlot is not valid!'" chance="@$DebugChance" />
                        <set_value name="$InValidSlot" exact="false" />
                      </do_else>

                      <do_if value="$InValidSlot and not $NPC.isintransit">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is already in position'" chance="@$DebugChance" />
                        <!-- The NPC is already in position; we do not need to move them and can move straight into STATE_worker_at_post_default -->
                        <set_value name="$NPCAtPost" exact="true" />
                      </do_if>
                      <do_elseif value="$NPC.isintransit">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is already on their way to their post'" chance="@$DebugChance" />
                        <!-- We should leave $NPCAtPost as it is - this will fall into STATE_worker_move_to_post, which can track when the $NPC actually reaches the slot -->
                      </do_elseif>
                      <do_elseif value="not $InValidSlot">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is in wrong position'" chance="@$DebugChance" />
                        <!-- We can leave $NPCAtPost as it is - STATE_worker_move_to_post can find a valid position to move them to -->
                      </do_elseif>
                    </do_else>

                    <debug_text text="'Is $NPC at post?: ' + $NPCAtPost" chance="@$DebugChance" />
                    <!-- If they're at their post then they should move to the default sub-state -->
                    <do_if value="$NPCAtPost">
                      <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post_default" />
                    </do_if>
                    <!-- Otherwise, they need to move into position -->
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_worker_move_to_post" />
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_worker_at_post" ref="EXIT_Empty"/>

                <!-- Sub-states -->
                <cue name="STATE_worker_move_to_post">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_worker_move_to_post">
                      <actions>
                        <set_value name="$NPCRole" exact="$NPC.role" />
                        <set_entity_role_object entity="$NPC" object="$NPC.controllable"/>

                        <do_if value="($NPCRole and $NPC.roleobject.exists)">
                          <debug_text text="'$NPC has a role, their roleobject exists and they belong to it - safe to continue'" chance="@$DebugChance" />

                          <set_value name="$Assigned" exact="$NPC.roleobject" />
                          <set_value name="$Assignment" exact="$NPC.role" />
                          <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) - $Assigned: ' + $Assigned + '; $Assignment: ' + $Assignment" chance="@$DebugChance" />

                          <set_value name="this.$destinationslot" exact="null" />
                          <set_value name="$currentroomslot" exact="$NPC.roomslot" />

                          <!-- No pre-defined slot has been passed in - the NPC should be moved to a random valid position -->
                          <do_if value="not $NPCSlot">
                            <do_if value="$currentroomslot and $currentroomslot.hastag.{entityrole.service.tag}">
                              <set_value name="this.$destinationslot" exact="$currentroomslot" />
                            </do_if>
                            <do_else>
                              <find_npc_slot name="this.$destinationslot" object="$Assigned" role="$Assignment" />
                            </do_else>
                          </do_if>

                          <!-- Pre-defined slot has been passed into the state machine - the NPC should be moved to this position -->
                          <do_else>
                            <set_value name="this.$destinationslot" exact="$NPCSlot" />
                          </do_else>

                          <do_if value="not this.$destinationslot">
                            <!--Find a despawn slot on the object for a role entity-->
                            <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
                            <!--TODO @Owen - check if this should instead signal the NPC to despawn to disconnect
                            <signal_objects object="$NPC" param="'npc_despawn'" param2="table[$disconnect = true]"/>-->
                          </do_if>
                          <do_else>
                            <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                              <param name="NPC" value="$NPC"/>
                              <param name="DestinationSlot" value="this.$destinationslot"/>
                              <param name="AnimateAtEnd" value="false" comment="The following states will take care of the animations"/>
                              <param name="DebugChance" value="@$DebugChance"/>
                            </run_actions>
                            <do_if value="this.$pathtable">
                              <set_value name="$pathtable" exact="this.$pathtable" />
                              <!-- If a speed was passed into the state machine, use it -->
                              <do_if value="$NPCSpeed">
                                <set_value name="$pathtable.$speed" exact="$NPCSpeed" />
                              </do_if>
                              <!-- Else, select one at random -->
                              <do_else>
                                <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                              </do_else>
                              <do_if value="this.$destinationslot.hastag.npc">
                                <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot" />
                              </do_if>
                              <do_else>
                                <clear_actor_roomslot actor="$NPC" />
                              </do_else>
                              <signal_cue_instantly cue="ChangeState" param="STATE_worker_moving_to_post" />
                            </do_if>
                            <do_else>
                              <run_actions ref="MoveFailedHandling_ToSlot">
                                <param name="NPC" value="$NPC"/>
                                <param name="DestinationSlot" value="this.$destinationslot"/>
                                <param name="DebugChance" value="@$DebugChance"/>
                              </run_actions>
                              <signal_cue_instantly cue="ChangeState" param="STATE_worker_move_to_post_finished" />
                            </do_else>
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is in ENTER_worker_move_to_post when something is wrong. $NPCRole: ' + $NPCRole + '; $NPC.roleobject.exists: ' + $NPC.roleobject.exists" filter="error" />
                          <destroy_object object="$NPC" />
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_worker_move_to_post" ref="EXIT_Empty" />

                    <!-- Sub-states -->
                    <cue name="STATE_worker_moving_to_post">
                      <conditions>
                        <event_cue_signalled />
                        <check_value value="not @event.param" />
                      </conditions>
                      <actions>
                        <include_actions ref="Init_State" />
                      </actions>
                      <cues>
                        <!-- Enter / Exit actions -->
                        <cue name="ENTER_worker_moving_to_post" ref="PerformPath">
                          <param name="NPC" value="$NPC" />
                          <param name="pathtable" value="$pathtable" />
                          <param name="signalcue" value="TRANSITION_worker_moving_to_post_finished" />
                          <param name="DebugChance" value="@$DebugChance" />
                        </cue>

                        <cue name="EXIT_worker_moving_to_post" ref="EXIT_Empty" />

                        <!-- Transitions -->
                        <cue name="TRANSITION_worker_moving_to_post_finished">
                          <conditions>
                            <event_cue_signalled />
                          </conditions>
                          <actions>
                            <signal_cue_instantly cue="ChangeState" param="STATE_worker_move_to_post_finished" />
                          </actions>
                        </cue>
                      </cues>
                    </cue>

                    <cue name="STATE_worker_move_to_post_finished">
                      <conditions>
                        <event_cue_signalled />
                        <check_value value="not @event.param" />
                      </conditions>
                      <actions>
                        <include_actions ref="Init_State" />
                      </actions>
                      <cues>
                        <cue name="ENTER_worker_move_to_post_finished">
                          <actions>
                            <set_entity_traits entity="$NPC" busy="false" intransit="false" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post_default" />
                          </actions>
                        </cue>

                        <cue name="EXIT_worker_move_to_post_finished" ref="EXIT_Empty" />
                      </cues>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_worker_at_post_default">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!--Allow usecases
                    If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                    Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                    <cue name="USECASE_CHECK_worker_at_post_default" instantiate="true">
                      <conditions>
                        <event_cue_signalled cue="parent"/>
                        <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                      </conditions>
                      <actions>
                        <include_actions ref="Allow_Usecase"/>
                      </actions>
                    </cue>

                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_worker_at_post_default">
                      <actions>
                        <do_if value="not $NPC.hasbody">
                          <set_value name="$StayTime" min="1min" max="2min" />
                        </do_if>
                        <do_else>
                          <set_value name="$RoomslotTags" exact="$NPC.roomslot.tags"/>
                          <do_if value="$RoomslotTags.indexof.{tag.stand}">
                            <set_value name="$StayTime" min="1min" max="2min" />
                          </do_if>
                          <do_else>
                            <set_value name="$StayTime" min="3min" max="5min" />
                          </do_else>
                          <set_value name="$SlotFlag" exact="0"/>
                          <do_if value="$RoomslotTags.indexof.{tag.sit_terminal_forward}">
                            <set_value name="$SlotFlag" operation="add" exact="1"/>
                          </do_if>
                          <do_if value="$RoomslotTags.indexof.{tag.sit_terminal_left}">
                            <set_value name="$SlotFlag" operation="add" exact="2"/>
                          </do_if>
                          <do_if value="$RoomslotTags.indexof.{tag.sit_terminal_right}">
                            <set_value name="$SlotFlag" operation="add" exact="4"/>
                          </do_if>
                          <!--TODO @Owen other worker busy behaviours for different terminal tags-->

                          <!--Get the correct behaviour based on the tags of the roomslot-->
                          <do_if value="md.NPC_State_Machines.TerminalFlagHelper.$Table.{$SlotFlag}?">
                            <debug_text text="'Slotflag ' + $SlotFlag + ' - selected behaviour ' + md.NPC_State_Machines.TerminalFlagHelper.$Table.{$SlotFlag}" chance="@$DebugChance"/>
                            <start_actor_sequence actor="$NPC" type="'busy'" behavior="md.NPC_State_Machines.TerminalFlagHelper.$Table.{$SlotFlag}" transition="true" immediate="true" />
                          </do_if>
                          <do_elseif value="$RoomslotTags.indexof.{tag.stand_terminal_forward}">
                            <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="activate" />
                            <start_actor_sequence actor="$NPC" type="'busy'" behavior="'stand_terminal_forward'" transition="true" immediate="true" />
                          </do_elseif>
                        </do_else>
                        <signal_objects object="$NPC" param="'TRANSITION_worker_at_post_wander'" param2="parent" delay="$StayTime" />
                        <remove_value name="$StayTime"/>
                        <remove_value name="$RoomslotTags"/>
                        <remove_value name="$SlotFlag"/>
                      </actions>
                    </cue>

                    <cue name="EXIT_worker_at_post_default_v2">
                      <conditions>
                        <event_cue_signalled cue="parent"/>
                        <check_value value="@event.param == 'exit'"/>
                      </conditions>
                      <actions>
                        <do_if value="$NPC.hasbody">
                          <do_if value="@$NPC.roomslot.tags.indexof.{tag.stand_terminal_forward}">
                            <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="deactivate" />
                          </do_if>
                        </do_if>
                      </actions>
                    </cue>
                    <!-- Transitions -->
                    <cue name="TRANSITION_worker_at_post_leave" instantiate="true">
                      <conditions>
                        <event_object_signalled object="$NPC"/>
                        <check_any>
                          <check_value value="event.param == 'worker_at_post_leave'"/>
                          <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                        </check_any>
                      </conditions>
                      <actions>
                        <do_if value="@$DispatchTransitionStateChange">
                          <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                        </do_if>
                        <do_else>
                          <include_actions ref="QueueTransitionRequest"/>
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="TRANSITION_worker_at_post_wander" instantiate="true">
                      <conditions>
                        <event_object_signalled object="$NPC" param="'TRANSITION_worker_at_post_wander'"/>
                        <check_value value="event.param2.exists" comment="Transition requester"/>
                      </conditions>
                      <actions>
                        <include_actions ref="Validate_Usecase_Reservation"/>
                        <do_if value="@$UsecaseCue.exists">
                          <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post_default" />
                        </do_if>
                        <do_else>
                          <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="TRANSITION_worker_at_post_nearby" instantiate="true">
                      <conditions>
                        <event_object_changed_attention object="$NPC"/>
                        <check_value value="event.param ge attention.nearby and event.param2 lt attention.nearby"/>
                      </conditions>
                      <actions>
                        <debug_text text="'Worker changed attention to nearby ' + $NPC.name + ' ({' + $NPC + '})'" chance="@$DebugChance" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post_default" />
                      </actions>
                    </cue>

                    <!-- TODO @Owen: Define transition to docking substate?
                    Do not use following cuenames again:
                    TRANSITION_worker_at_post_dock
                    STATE_worker_at_post_dock
                    ENTER_worker_at_post_dock
                    EXIT_worker_at_post_dock-->
                    <!--<cue name="TRANSITION_worker_at_post_dock">
                      <conditions>
                        <event_object_signalled object="$NPC" param="'manage_dock'" />
                      </conditions>
                      <actions>
                        
                      </actions>
                    </cue>-->
                  </cues>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_worker_with_tool">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!--Allow usecases
                If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                <cue name="USECASE_CHECK_worker_with_tool" instantiate="true">
                  <conditions>
                    <event_cue_signalled cue="parent"/>
                    <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                  </conditions>
                  <actions>
                    <do_if value="$ToolInHand">
                      <include_actions ref="Disallow_Usecase"/>
                    </do_if>
                    <do_else>
                      <include_actions ref="Allow_Usecase"/>
                    </do_else>
                  </actions>
                </cue>

                <!-- Enter / Exit actions -->
                <cue name="ENTER_worker_with_tool">
                  <actions>
                    <set_value name="$DestinationSlot" exact="null" />
                    <!-- Select which type of tool the NPC should use -->
                    <do_any>
                      <!-- @Lorraine: Do-any is there because there will be other types of tools later -->
                      <set_value name="$ToolType" exact="'TwoHand'" />
                      <set_value name="$ToolType" exact="'OneHand'" />
                    </do_any>
                    <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) will pick up a tool with type ' + $ToolType" chance="@$DebugChance" />
                    <set_value name="$ToolInHand" exact="false" />

                    <signal_cue_instantly cue="ChangeState" param="STATE_worker_find_tool" />
                  </actions>
                </cue>

                <cue name="EXIT_worker_with_tool">
                  <conditions>
                    <event_cue_signalled cue="parent" />
                    <check_value value="@event.param == 'exit'" />
                  </conditions>
                  <actions>
                    <remove_value name="$ToolType" />
                    <remove_value name="$ToolInHand" />
                    <remove_value name="$DestinationSlot" />
                  </actions>
                </cue>

                <!-- Sub-states -->
                <cue name="STATE_worker_find_tool">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_worker_find_tool">
                      <actions>
                        <do_if value="$NPC.walkablemodule">
                          <find_npc_waypoint name="this.$Waypoints" object="$NPC.walkablemodule" tags="tag.pickup_hole" multiple="true" />
                          <remove_from_list name="this.$Waypoints" exact="$DestinationSlot"/>
                          <do_if value="this.$Waypoints.count">
                            <set_value name="$DestinationSlot" list="this.$Waypoints" />
                          </do_if>
                        </do_if>

                        <do_if value="$DestinationSlot">
                          <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                            <param name="NPC" value="$NPC"/>
                            <param name="DestinationSlot" value="$DestinationSlot"/>
                            <param name="DebugChance" value="@$DebugChance"/>
                          </run_actions>
                          <do_if value="this.$pathtable">
                            <set_value name="$pathtable" exact="this.$pathtable" />
                            <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_worker_move_to_tool" />
                          </do_if>
                          <do_else>
                            <run_actions ref="MoveFailedHandling_ToSlot">
                              <param name="NPC" value="$NPC"/>
                              <param name="DestinationSlot" value="this.$destinationslot"/>
                              <param name="DebugChance" value="@$DebugChance"/>
                            </run_actions>
                            <signal_cue_instantly cue="ChangeState" param="STATE_worker_tool_action" />
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'Unable to find a pickup slot'" chance="@$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_worker_find_tool" ref="EXIT_Empty" />
                  </cues>
                </cue>

                <cue name="STATE_worker_move_to_tool">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!--Allow usecases
                    If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                    Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                    <cue name="USECASE_CHECK_worker_move_to_tool" instantiate="true">
                      <conditions>
                        <event_cue_signalled cue="parent"/>
                        <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                      </conditions>
                      <actions>
                        <do_if value="$ToolInHand">
                          <include_actions ref="Disallow_Usecase"/>
                        </do_if>
                        <do_else>
                          <include_actions ref="Allow_Usecase"/>
                        </do_else>
                      </actions>
                    </cue>

                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_worker_move_to_tool" ref="PerformPath">
                      <param name="NPC" value="$NPC" />
                      <param name="pathtable" value="$pathtable" />
                      <param name="signalcue" value="TRANSITION_worker_tool_action" />
                      <param name="DebugChance" value="@$DebugChance" />
                    </cue>

                    <cue name="EXIT_worker_move_to_tool" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_worker_tool_action">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_worker_tool_action" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_worker_tool_action">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_worker_tool_action">
                      <actions>
                        <do_if value="not $ToolInHand">
                          <do_any>
                            <set_value name="$AnimationType" exact="'tool_quickpickup_ground'" weight="70" />
                            <set_value name="$AnimationType" exact="'tool_pickup_ground'" weight="30" />
                          </do_any>
                        </do_if>
                        <do_elseif value="$ToolInHand">
                          <set_value name="$AnimationType" exact="'tool_drop_ground'" />
                        </do_elseif>
                        <debug_text text="'$AnimationType for tool interaction set to ' + $AnimationType" chance="@$DebugChance" />

                        <trigger_animation object="$NPC.room" group="'groundhatch'" trigger="activate" />

                        <start_actor_sequence actor="$NPC" type="$AnimationType" transition="true" immediate="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <debug_text text="'Unable to start ' + $AnimationType + ' animation sequence for ' + $NPC.name + ' ({' + $NPC + '})'"  filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                      </actions>
                    </cue>

                    <!--TODO @Owen stop animation?-->
                    <cue name="EXIT_worker_tool_action" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_worker_picked_up_tool">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'tran_stand_toolcrouch_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is picking up a tool'" chance="@$DebugChance" />
                        <!-- TODO @Lorraine: The way this is currently set up means that if the NPC stops crouched down to search for the tool before picking it up, it
                             appears in their hand before they are done searching. This is not easily solved by separating out the sequences for searching and non-searching,
                             more likely, here we have to make the decision to search or not, have an optional sequence for searching and wait for that to be fired if searching
                             was selected - or something along these lines -->
                        <do_if value="$ToolType" exact="'OneHand'">
                          <set_actor_tool actor="$NPC" name="'tool1hand'" />
                        </do_if>
                        <do_elseif value="$ToolType" exact="'TwoHand'">
                          <set_actor_tool actor="$NPC" name="'tool2hand'" />
                        </do_elseif>
                        <set_value name="$ToolInHand" exact="true" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="@$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_worker_dropped_tool">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'tran_toolstand_toolcrouch_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is dropping a tool'" chance="@$DebugChance" />
                        <clear_actor_tool actor="$NPC" />
                        <set_value name="$ToolInHand" exact="false" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="@$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_worker_tool_action_finished">
                      <conditions>
                        <check_any>
                          <event_character_animation_finished object="$NPC" id="'tran_toolcrouch_toolstand_01'" />
                          <event_character_animation_finished object="$NPC" id="'tran_toolcrouch_stand_01'" />
                        </check_any>
                      </conditions>
                      <actions>
                        <trigger_animation object="$NPC.room" group="'groundhatch'" trigger="deactivate" />

                        <do_if value="not $ToolInHand">
                          <debug_text text="'NPC does not have tool in hand - they can either reinitialise or go to find a tool'" chance="@$DebugChance" />

                          <do_any>
                            <do_all weight="60">
                              <debug_text text="'NPC will reinitialise'" chance="@$DebugChance" />
                              <signal_cue_instantly cue="ChangeState" param="STATE_init" weight="60" />
                            </do_all>
                            <do_all weight="40">
                              <debug_text text="'NPC will pick up another tool'" chance="@$DebugChance" />
                              <signal_cue_instantly cue="ChangeState" param="STATE_worker_find_tool" weight="40" />
                            </do_all>
                          </do_any>
                        </do_if>
                        <do_else>
                          <debug_text text="'NPC has tool in hand, they should go to put the tool down'" chance="@$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_worker_find_tool" />
                        </do_else>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_move_to_assignment">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <!--TODO @Owen - broken case. Pilot being told to work as service. Doesn't get up.-->
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_move_to_assignment">
              <actions>
                <!--TODO @Owen check if they are in a conversation-->
                <do_if value="$NPC.controlpost">
                  <set_value name="$assigned" exact="$NPC.assignedcontrolled"/>
                  <debug_text text="player.age + ' assigned ' + $assigned" chance="@$DebugChance"/>
                  <do_if value="$assigned">
                    <do_if value="$assigned == $NPC.controlled">
                      <!--Find correct state via the initial handler-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_find"/>
                    </do_else>
                  </do_if>
                  <do_else>
                    <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                  </do_else>
                  <remove_value name="$assigned"/>
                </do_if>
                <do_elseif value="$NPC.role">
                  <do_if value="$NPC.controllable.people.{$NPC.npctemplate}.exists">
                    <set_entity_role_object entity="$NPC" object="$NPC.controllable"/>
                  </do_if>
                  <do_if value="$NPC.roleobject.exists">
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_find"/>
                  </do_if>
                  <do_else>
                    <assert value="$NPC.roleobject.exists" text="'entity ' + $NPC + ' ' + $NPC.knownname + ' has role ' + $NPC.role + ' but no assigned object. killing'"/>
                    <destroy_object object="$NPC"/>
                  </do_else>
                </do_elseif>
              </actions>
            </cue>

            <cue name="EXIT_move_to_assignment" ref="EXIT_Empty"/>

            <!--Sub-states-->

            <cue name="STATE_move_to_assignment_find">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_move_to_assignment_find">
                  <actions>
                    <do_if value="$NPC.isbusy">
                      <!--TODO @Owen check if entity is already in the place they should be 'busy' in. Should they walk to the cabin and 'hide'-->
                      <debug_text text="player.age + ' busy'" chance="@$DebugChance"/>
                      <!--<signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_find"/>-->
                    </do_if>
                    <do_elseif value="$NPC.controlled">
                      <!--NPC is already controlling-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_elseif>
                    <do_elseif value="$NPC.controlpost == controlpost.aipilot">
                      <!--TODO @Owen this case can happen after a NPC has been hired while this state was queued by a transition request. Another transition request to re-init is probably pending from the hire request.-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_elseif>
                    <do_else>
                      <set_value name="$assigned" exact="null"/>
                      <do_if value="$NPC.controlpost">
                        <set_value name="$assigned" exact="$NPC.assignedcontrolled"/>
                        <set_value name="$assignment" exact="$NPC.controlpost"/>
                      </do_if>
                      <do_elseif value="$NPC.role">
                        <set_value name="$assigned" exact="$NPC.roleobject"/>
                        <set_value name="$assignment" exact="$NPC.role"/>
                      </do_elseif>
                      <do_else>
                        <!--TODO @Owen no assignment?-->
                      </do_else>

                      <debug_text text="player.age + ' assigned ' + $assigned + ' ' + $assigned.knownname + ' as ' + $assignment" chance="@$DebugChance"/>
                      <do_if value="$assigned.exists">
                        <set_value name="this.$destinationslot" exact="null"/>
                        <set_value name="$nextstate" exact="null"/>
                        <set_value name="$currentroomslot" exact="$NPC.roomslot"/>
                        <!--check if at or en-route to a suitable location-->
                        <do_if value="$currentroomslot and ($currentroomslot.component == $assigned or (not $currentroomslot.component.isclass.object and $currentroomslot.component.object == $assigned))">
                          <!--Only controlpost entities or those in-transit should look at their current room slot. Role NPCs should try to find new ones (unless there is no other slot available).-->
                          <do_if value="typeof $assignment == datatype.controlpost">
                            <!--while both controlpost and entityrole have the script property .tag, let's not assume that here in case that changes-->
                            <do_if value="$currentroomslot.hastag.{$assignment.tag}">
                              <set_value name="this.$destinationslot" exact="$currentroomslot"/>
                            </do_if>
                          </do_if>
                          <do_elseif value="typeof $assignment == datatype.entityrole">
                            <do_if value="$NPC.isintransit and $currentroomslot.hastag.{$assignment.tag}">
                              <set_value name="this.$destinationslot" exact="$currentroomslot"/>
                            </do_if>
                            <do_else>
                              <find_npc_slot name="this.$destinationslot" object="$assigned" role="$assignment"/>
                              <do_if value="not this.$destinationslot and not $NPC.isintransit">
                                <!--No other slot for this role entity to move to. Stay at current location-->
                                <set_value name="this.$destinationslot" exact="$currentroomslot"/>
                              </do_if>
                            </do_else>
                          </do_elseif>
                        </do_if>

                        <!--if $currentroomslot is not suitable, search for a new one-->
                        <do_if value="not this.$destinationslot">
                          <do_if value="typeof $assignment == datatype.controlpost">
                            <!--If assignment was a controlpost, the above check for $NPC.controlled would have caught if it was already at a suitable location-->
                            <debug_text text="'Looking for control post slots'" chance="@$DebugChance"/>
                            <find_npc_slot name="this.$destinationslot" object="$assigned" post="$assignment"/>
                            <do_if value="not this.$destinationslot">
                              <do_if value="$assignment == controlpost.manager">
                                <find_room name="$managersoffice" roomtype="roomtype.manager" object="$assigned"/>
                                <debug_text text="'Looking for slots in manager room'" chance="@$DebugChance"/>
                                <do_if value="$managersoffice">
                                  <find_npc_slot name="this.$destinationslot" object="$managersoffice" tags="tag.control"/>
                                  <do_if value="not this.$destinationslot">
                                    <find_npc_slot name="this.$destinationslot" object="$managersoffice"/>
                                  </do_if>
                                </do_if>
                              </do_if>
                              <do_elseif value="$assignment == controlpost.shiptrader">
                                <!--TODO @Owen, using the tag here is a bit of a hack as using 'post' will not find slots on corners-->
                                <find_npc_slot name="this.$destinationslot" object="$assigned" tags="controlpost.shiptrader.tag"/>
                              </do_elseif>
                              <do_elseif value="$assignment == controlpost.trainee_individual">
                                <!--Have the NPC move to a despawn point and reinitialise-->
                                <signal_objects object="$NPC" param="'npc_despawn'" param2="table[$reinit = true]"/>
                              </do_elseif>
                              <do_if value="not this.$destinationslot and $assigned.isclass.station">
                                <debug_text text="'Attempting to find virtual waypoint on station'" chance="@$DebugChance"/>
                                <find_npc_waypoint name="this.$destinationslot" object="$assigned" tags="tag.npctransport"/>
                              </do_if>
                              <do_if value="not this.$destinationslot">
                                <!--No slots could be found. Simply finish so it can be assigned-->
                                <debug_text text="'No slots could be found. Simply finish so it can be assigned'" chance="@$DebugChance"/>
                                <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_finished"/>
                              </do_if>
                            </do_if>
                          </do_if>
                          <do_elseif value="typeof $assignment == datatype.entityrole">
                            <find_npc_slot name="this.$destinationslot" object="$assigned" role="$assignment"/>
                            <do_if value="not this.$destinationslot">
                              <!--TODO @Owen better rules for wandering role NPCs-->
                              <!--Find random free NPC slot-->
                              <do_if value="$assignment != entityrole.trainee_group">
                                <find_npc_slot name="this.$destinationslot" object="$assigned" tags="tag.npc_generic"/>
                              </do_if>
                            </do_if>
                          </do_elseif>
                        </do_if>

                        <do_if value="not this.$destinationslot and typeof $assignment == datatype.entityrole">
                          <!--Find a despawn slot on the object for a role entity-->
                          <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
                        </do_if>

                        <!--Evaluate this.$destinationslot-->
                        <do_elseif value="not this.$destinationslot">
                          <!--Unable to find slot. Do nothing-->
                          <debug_text text="player.age + ' Unable to find slot. Waiting a while before trying again.'" chance="@$DebugChance"/>
                        </do_elseif>
                        <do_elseif value="this.$destinationslot == $currentroomslot and not $NPC.isintransit">
                          <!--Current roomslot is fine and NPC is not in transit. Do nothing-->
                          <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_finished"/>
                        </do_elseif>
                        <do_else>
                          <!--Go to this.$destinationslot-->
                          <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                            <param name="NPC" value="$NPC"/>
                            <param name="DestinationSlot" value="this.$destinationslot"/>
                            <param name="AnimateAtEnd" value="false" comment="The following states will take care of the animations"/>
                            <param name="DebugChance" value="@$DebugChance"/>
                          </run_actions>
                          <do_if value="this.$pathtable">
                            <set_value name="$pathtable" exact="this.$pathtable"/>
                            <do_if value="$NPC.distanceto.{this.$destinationslot} gt 200m">
                              <set_value name="$pathtable.$speed" exact="$NPC.runspeed"/>
                            </do_if>
                            <do_elseif value="$NPC.room.parent.isclass.walkablemodule">
                              <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                            </do_elseif>
                            <do_else>
                              <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                            </do_else>
                            <do_if value="this.$destinationslot.hastag.npc">
                              <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                            </do_if>
                            <do_else>
                              <clear_actor_roomslot actor="$NPC"/>
                            </do_else>
                            <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_moving"/>
                          </do_if>
                          <do_else>
                            <run_actions ref="MoveFailedHandling_ToSlot">
                              <param name="NPC" value="$NPC"/>
                              <param name="DestinationSlot" value="this.$destinationslot"/>
                              <param name="DebugChance" value="@$DebugChance"/>
                            </run_actions>
                            <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_finished"/>
                          </do_else>
                        </do_else>
                      </do_if>
                    </do_else>
                  </actions>
                  <cues>
                    <!--If there was no state change, no suitable destinationslot was found. Wait a little while and retry-->
                    <cue name="ENTER_HELPER_move_to_assignment_find_reset">
                      <delay exact="1s"/>
                      <actions>
                        <reset_cue cue="ENTER_move_to_assignment_find"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="EXIT_move_to_assignment_find" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_move_to_assignment_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Allow usecases
                If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                <cue name="USECASE_CHECK_move_to_assignment_moving" instantiate="true">
                  <conditions>
                    <event_cue_signalled cue="parent"/>
                    <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                  </conditions>
                  <actions>
                    <!--Only allow usecase interrupts for NPCs which are not control entities moving to their controlling positions-->
                    <do_if value="$NPC.controlpost">
                      <include_actions ref="Disallow_Usecase"/>
                    </do_if>
                    <do_else>
                      <include_actions ref="Allow_Usecase"/>
                    </do_else>
                  </actions>
                </cue>

                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_move_to_assignment_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_move_to_assignment_moving_finished"/>
                  <param name="DebugChance" value="@$DebugChance"/>
                </cue>

                <cue name="EXIT_move_to_assignment_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_move_to_assignment_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_move_to_assignment_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_move_to_assignment_finished">
                  <actions>
                    <set_entity_traits entity="$NPC" busy="false" intransit="false"/>
                    <do_if value="$NPC.assignedcontrolled">
                      <set_value name="$controlslot" exact="$NPC.assignedcontrolled.controlpostslot.{$NPC.controlpost}"/>
                      <do_if value="not $controlslot and $NPC.controlpost == controlpost.manager and $NPC.roomslot and $NPC.container == $NPC.assignedcontrolled and $NPC.assignedcontrolled.attention ge attention.nearby">
                        <!--Manager can be allowed to be at a position outside of the control room, but only allow this if they are on the controllable. Otherwise warp them to the control room for safety.-->
                        <debug_text text="'Manager ' + $NPC + ' ' + $NPC.knownname + ' is not in the controlroom but is onboard the nearby station. State machine will allow this.'" chance="@$DebugChance"/>
                      </do_if>
                      <do_elseif value="$controlslot and $NPC.roomslot != $controlslot">
                        <assert value="false" text="'Control entity ' + $NPC + ' ' + $NPC.knownname + ' finished moving but not to their control position. Attempting to fix by adding them to their control location [Owen]'"/>
                        <add_actor_to_post_location actor="$NPC"/>
                      </do_elseif>
                      <do_elseif value="not $NPC.controlled">
                        <assert value="$NPC.controlled" text="'Control entity ' + $NPC + ' ' + $NPC.knownname + ' is not currently controlling. Attempting to fix by re-adding them to their control location [Owen]'"/>
                        <add_actor_to_post_location actor="$NPC"/>
                      </do_elseif>
                      <do_elseif value="$NPC.container != $NPC.assignedcontrolled">
                        <assert value="$NPC.container == $NPC.assignedcontrolled" text="'Control entity ' + $NPC + ' ' + $NPC.knownname + ' is not inside their assigned controllable. Attempting to fix by re-adding them to their control location [Owen]'"/>
                        <add_actor_to_post_location actor="$NPC"/>
                      </do_elseif>

                      <initialise_control_entity actor="$NPC"/>
                    </do_if>

                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </actions>
                </cue>

                <cue name="EXIT_move_to_assignment_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_pickup">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_pickup">
              <actions>
                <!-- set_value name="$DebugChance" exact="100"/ -->
                <set_value name="$PickupDone" exact="false"/>
                <signal_cue_instantly cue="ChangeState" param="STATE_pickup_find"/>
              </actions>
            </cue>

            <cue name="EXIT_pickup">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <remove_value name="$PickupDone"/>
              </actions>
            </cue>

            <!--Sub-states-->
            <cue name="STATE_pickup_find">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_pickup_find">
                  <actions>
                    <find_npc_waypoint name="this.$destinationslot" object="$NPC.walkablemodule" tags="tag.pickup_hole"/>

                    <do_if value="this.$destinationslot">
                      <!--Go to this.$destinationslot-->
                      <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                        <param name="NPC" value="$NPC"/>
                        <param name="DestinationSlot" value="this.$destinationslot"/>
                        <param name="DebugChance" value="@$DebugChance"/>
                      </run_actions>
                      <do_if value="this.$pathtable">
                        <set_value name="$pathtable" exact="this.$pathtable"/>
                        <do_if value="$NPC.room.parent.isclass.walkablemodule">
                          <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                        </do_if>
                        <do_else>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                        </do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_pickup_moving"/>
                      </do_if>
                      <do_else>
                        <run_actions ref="MoveFailedHandling_ToSlot">
                          <param name="NPC" value="$NPC"/>
                          <param name="DestinationSlot" value="this.$destinationslot"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_pickup_moving_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'Unable to find a pickup slot.'" chance="@$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_pickup_find" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_pickup_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_pickup_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_pickup_moving_finished"/>
                  <param name="DebugChance" value="@$DebugChance"/>
                </cue>

                <cue name="EXIT_pickup_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_pickup_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_pickup_moving_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_pickup_moving_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_pickup_moving_finished">
                  <actions>
                    <do_if value="$PickupDone">
                      <!--Pickup was done, end-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                    <do_else>
                      <!--Pickup was not done yet, do it-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_pickup_action"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_pickup_moving_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_pickup_action">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_pickup_action">
                  <actions>
                    <start_actor_sequence actor="$NPC" type="'tool_pickup_ground'" behavior="'standing'" transition="false" result="this.$animationstarted"/>
                    <set_actor_tool actor="$NPC" name="'tool1hand'" />
                    <do_if value="not this.$animationstarted">
                      <debug_text text="'Unable to start pickup animation for ' + $NPC.knownname + ' ' + $NPC" filter="error"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                  </actions>
                </cue>

                <cue name="EXIT_pickup_action" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_pickup_action_finished" instantiate="true">
                  <conditions>
                    <event_character_animation_finished object="$NPC" id="'tran_toolcrouch_toolstand_01'"/>
                  </conditions>
                  <actions>
                    <set_value name="$PickupDone" exact="true"/>
                    <find_npc_slot name="this.$destinationslot" object="$NPC.walkablemodule" tags="tag.npc_generic"/>
                    <do_if value="not this.$destinationslot">
                      <find_npc_slot name="this.$destinationslot" object="$NPC.container" tags="tag.npc_generic"/>
                    </do_if>

                    <do_if value="this.$destinationslot">
                      <!--Go to this.$destinationslot-->
                      <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                        <param name="NPC" value="$NPC"/>
                        <param name="DestinationSlot" value="this.$destinationslot"/>
                        <param name="DebugChance" value="@$DebugChance"/>
                      </run_actions>
                      <do_if value="this.$pathtable">
                        <set_value name="$pathtable" exact="this.$pathtable"/>
                        <do_if value="$NPC.room.parent.isclass.walkablemodule">
                          <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                        </do_if>
                        <do_else>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                        </do_else>
                        <do_if value="this.$destinationslot.hastag.npc">
                          <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                        </do_if>
                        <do_else>
                          <clear_actor_roomslot actor="$NPC"/>
                        </do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_pickup_moving"/>
                      </do_if>
                      <do_else>
                        <run_actions ref="MoveFailedHandling_ToSlot">
                          <param name="NPC" value="$NPC"/>
                          <param name="DestinationSlot" value="this.$destinationslot"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_pickup_moving_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'Unable to find a destination slot.'" chance="@$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_vendomat">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_vendomat">
              <actions>
                <!-- set_value name="$DebugChance" exact="100"/ -->
                <set_value name="$PickupDone" exact="false"/>
                <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_find"/>
              </actions>
            </cue>

            <cue name="EXIT_vendomat">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <remove_value name="$VendomatDone"/>
              </actions>
            </cue>

            <!--Sub-states-->
            <cue name="STATE_vendomat_find">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_vendomat_find">
                  <actions>
                    <find_npc_slot name="this.$destinationslot" object="$NPC.walkablemodule" tags="tag.vendingmachine"/>

                    <do_if value="this.$destinationslot">
                      <set_value name="$vendomat" exact="this.$destinationslot.component"/>
                      <!--Go to this.$destinationslot-->
                      <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                        <param name="NPC" value="$NPC"/>
                        <param name="DestinationSlot" value="this.$destinationslot"/>
                        <param name="DebugChance" value="@$DebugChance"/>
                      </run_actions>
                      <do_if value="this.$pathtable">
                        <set_value name="$pathtable" exact="this.$pathtable"/>
                        <do_if value="$NPC.room.parent.isclass.walkablemodule">
                          <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                        </do_if>
                        <do_else>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                        </do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_moving"/>
                      </do_if>
                      <do_else>
                        <run_actions ref="MoveFailedHandling_ToSlot">
                          <param name="NPC" value="$NPC"/>
                          <param name="DestinationSlot" value="this.$destinationslot"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_moving_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'Unable to find a vendomat slot.'" chance="@$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_vendomat_find" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_vendomat_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_vendomat_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_vendomat_moving_finished"/>
                  <param name="DebugChance" value="@$DebugChance"/>
                </cue>

                <cue name="EXIT_vendomat_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_vendomat_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_moving_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_vendomat_moving_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_vendomat_moving_finished">
                  <actions>
                    <do_if value="$VendomatDone">
                      <!--Vendomat was done, end-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                    <do_else>
                      <!--Vendomat was not done yet, do it-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_action"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_vendomat_moving_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_vendomat_action">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_vendomat_action">
                  <actions>
                    <trigger_animation object="$vendomat" trigger="activate"/>
                    <start_actor_sequence actor="$NPC" type="'vendingmachine_use'" behavior="'generic'" transition="false" result="this.$animationstarted"/>
                    <do_if value="not this.$animationstarted">
                      <debug_text text="'Unable to start vendomat animation for ' + $NPC.knownname + ' ' + $NPC" filter="error"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                  </actions>
                </cue>

                <cue name="EXIT_vendomat_action" ref="EXIT_Empty"/>


                <cue name="TRANSITION_vendomat_action_finished" instantiate="true">
                  <conditions>
                    <!-- event_character_animation_finished object="$NPC" id="'tran_standterminal_stand_01'"/ -->
                    <event_character_animation_finished object="$NPC" id="'vending_takeout'"/>
                  </conditions>
                  <actions>
                    <trigger_animation object="$vendomat" trigger="deactivate"/>
                    <set_value name="$VendomatDone" exact="true"/>
                    <find_npc_slot name="this.$destinationslot" object="$NPC.walkablemodule" tags="tag.npc_generic"/>
                    <do_if value="not this.$destinationslot">
                      <find_npc_slot name="this.$destinationslot" object="$NPC.container" tags="tag.npc_generic"/>
                    </do_if>

                    <do_if value="this.$destinationslot">
                      <!--Go to this.$destinationslot-->
                      <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                        <param name="NPC" value="$NPC"/>
                        <param name="DestinationSlot" value="this.$destinationslot"/>
                        <param name="DebugChance" value="@$DebugChance"/>
                      </run_actions>
                      <do_if value="this.$pathtable">
                        <set_value name="$pathtable" exact="this.$pathtable"/>
                        <do_if value="$NPC.room.parent.isclass.walkablemodule">
                          <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                        </do_if>
                        <do_else>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                        </do_else>
                        <do_if value="this.$destinationslot.hastag.npc">
                          <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                        </do_if>
                        <do_else>
                          <clear_actor_roomslot actor="$NPC"/>
                        </do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_moving"/>
                      </do_if>
                      <do_else>
                        <run_actions ref="MoveFailedHandling_ToSlot">
                          <param name="NPC" value="$NPC"/>
                          <param name="DestinationSlot" value="this.$destinationslot"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_moving_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'Unable to find a destination slot.'" chance="@$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_welder">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <debug_text text="'STATE_welder start.'" chance="@$DebugChance"/>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_welder">
              <actions>
                <!-- set_value name="$DebugChance" exact="100" / -->
                <set_value name="$ToolInHand" exact="false" />
                <set_value name="$ToolType" exact="'TwoHand'" />
                <do_if value="@$NPC.$welder_ship.exists">
                  <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool"/>
                </do_if>
                <do_else>
                  <!--No dock assigned. Re-init, probably back to service behaviour-->
                  <!-- find ships -->
                  <set_value name="$DockArea" exact="null"/>
                  <set_value name="$Parent" exact="$NPC.parent"/>
                  <do_while value="$Parent">
                    <do_if value="$Parent.isclass.walkablemodule">
                      <set_value name="$DockArea" exact="$Parent"/>
                      <break/>
                    </do_if>
                    <set_value name="$Parent" exact="$Parent.parent"/>
                  </do_while>
                  <do_if value="not $DockArea">
                    <set_value name="$Parent" exact="$NPC.parent"/>
                    <do_while value="$Parent">
                      <do_if value="$Parent.isclass.object">
                        <set_value name="$DockArea" exact="$Parent"/>
                        <break/>
                      </do_if>
                      <set_value name="$Parent" exact="$Parent.parent"/>
                    </do_while>
                  </do_if>

                  <do_if value="$DockArea">
                    <debug_text text="'Welder found DockArea Parent ' + $DockArea.macro" chance="@$DebugChance"/>
                    <find_dockingbay name="$DockingBays" object="$DockArea" multiple="true">
                      <match_dock storage="false" size="tag.dock_s" walkable="true"/>
                    </find_dockingbay>

                    <create_group groupname="this.$Ships"/>
                    <do_all exact="$DockingBays.count" counter="$i">
                      <debug_text text="'dock ' + $DockingBays.{$i}.macro" chance="@$DebugChance"/>
                      <!--TODO @Owen better check that the ship is actually docked?-->
                      <do_if value="$DockingBays.{$i}.assignedship">
                        <debug_text text="'  assigned ship ' + $DockingBays.{$i}.assignedship.macro + ' Name ' + $DockingBays.{$i}.assignedship.knownname" chance="@$DebugChance"/>
                        <add_to_group object="$DockingBays.{$i}.assignedship" groupname="this.$Ships"/>
                      </do_if>
                    </do_all>
                    <debug_text text="'ships ' + this.$Ships.count" chance="@$DebugChance"/>
                    <do_if value="this.$Ships.count">
                      <set_value name="this.$DistanceTable" exact="table[]"/>
                      <do_all exact="this.$Ships.count" counter="$i">
                        <!--TODO @Owen - improve selection by distance. Walk distance may actually be longer than direct distance-->
                        <set_value name="this.$DistanceTable.{this.$Ships.{$i}}" exact="this.$Ships.{$i}.distanceto.{$NPC}"/>
                      </do_all>
                      <set_value name="this.$NearestShip" exact="this.$DistanceTable.keys.sorted.{1}"/>
                      <debug_text text="'Nearest Ship: ' + this.$NearestShip + ' ' + this.$NearestShip.macro + ' Name ' + this.$NearestShip.knownname" chance="@$DebugChance"/>
                      <set_value name="$NPC.$welder_ship" exact="this.$NearestShip"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'Welder no ship found!'" chance="@$DebugChance"/>
                    </do_else>
                  </do_if >
                  <do_else>
                    <debug_text text="'Welder no dockarea found!'"/>
                  </do_else>
                  <!-- Second try with found ship -->
                  <do_if value="@$NPC.$welder_ship.exists">
                    <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool"/>
                  </do_if>
                  <do_else>
                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </do_else>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_welder">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <remove_value name="$ToolType" />
                <remove_value name="$ToolInHand" />
                <remove_value name="$DestinationSlot" />
                <!--<remove_value name="$JobDone"/>-->
                <do_if value="$AssignedShip?">
                  <remove_value name="$AssignedShip" />
                </do_if>
                <do_if value="$NPC.$welder_ship?">
                  <remove_value name="$NPC.$welder_ship" />
                </do_if>
                <do_if value="$Docking?">
                  <remove_value name="$Docking" />
                </do_if>
              </actions>
            </cue>
            <!-- Getting or dropping welding tool from box in the ground 
                This assumes the following variables have been set:
                $ToolInHand bool whether the welder is already carrying the tool or not
                $ToolType tool id which type of tool the welder is using (two handed for now) 
                -->
            <cue name="STATE_welder_with_tool">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!-- Enter / Exit actions -->
                <cue name="ENTER_welder_with_tool">
                  <actions>
                    <set_value name="$DestinationSlot" exact="null" />
                    <!-- Select which type of tool the NPC should use -->
                    <do_if value="not $ToolInHand">
                      <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) will pick up a tool with type ' + $ToolType" chance="@$DebugChance" />
                    </do_if>
                    <do_else>
                      <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) will drop tool with type ' + $ToolType" chance="@$DebugChance" />
                    </do_else>
                    <signal_cue_instantly cue="ChangeState" param="STATE_welder_find_tool" />
                  </actions>
                </cue>

                <cue name="EXIT_welder_with_tool">
                  <conditions>
                    <event_cue_signalled cue="parent" />
                    <check_value value="@event.param == 'exit'" />
                  </conditions>
                  <actions>
                    <remove_value name="$DestinationSlot" />
                  </actions>
                </cue>

                <!-- Sub-states -->
                <cue name="STATE_welder_find_tool">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_welder_find_tool">
                      <actions>
                        <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) trying to find a pickup location'" chance="@$DebugChance" />
                        <do_if value="$NPC.walkablemodule">
                          <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) on walkable: ' + $NPC.walkablemodule" chance="@$DebugChance" />
                          <do_if value="true" chance="20">
                            <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) trying to pickup from locker'" chance="@$DebugChance" />
                            <find_npc_waypoint name="$Waypoints" object="$NPC.walkablemodule" tags="tag.pickup_locker" multiple="true" />
                            <do_all exact="$Waypoints.count" counter="$WaypointCounter" reverse="true">
                              <do_if value="$Waypoints.{$WaypointCounter}" exact="$DestinationSlot">
                                <remove_value name="$Waypoints.{$WaypointCounter}" />
                              </do_if>
                            </do_all>
                            <do_if value="$Waypoints.count">
                              <set_value name="$DistanceTable" exact="table[]"/>
                              <do_all exact="$Waypoints.count" counter="$i">
                                <!--TODO @Owen - improve selection by distance. Walk distance may actually be longer than direct distance-->
                                <set_value name="$DistanceTable.{$Waypoints.{$i}}" exact="$NPC.distanceto.{$Waypoints.{$i}}"/>
                              </do_all>
                              <set_value name="$DestinationSlot" exact="$DistanceTable.keys.sorted.{1}"/>
                              <!-- set_value name="$DestinationSlot" list="$Waypoints" / -->
                              <debug_text text="'DestinationSlot ' + $DestinationSlot" chance="@$DebugChance" />
                            </do_if>
                          </do_if>
                          <do_if value ="not $DestinationSlot">
                            <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) trying to pickup from hole'" chance="@$DebugChance" />
                            <find_npc_waypoint name="$Waypoints" object="$NPC.walkablemodule" tags="tag.pickup_hole" multiple="true" />
                            <do_all exact="$Waypoints.count" counter="$WaypointCounter" reverse="true">
                              <do_if value="$Waypoints.{$WaypointCounter}" exact="$DestinationSlot">
                                <remove_value name="$Waypoints.{$WaypointCounter}" />
                              </do_if>
                            </do_all>
                            <do_if value="$Waypoints.count">
                              <set_value name="$DistanceTable" exact="table[]"/>
                              <do_all exact="$Waypoints.count" counter="$i">
                                <!--TODO @Owen - improve selection by distance. Walk distance may actually be longer than direct distance-->
                                <set_value name="$DistanceTable.{$Waypoints.{$i}}" exact="$NPC.distanceto.{$Waypoints.{$i}}"/>
                              </do_all>
                              <set_value name="$DestinationSlot" exact="$DistanceTable.keys.sorted.{1}"/>
                              <!-- set_value name="$DestinationSlot" list="$Waypoints" / -->
                              <debug_text text="'DestinationSlot ' + $DestinationSlot" chance="@$DebugChance" />
                            </do_if>
                          </do_if>
                        </do_if>
                        <do_if value ="not $DestinationSlot">
                          <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) trying to find a pickup location on the target ships dockingbay'" chance="@$DebugChance" />
                          <do_if value="$NPC.$welder_ship">
                            <do_if value="$NPC.$welder_ship.dock">
                              <debug_text text="'welder ship dockingbay ' + $NPC.$welder_ship.dock.macro" chance="@$DebugChance"/>
                              <find_npc_waypoint name="$DestinationSlot" object="$NPC.$welder_ship.dock" tags="tag.pickup_hole" />
                            </do_if>
                            <do_else>
                              <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) target ship does not have a dock'" chance="@$DebugChance" />
                              <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                            </do_else>
                          </do_if>
                          <do_else>
                            <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) target ship does not exist'" chance="@$DebugChance" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                          </do_else>
                        </do_if>
                        <do_if value="$DestinationSlot">
                          <debug_text text="'welder $NPC: ' + $NPC.name + ' $Destinationslot ' + $DestinationSlot" chance="@$DebugChance"/>
                          <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                            <param name="NPC" value="$NPC"/>
                            <param name="DestinationSlot" value="$DestinationSlot"/>
                            <param name="DebugChance" value="@$DebugChance"/>
                          </run_actions>
                          <do_if value="this.$pathtable">
                            <set_value name="$pathtable" exact="this.$pathtable" />
                            <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_welder_move_to_tool" />
                          </do_if>
                          <do_else>
                            <run_actions ref="MoveFailedHandling_ToSlot">
                              <param name="NPC" value="$NPC"/>
                              <param name="DestinationSlot" value="$DestinationSlot"/>
                              <param name="DebugChance" value="@$DebugChance"/>
                            </run_actions>
                            <signal_cue_instantly cue="ChangeState" param="STATE_welder_tool_action" />
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'Unable to find a pickup slot'" chance="@$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_welder_find_tool" ref="EXIT_Empty" />
                  </cues>
                </cue>

                <cue name="STATE_welder_move_to_tool">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_welder_move_to_tool" ref="PerformPath">
                      <param name="NPC" value="$NPC" />
                      <param name="pathtable" value="$pathtable" />
                      <param name="signalcue" value="TRANSITION_welder_tool_action" />
                      <param name="DebugChance" value="@$DebugChance" />
                    </cue>

                    <cue name="EXIT_welder_move_to_tool" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_welder_tool_action">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_welder_tool_action" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_welder_tool_action">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_welder_tool_action">
                      <actions>
                        <do_if value="$DestinationSlot and $DestinationSlot.hastag.pickup_locker">
                          <debug_text text="'Pickup from Locker!'" chance="@$DebugChance"/>
                          <do_if value="not $ToolInHand">
                            <debug_text text="'Pickup from Hole!'" chance="@$DebugChance"/>
                            <set_value name="$AnimationType" exact="'tool_takeout_locker'" />
                          </do_if>
                          <do_elseif value="$ToolInHand">
                            <set_value name="$AnimationType" exact="'tool_putin_locker'" />
                          </do_elseif>
                          <!--TODO @Owen this probably should specify a group-->
                          <trigger_animation object="$NPC.room" trigger="activate" />
                        </do_if>
                        <do_elseif value="$DestinationSlot and $DestinationSlot.hastag.pickup_hole">
                          <debug_text text="'Pickup from Hole!'" chance="@$DebugChance"/>
                          <do_if value="not $ToolInHand">
                            <debug_text text="'Pickup from Hole!'" chance="@$DebugChance"/>
                            <do_any>
                              <set_value name="$AnimationType" exact="'tool_quickpickup_ground'" weight="70" />
                              <set_value name="$AnimationType" exact="'tool_pickup_ground'" weight="30" />
                            </do_any>
                          </do_if>
                          <do_elseif value="$ToolInHand">
                            <debug_text text="'Drop to Hole!'" chance="@$DebugChance"/>
                            <set_value name="$AnimationType" exact="'tool_drop_ground'" />
                          </do_elseif>
                          <trigger_animation object="$NPC.room" group="'groundhatch'" trigger="activate" />
                        </do_elseif>
                        <do_else>
                          <debug_text text="'Pickup from unknwon location!'" chance="@$DebugChance"/>
                        </do_else>
                        <debug_text text="'$AnimationType for tool interaction set to ' + $AnimationType" chance="@$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="$AnimationType" transition="true" immediate="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <debug_text text="'Unable to start ' + $AnimationType + ' animation sequence for ' + $NPC.name + ' ({' + $NPC + '})'"  filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_welder_tool_action" ref="EXIT_Empty" />

                    <cue name="TRANSITION_welder_picked_up_tool_locker">
                      <conditions>
                        <event_character_animation_started object="$NPC" id="'anim_locker_takeout'" />
                      </conditions>
                      <delay exact="1s"/>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is picking up a tool'" chance="@$DebugChance" />
                        <!-- TODO @Lorraine: The way this is currently set up means that if the NPC stops crouched down to search for the tool before picking it up, it
                             appears in their hand before they are done searching. This is not easily solved by separating out the sequences for searching and non-searching,
                             more likely, here we have to make the decision to search or not, have an optional sequence for searching and wait for that to be fired if searching
                             was selected - or something along these lines -->
                        <do_if value="$ToolType" exact="'OneHand'">
                          <set_actor_tool actor="$NPC" name="'tool1hand'" />
                        </do_if>
                        <do_elseif value="$ToolType" exact="'TwoHand'">
                          <set_actor_tool actor="$NPC" name="'tool2hand'" />
                        </do_elseif>
                        <set_value name="$ToolInHand" exact="true" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="@$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_welder_dropped_tool_locker">
                      <conditions>
                        <event_character_animation_started object="$NPC" id="'anim_locker_putin'" />
                      </conditions>
                      <delay exact="1s"/>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is dropping a tool'" chance="@$DebugChance" />
                        <clear_actor_tool actor="$NPC" />
                        <set_value name="$ToolInHand" exact="false" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="@$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_welder_tool_action_locker_finished">
                      <conditions>
                        <check_any>
                          <event_character_animation_finished object="$NPC" id="'anim_locker_takeout'" />
                          <event_character_animation_finished object="$NPC" id="'anim_locker_putin'" />
                        </check_any>
                      </conditions>
                      <actions>
                        <trigger_animation object="$NPC.room" trigger="deactivate" />
                        <do_if value="not $ToolInHand">
                          <debug_text text="'Welder will reinitialise'" chance="@$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                        <do_else>
                          <debug_text text="'Welder has tool in hand, they should go and use it'" chance="@$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_welder_use_tool" />
                        </do_else>
                      </actions>
                    </cue>

                    <!-- Transitions -->
                    <cue name="TRANSITION_welder_picked_up_tool">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'tran_stand_toolcrouch_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is picking up a tool'" chance="@$DebugChance" />
                        <!-- TODO @Lorraine: The way this is currently set up means that if the NPC stops crouched down to search for the tool before picking it up, it
                             appears in their hand before they are done searching. This is not easily solved by separating out the sequences for searching and non-searching,
                             more likely, here we have to make the decision to search or not, have an optional sequence for searching and wait for that to be fired if searching
                             was selected - or something along these lines -->
                        <do_if value="$ToolType" exact="'OneHand'">
                          <set_actor_tool actor="$NPC" name="'tool1hand'" />
                        </do_if>
                        <do_elseif value="$ToolType" exact="'TwoHand'">
                          <set_actor_tool actor="$NPC" name="'tool2hand'" />
                        </do_elseif>
                        <set_value name="$ToolInHand" exact="true" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="@$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_welder_dropped_tool">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'tran_toolstand_toolcrouch_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is dropping a tool'" chance="@$DebugChance" />
                        <clear_actor_tool actor="$NPC" />
                        <set_value name="$ToolInHand" exact="false" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="@$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_welder_tool_action_finished">
                      <conditions>
                        <check_any>
                          <event_character_animation_finished object="$NPC" id="'tran_toolcrouch_toolstand_01'" />
                          <event_character_animation_finished object="$NPC" id="'tran_toolcrouch_stand_01'" />
                        </check_any>
                      </conditions>
                      <actions>
                        <trigger_animation object="$NPC.room" group="'groundhatch'" trigger="deactivate" />

                        <do_if value="not $ToolInHand">
                          <debug_text text="'Welder will reinitialise'" chance="@$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                        <do_else>
                          <debug_text text="'Welder has tool in hand, they should go and use it'" chance="@$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_welder_use_tool" />
                        </do_else>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>
            <!-- Welder using tool at ship. This includes moving to the position at the ship
            -->
            <cue name="STATE_welder_use_tool">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!-- Enter / Exit actions -->
                <cue name="ENTER_welder_use_tool">
                  <actions>
                    <set_value name="$DestinationSlot" exact="null" />
                    <!-- Select which type of tool the NPC should use -->
                    <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) will use the welding tool ' + $ToolType" chance="@$DebugChance" />
                    <signal_cue_instantly cue="ChangeState" param="STATE_welder_find_position" />
                  </actions>
                </cue>

                <cue name="EXIT_welder_use_tool">
                  <conditions>
                    <event_cue_signalled cue="parent" />
                    <check_value value="@event.param == 'exit'" />
                  </conditions>
                  <actions>
                    <remove_value name="$DestinationSlot" />
                  </actions>
                </cue>
                <!-- Sub-states -->
                <cue name="STATE_welder_find_position" version="2">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <patch sinceversion="2" state="complete">
                    <debug_text text="'Stuck in pickup Loop'" chance="@$DebugChance"/>
                    <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                  </patch>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_welder_find_position">
                      <actions>
                        <do_if value="$NPC.$welder_ship.isoperational">
                          <do_if value="$NPC.$welder_ship.dock">
                            <debug_text text="'welder ship dockingbay ' + $NPC.$welder_ship.dock.macro" chance="@$DebugChance"/>
                            <find_npc_slot name="this.$destinationslot" object="$NPC.$welder_ship.dock" tags="tag.welder" excludefilled="true"/>
                            <debug_text text="'welder $destinationslot ' + this.$destinationslot" chance="@$DebugChance"/>
                            <do_if value="this.$destinationslot">
                              <!-- calculate a position on the dockingbay -->
                              <find_actor_interaction_point posname="this.$destinationoffset" rotname="this.$destinationrotation" actor="$NPC" object="$NPC.$welder_ship" slot="this.$destinationslot"/>
                              <do_if value="this.$destinationoffset">
                                <debug_text text="'interaction point ' + this.$destinationoffset + ' * ' + this.$destinationrotation" chance="@$DebugChance"/>
                                <debug_text text="'slot offset ' + this.$destinationslot.offset + ' * ' + this.$destinationslot.rotation" chance="@$DebugChance"/>
                                <!--TODO @Owen @Martin Reserve slot?-->
                                <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                                  <param name="NPC" value="$NPC"/>
                                  <param name="DestinationSlot" value="this.$destinationslot"/>
                                  <param name="DestinationOffset" value="this.$destinationoffset"/>
                                  <param name="DestinationRotation" value="this.$destinationrotation"/>
                                  <param name="DebugChance" value="@$DebugChance"/>
                                </run_actions>
                                <do_if value="this.$pathtable">
                                  <set_value name="$pathtable" exact="this.$pathtable" />
                                  <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                                  <signal_cue_instantly cue="ChangeState" param="STATE_welder_move_to_position" />
                                </do_if>
                                <do_else>
                                  <debug_text text="'Unable to find path to weld point'" chance="@$DebugChance"/>
                                  <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                                </do_else>
                              </do_if>
                              <do_else>
                                <run_actions ref="MoveFailedHandling_ToSlot">
                                  <param name="NPC" value="$NPC"/>
                                  <param name="DestinationSlot" value="this.$destinationslot"/>
                                  <param name="DestinationOffset" value="this.$destinationoffset"/>
                                  <param name="DestinationRotation" value="this.$destinationrotation"/>
                                  <param name="DebugChance" value="@$DebugChance"/>
                                </run_actions>
                                <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                              </do_else>
                            </do_if>
                            <do_else>
                              <debug_text text="'Welding slot occupied'" chance="@$DebugChance" />
                              <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                            </do_else>
                          </do_if>
                          <do_else>
                            <debug_text text="'Welder ship has no dock'" chance="@$DebugChance" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'Unable to find the ship to weld'" chance="@$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_welder_find_position" ref="EXIT_Empty" />
                  </cues>
                </cue>

                <cue name="STATE_welder_move_to_position">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->

                    <cue name="ENTER_welder_move_to_position" ref="PerformPath">
                      <param name="NPC" value="$NPC" />
                      <param name="pathtable" value="$pathtable" />
                      <param name="signalcue" value="TRANSITION_welder_use_action" />
                      <param name="DebugChance" value="@$DebugChance" />
                    </cue>

                    <cue name="EXIT_welder_move_to_position" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_welder_use_action">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_welder_use_action" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_welder_use_action">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_welder_use_action">
                      <actions>
                        <set_value name="$AnimationType" exact="'2htool_use'" />
                        <debug_text text="'$AnimationType for welding action set to ' + $AnimationType" chance="@$DebugChance" />

                        <!-- trigger_animation object="$NPC.room" group="'groundhatch'" trigger="activate" / -->

                        <start_actor_sequence actor="$NPC" type="$AnimationType" behavior="'generic'" transition="false" immediate="false" result="this.$animationstarted" />
                        <!--
                        <do_if value="not this.$animationstarted">
                          <debug_text text="'Unable to start ' + $AnimationType + ' animation sequence for ' + $NPC.name + ' ({' + $NPC + '})'"  filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                        -->
                      </actions>
                    </cue>

                    <cue name="EXIT_welder_use_action" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_welder_use_action_finished">
                      <conditions>
                        <event_character_animation_started object="$NPC" id="'anim_stand_conversation_01'" />
                      </conditions>
                      <actions>
                        <do_any>
                          <do_all weight="80">
                            <debug_text text="'welder finished using tool, move to another position'" chance="@$DebugChance" />
                            <set_value name="$DestinationSlot" exact="null" />
                            <!-- Select which type of tool the NPC should use -->
                            <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) will use the welding tool ' + $ToolType" chance="@$DebugChance" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_welder_find_position" />
                          </do_all>
                          <do_all weight="20">
                            <debug_text text="'welder finished using tool, they should put it back'" chance="@$DebugChance" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                          </do_all>
                        </do_any>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_airmarshal">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_airmarshal">
              <actions>
                <!-- set_value name="$DebugChance" exact="100" / -->
                <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                  <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_find"/>
                </do_if>
                <do_else>
                  <!--No dock assigned. Re-init, probably back to service behaviour-->
                  <remove_value name="$NPC.$airmarshal_dockingbay"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_airmarshal">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <!--<remove_value name="$JobDone"/>-->
                <do_if value="$AssignedShip?">
                  <remove_value name="$AssignedShip" />
                </do_if>
                <do_if value="$NPC.$airmarshal_dockingbay?">
                  <remove_value name="$NPC.$airmarshal_dockingbay" />
                </do_if>
                <do_if value="$Docking?">
                  <remove_value name="$Docking" />
                </do_if>
              </actions>
            </cue>

            <!--Transitions-->

            <!--Sub-states-->
            <cue name="STATE_airmarshal_find">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_airmarshal_find">
                  <actions>
                    <set_value name="this.$destinationslot" exact="null"/>
                    <do_if value="$NPC.roomslot and $NPC.roomslot.component == $NPC.$airmarshal_dockingbay and $NPC.roomslot.hastag.airmarshal">
                      <set_value name="this.$destinationslot" exact="$NPC.roomslot"/>
                    </do_if>

                    <do_if value="this.$destinationslot and not $NPC.isintransit">
                      <!--Already standing in a suitable slot-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moving_finished"/>
                    </do_if>
                    <do_else>
                      <find_npc_slot name="this.$destinationslot" object="$NPC.$airmarshal_dockingbay" tags="tag.airmarshal"/>
                      <do_if value="this.$destinationslot">
                        <!--Go to this.$destinationslot-->
                        <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                          <param name="NPC" value="$NPC"/>
                          <param name="DestinationSlot" value="this.$destinationslot"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>
                        <do_if value="this.$pathtable">
                          <set_value name="$pathtable" exact="this.$pathtable"/>
                          <do_if value="$NPC.room.parent.isclass.walkablemodule">
                            <set_value name="$pathtable.$speed" exact="$NPC.runspeed" />
                          </do_if>
                          <do_else>
                            <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                          </do_else>
                          <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                          <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moving"/>
                        </do_if>
                        <do_else>
                          <run_actions ref="MoveFailedHandling_ToSlot">
                            <param name="NPC" value="$NPC"/>
                            <param name="DestinationSlot" value="this.$destinationslot"/>
                            <param name="DebugChance" value="@$DebugChance"/>
                          </run_actions>
                          <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                          <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moving_finished"/>
                        </do_else>
                      </do_if>
                      <do_else>
                        <debug_text text="'$NPC ' + $NPC.knownname + ' ({' + $NPC + '}) unable to find an air marshal slot on ' + $NPC.$airmarshal_dockingbay.knownname + ' ({' + $NPC.$airmarshal_dockingbay + '}).'" filter="error"/>
                        <!--TODO @Owen wait a little while and try to find slot again-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_idle_stay"/>
                      </do_else>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_find" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_airmarshal_moving" ref="PerformPath" comment="Movement helper library">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_airmarshal_moving_finished"/>
                  <param name="DebugChance" value="@$DebugChance"/>
                </cue>

                <cue name="EXIT_airmarshal_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_airmarshal_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moving_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_moving_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_airmarshal_moving_finished">
                  <actions>
                    <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                      <do_if value="$NPC.roomslot.hastag.airmarshal">
                        <!--Arrived at air marshaling position-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_standby"/>
                      </do_if>
                      <do_else>
                        <!--Should be at an airmarshal slot-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_find"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <!--Done with marshalling for now. Just idle at this point for a while-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_idle_stay"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_moving_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_standby">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>

                <!-- Identify the ship that is docking / undocking -->
                <set_value name="$AssignedShip" exact="null" />
                <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                  <set_value name="$AssignedShip" exact="$NPC.$airmarshal_dockingbay.assignedship" />
                </do_if>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_airmarshal_standby">
                  <actions>
                    <do_if value="not $NPC.hasbody">
                      <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="30s" />
                    </do_if>
                    <do_else>
                      <start_actor_sequence actor="$NPC" type="'marshalling_standby'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                      <do_if value="not this.$animationstarted">
                        <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                        <set_value name="$NpcLocation" exact="$NPC.container" />
                        <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                        <set_value name="$NPCAttention" exact="$NPC.attention" />

                        <set_value name="$PlayerLocation" exact="player.container" />
                        <do_if value="player.container.isclass.station">
                          <set_value name="$PlayerOnStation" exact="'is on'" />
                        </do_if>
                        <do_else>
                          <set_value name="$PlayerOnStation" exact="'is not on'" />
                        </do_else>

                        <debug_text text="'Unable to start marshalling_standby animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                      </do_if>

                      <do_elseif value="$AssignedShip and $AssignedShip.isclass.ship">
                        <debug_text text="'$AssignedShip is ' + $AssignedShip.knownname + ' with ID code ' + $AssignedShip.idcode + ' ({' + $AssignedShip + '})'" chance="@$DebugChance" />
                        <debug_text text="'$NPC is ' + $NPC.knownname + ' ({' + $NPC + '})'" chance="@$DebugChance" />

                        <!-- Checking these cases allows the air marshal to turn up late and known which state the $AssignedShip is in -->
                        <!-- Playership approaching -->
                        <do_if value="(($AssignedShip == player.ship and $NPC.$airmarshal_dockingbay.dockstate == dockstate.default) and not $AssignedShip.dock) and $AssignedShip.distanceto.{$NPC.$airmarshal_dockingbay} le 750m">
                          <debug_text text="'$AssignedShip (playership) is approaching station - swapping to dock state'" chance="@$DebugChance" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'dock'" />
                          <!--As we've already signalled to identifygate, no need to have another cue doing it-->
                          <cancel_cue cue="TRANSITION_airmarshal_standby_identifygate_approachingship"/>
                        </do_if>

                        <!-- Approaching Case -->
                        <do_elseif value="($NPC.$airmarshal_dockingbay.dockstate == dockstate.default and not $AssignedShip.dock) and $AssignedShip.distanceto.{$NPC.$airmarshal_dockingbay} le 750m">
                          <debug_text text="'$AssignedShip is approaching station - swapping to identifygate state'" chance="@$DebugChance" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'identifygate'" />
                          <!--As we've already signalled to identifygate, no need to have another cue doing it-->
                          <cancel_cue cue="TRANSITION_airmarshal_standby_identifygate_approachingship"/>
                        </do_elseif>

                        <!-- Docking Case -->
                        <do_elseif value="$NPC.$airmarshal_dockingbay.dockstate == dockstate.docking">
                          <debug_text text="'$AssignedShip is docking - swapping to docking state'" chance="@$DebugChance" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'dock'" />
                        </do_elseif>

                        <!-- Docked Case -->
                        <do_elseif value="$NPC.$airmarshal_dockingbay.dockstate == dockstate.default and $AssignedShip.dock">
                          <debug_text text="'$AssignedShip is docked - swapping to idle state'" chance="@$DebugChance" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="30s" />
                        </do_elseif>

                        <!-- Undocking Case -->
                        <do_elseif value="$NPC.$airmarshal_dockingbay.dockstate == dockstate.undocking">
                          <debug_text text="'$AssignedShip is undocking - swapping to undocking state'" chance="@$DebugChance" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'undock'" />
                        </do_elseif>
                      </do_elseif>

                      <!-- Idle Case -->
                      <do_else>
                        <debug_text text="'There is currently no ship assigned to marshal for $NPC ' + $NPC.knownname + ' ({' + $NPC + '})'" chance="@$DebugChance" />
                        <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="30s" />
                      </do_else>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_standby" ref="EXIT_Empty" />

                <!--Transitions-->
                <cue name="TRANSITION_airmarshal_standby_leave" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC"/>
                    <check_any>
                      <check_value value="event.param == 'npc_airmarshal' and event.param2 == 'leave'"/>
                      <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="@$DispatchTransitionStateChange">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_leave"/>
                    </do_if>
                    <do_else>
                      <include_actions ref="QueueTransitionRequest"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_standby_identifygate_approachingship" checkinterval="1s">
                  <conditions>
                    <check_value value="$AssignedShip and $AssignedShip.isoperational" />
                    <check_value value="$AssignedShip.distanceto.{$NPC.$airmarshal_dockingbay}" max="750m" />
                    <check_value value="not $AssignedShip.dock" />
                    <check_value value="$NPC.hasbody" />
                  </conditions>
                  <actions>
                    <debug_text text="'$AssignedShip is approaching station - signalling change to identifygate state'" chance="@$DebugChance" />
                    <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'identifygate'" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_standby_identifygate" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC"/>
                    <check_any>
                      <check_value value="event.param == 'npc_airmarshal' and event.param2 == 'identifygate'"/>
                      <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="@$DispatchTransitionStateChange">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_identifygate"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'$AssignedShip is approaching station - requesting queued state change to identifygate state'" chance="@$DebugChance" />
                      <include_actions ref="QueueTransitionRequest"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_standby_dock" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC"/>
                    <check_any>
                      <check_value value="event.param == 'npc_airmarshal' and event.param2 == 'dock'"/>
                      <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="@$DispatchTransitionStateChange">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'$AssignedShip is docking with station - requesting queued state change to dock state'" chance="@$DebugChance" />
                      <include_actions ref="QueueTransitionRequest"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_standby_undock" instantiate="true">
                  <conditions>
                    <check_any>
                      <check_all>
                        <event_object_signalled object="$NPC"/>
                        <check_any>
                          <check_value value="event.param == 'npc_airmarshal' and event.param2 == 'undock'"/>
                          <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                        </check_any>
                      </check_all>
                      <check_all>
                        <event_object_started_to_undock_from container="$NPC.container" />
                        <check_value value="event.param.dock" exact="$NPC.$airmarshal_dockingbay" />
                      </check_all>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="@$DispatchTransitionStateChange">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_undock"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'$AssignedShip has undocked from station - requesting queued state change to undock state'" chance="@$DebugChance" />
                      <include_actions ref="QueueTransitionRequest"/>
                    </do_else>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_identifygate">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!-- Enter / Exit Actions -->
                <cue name="ENTER_airmarshal_identifygate">
                  <actions>
                    <debug_text text="'$NPC is signalling the bay at which ship should dock'" chance="@$DebugChance" />
                    <start_actor_sequence actor="$NPC" type="'marshalling_identifygate'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                    <do_if value="not this.$animationstarted">
                      <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                      <set_value name="$NpcLocation" exact="$NPC.container" />
                      <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                      <set_value name="$NPCAttention" exact="$NPC.attention" />

                      <set_value name="$PlayerLocation" exact="player.container" />
                      <do_if value="player.container.isclass.station">
                        <set_value name="$PlayerOnStation" exact="'is on'" />
                      </do_if>
                      <do_else>
                        <set_value name="$PlayerOnStation" exact="'is not on'" />
                      </do_else>

                      <debug_text text="'Unable to start marshalling_identifygate animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_identifygate" ref="EXIT_Empty" />

                <!-- Transitions -->
                <cue name="TRANSITION_airmarshal_identifygate_dock" instantiate="true">
                  <conditions>
                    <event_object_started_to_dock_at container="$NPC.container" />
                    <check_value value="event.param.assigneddock" exact="$NPC.$airmarshal_dockingbay" />
                  </conditions>
                  <actions>
                    <debug_text text="'$AssignedShip is docking with station - changing to dock state'" chance="@$DebugChance" />
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock" />
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_dock" version="2">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
                <set_value name="$AssignedShip" exact="null" />
                <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                  <set_value name="$AssignedShip" exact="$NPC.$airmarshal_dockingbay.assignedship" />
                  <!--TODO @Owen it's possible the ship is docked at this point. should have been caught elsewhere?-->
                  <!--<do_if value="$AssignedShip.dock">
                    <debug_text text="'Ship ' + $AssignedShip + ' ' + $AssignedShip.knownname + ' is already docked.'" chance="@$DebugChance"/>
                    <set_value name="$AssignedShip" exact="null"/>
                  </do_if>-->
                </do_if>
              </actions>
              <patch sinceversion="2">
                <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
              </patch>
              <cues>
                <!-- Enter / Exit Actions -->
                <cue name="ENTER_airmarshal_dock">
                  <actions>
                    <debug_text text="'$NPC is signalling docking procedure'" chance="@$DebugChance" />
                    <do_if value="not $NPC.hasbody">
                      <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="30s" />
                    </do_if>
                    <do_else>
                      <do_if value="not $AssignedShip">
                        <!-- failsafe to leave if there is no assigned ship. NPC would usually be in another state -->
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_leave"/>
                      </do_if>
                      <do_else>

                        <!-- ~~~~~~~~ ROTATION ~~~~~~~~ -->
                        <!-- Identify important connection rotations: rotation of connection on ship that will connect to dock when landed, rotation of connection on dock that will connect to ship when ship is landed, range in which ship should be to safely land -->
                        <!--NOTE: getting maxoffset rotation with the ship and taking software into account can lead to very generous values. Don't for now.-->
                        <set_value name="$MaxOffsetPos" exact="$NPC.$airmarshal_dockingbay.maxoffset.{$AssignedShip}.position" />
                        <set_value name="$MaxOffsetRot" exact="$NPC.$airmarshal_dockingbay.maxoffset.{$AssignedShip.docksize}.rotation" />

                        <!-- Get the difference between the ship's current and final rotation for both the forward and backwards todock offsets-->
                        <set_value name="this.$ForwardRelativeRotations" exact="$AssignedShip.todockrotation.{$NPC.$airmarshal_dockingbay}" />
                        <set_value name="this.$BackwardRelativeRotations" exact="$AssignedShip.todockrotationreverse.{$NPC.$airmarshal_dockingbay}" />
                        <set_value name="this.$AbsoluteForwardYaw" exact="if this.$ForwardRelativeRotations.yaw ge 0deg then this.$ForwardRelativeRotations.yaw else this.$ForwardRelativeRotations.yaw + 360deg"/>
                        <set_value name="this.$AbsoluteBackwardsYaw" exact="if this.$BackwardRelativeRotations.yaw ge 0deg then this.$BackwardRelativeRotations.yaw else this.$BackwardRelativeRotations.yaw + 360deg"/>

                        <!--Check which yaw value is lowest between the forward and backwards todock offsets. Take the lowest one.-->
                        <do_if value="this.$AbsoluteForwardYaw lt 90deg or this.$AbsoluteForwardYaw gt 270deg">
                          <set_value name="$RelativeRotation" exact="this.$ForwardRelativeRotations"/>
                          <set_value name="$RelativePosition" exact="$AssignedShip.todockposition.{$NPC.$airmarshal_dockingbay}" />
                          <debug_text text="'Ship is landing facing forwards'" chance="@$DebugChance"/>
                        </do_if>
                        <do_else>
                          <set_value name="$RelativeRotation" exact="this.$BackwardRelativeRotations"/>
                          <set_value name="$RelativePosition" exact="$AssignedShip.todockpositionreverse.{$NPC.$airmarshal_dockingbay}" />
                          <debug_text text="'Ship is landing facing backwards'" chance="@$DebugChance"/>
                        </do_else>
                        <!--These rotations and positions are relative to the ship, e.g. a yaw value of 0-180deg means the dock is on the right and the ship must turn that way
                        Also, we can't store them as a rotation datatype as that may result in negative degrees again-->
                        <set_value name="$AbsoluteYaw"   exact="if $RelativeRotation.yaw ge 0deg then $RelativeRotation.yaw else $RelativeRotation.yaw + 360deg"/>
                        <set_value name="$AbsolutePitch" exact="if $RelativeRotation.pitch ge 0deg then $RelativeRotation.pitch else $RelativeRotation.pitch + 360deg"/>
                        <set_value name="$AbsoluteRoll"  exact="if $RelativeRotation.roll ge 0deg then $RelativeRotation.roll else $RelativeRotation.roll + 360deg"/>
                        <set_value name="$AbsoluteX"      exact="[$RelativePosition.x, $RelativePosition.x * -1.0f].max" />
                        <set_value name="$AbsoluteY"      exact="[$RelativePosition.y, $RelativePosition.y * -1.0f].max" />
                        <set_value name="$AbsoluteZ"      exact="[$RelativePosition.z, $RelativePosition.z * -1.0f].max" />
                        <do_if value="@$DebugChance" min="100" comment="Extra debugging information">
                          <debug_text text="'Ship - Relative rotation ' + [$AbsoluteYaw, $AbsolutePitch, $AbsoluteRoll]" />
                          <debug_text text="'$MaxOffsetRot - Yaw: ' + $MaxOffsetRot.yaw + ', Pitch: ' + $MaxOffsetRot.pitch + ', Roll: ' + $MaxOffsetRot.roll" />
                          <debug_text text="'Ship - X: ' + $RelativePosition.x + ', Y: ' + $RelativePosition.y + ', Z: ' + $RelativePosition.z" />
                          <debug_text text="'($MaxOffsetPos - X: ' + $MaxOffsetPos.x + ', Y: ' + $MaxOffsetPos.y + ', Z: ' + $MaxOffsetPos.z + ')'" />
                        </do_if>

                        <!-- Check to see whether ship is already safely aligned - if so, focus on position, otherwise focus on alignment -->

                        <set_value name="$AnimationType" exact="null" />
                        <set_value name="$EndAnimation" exact="null" />
                        <set_value name="$NextAirmarshalState" exact="STATE_airmarshal_dock"/>

                        <!--#1 Check roll-->
                        <!--TODO @Owen new animations for this case-->
                        <do_if value="$AbsoluteRoll gt $MaxOffsetRot.roll and $AbsoluteRoll lt 180deg">
                          <!-- roll clockwise -->
                          <debug_text text="'$NPC is signalling that ship should roll right ' + $AbsoluteRoll" chance="@$DebugChance" />
                          <set_value name="$AnimationType" exact="'marshalling_turnright'" />
                          <set_value name="$EndAnimation" exact="'anim_marshal_turnright_01'" />
                        </do_if>
                        <do_elseif value="$AbsoluteRoll lt 360deg - $MaxOffsetRot.roll and $AbsoluteRoll ge 180deg">
                          <!-- roll counter clockwise -->
                          <debug_text text="'$NPC is signalling that ship should roll left ' + (360deg - $MaxOffsetRot.roll - $AbsoluteRoll)" chance="@$DebugChance" />
                          <set_value name="$AnimationType" exact="'marshalling_turnleft'" />
                          <set_value name="$EndAnimation" exact="'anim_marshal_turnleft_01'" />
                        </do_elseif>

                        <!--#2 Check pitch-->
                        <!--TODO @Owen new animations for this case-->
                        <do_elseif value="$AbsolutePitch gt $MaxOffsetRot.pitch and $AbsolutePitch lt 180deg">
                          <!-- pitch up -->
                          <debug_text text="'$NPC is signalling that ship should pitch up ' + (360deg - $AbsolutePitch)" chance="@$DebugChance" />
                          <set_value name="$AnimationType" exact="'marshalling_hover'" />
                          <set_value name="$EndAnimation" exact="'anim_marshal_hover_01'" />
                        </do_elseif>
                        <do_elseif value="$AbsolutePitch lt 360deg - $MaxOffsetRot.pitch and $AbsolutePitch ge 180deg">
                          <!-- pitch down -->
                          <debug_text text="'$NPC is signalling that ship should pitch down ' + $AbsolutePitch" chance="@$DebugChance" />
                          <set_value name="$AnimationType" exact="'marshalling_hover'" />
                          <set_value name="$EndAnimation" exact="'anim_marshal_hover_01'" />
                        </do_elseif>

                        <!--#3 Check yaw-->
                        <do_elseif value="$AbsoluteYaw gt $MaxOffsetRot.yaw and $AbsoluteYaw lt 180deg">
                          <!-- turn right -->
                          <debug_text text="'$NPC is signalling that ship should yaw right ' + $AbsoluteYaw" chance="@$DebugChance" />
                          <set_value name="$AnimationType" exact="'marshalling_turnright'" />
                          <set_value name="$EndAnimation" exact="'anim_marshal_turnright_01'" />
                        </do_elseif>
                        <do_elseif value="$AbsoluteYaw lt 360deg - $MaxOffsetRot.yaw and $AbsoluteYaw ge 180deg">
                          <!-- turn left -->
                          <debug_text text="'$NPC is signalling that ship should yaw left ' + $AbsoluteYaw" chance="@$DebugChance" />
                          <set_value name="$AnimationType" exact="'marshalling_turnleft'" />
                          <set_value name="$EndAnimation" exact="'anim_marshal_turnleft_01'" />
                        </do_elseif>

                        <!--#4 Check X-->
                        <do_elseif value="$AbsoluteX gt $MaxOffsetPos.x">
                          <do_if value="$RelativePosition.x gt 0">
                            <!-- straight right -->
                            <debug_text text="'$NPC is signalling that the ship should strafe right.'" chance="@$DebugChance" />
                            <set_value name="$AnimationType" exact="'marshalling_straferight'" />
                            <set_value name="$EndAnimation" exact="'anim_marshal_straferight_01'" />
                          </do_if>
                          <do_else>
                            <!-- strafe left -->
                            <debug_text text="'$NPC is signalling that the ship should strafe left.'" chance="@$DebugChance" />
                            <set_value name="$AnimationType" exact="'marshalling_strafeleft'" />
                            <set_value name="$EndAnimation" exact="'anim_marshal_strafeleft_01'" />
                          </do_else>
                        </do_elseif>

                        <!--#5 Check Z-->
                        <do_elseif value="$AbsoluteZ gt $MaxOffsetPos.z">
                          <!--TODO @Owen new animations for this case-->
                          <do_if value="$RelativePosition.z gt 0">
                            <!-- move forwards -->
                            <debug_text text="'$NPC is signalling that ship should move forwards'" chance="@$DebugChance" />
                            <set_value name="$AnimationType" exact="'marshalling_straightahead'" />
                            <set_value name="$EndAnimation" exact="'anim_marshal_straightahead_01'" />
                          </do_if>
                          <do_else>
                            <!-- move backwards -->
                            <debug_text text="'$NPC is signalling that ship should move backwards'" chance="@$DebugChance" />
                            <set_value name="$AnimationType" exact="'marshalling_identifygate'" />
                            <set_value name="$EndAnimation" exact="'anim_marshal_identifygate_01'" />
                          </do_else>
                        </do_elseif>

                        <!--#6 Check Y-->
                        <do_elseif value="$AbsoluteY gt $MaxOffsetPos.y">
                          <do_if value="$RelativePosition.y gt 0">
                            <!-- strafe up -->
                            <debug_text text="'$NPC is signalling that the ship should move up.'" chance="@$DebugChance" />
                            <set_value name="$AnimationType" exact="'marshalling_moveup'" />
                            <set_value name="$EndAnimation" exact="'anim_marshal_moveup_01'" />
                          </do_if>
                          <do_else>
                            <!-- strafe down -->
                            <debug_text text="'$NPC is signalling that the ship should move down.'" chance="@$DebugChance" />
                            <set_value name="$AnimationType" exact="'marshalling_movedown'" />
                            <set_value name="$EndAnimation" exact="'anim_marshal_movedown_01'" />
                          </do_else>
                        </do_elseif>
                        <do_else>
                          <debug_text text="'$NPC is signalling that the ship should land.'" chance="@$DebugChance" />
                          <set_value name="$AnimationType" exact="'marshalling_land'" />
                          <set_value name="$EndAnimation" exact="'anim_marshal_land_01'" />
                          <set_value name="$NextAirmarshalState" exact="STATE_airmarshal_dispatch"/>
                        </do_else>

                        <set_value name="$AnimationStarted" exact="false"/>
                        <do_if value="$AnimationType and $EndAnimation">
                          <!-- Trigger the right animation on the NPC -->
                          <start_actor_sequence actor="$NPC" type="$AnimationType" behavior="'generic'" transition="true" result="$AnimationStarted" />
                        </do_if>

                        <do_if value="not $AnimationStarted">
                          <debug_text text="'Unable to start ' + $AnimationType + ' animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPC.attention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                        <remove_value name="$AnimationStarted"/>
                        <remove_value name="$MaxOffsetRot"/>
                        <remove_value name="$MaxOffsetPos"/>
                        <remove_value name="$RelativePosition"/>
                        <remove_value name="$RelativeRotation"/>
                        <remove_value name="$AbsoluteYaw"/>
                        <remove_value name="$AbsolutePitch"/>
                        <remove_value name="$AbsoluteRoll"/>
                        <remove_value name="$AbsoluteX"/>
                        <remove_value name="$AbsoluteY"/>
                        <remove_value name="$AbsoluteZ"/>
                        <remove_value name="$AbsoluteZ"/>
                      </do_else>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_dock_v2">
                  <conditions>
                    <event_cue_signalled cue="parent"/>
                    <check_value value="@event.param == 'exit'"/>
                  </conditions>
                  <actions>
                    <remove_value name="$AssignedShip"/>
                    <remove_value name="$AnimationType"/>
                    <remove_value name="$EndAnimation"/>
                    <remove_value name="$NextAirmarshalState"/>
                  </actions>
                </cue>

                <!-- Transitions-->
                <cue name="TRANSITION_airmarshal_dock_animation_finished">
                  <conditions>
                    <event_character_animation_finished object="$NPC"/>
                    <check_value value="@$NextAirmarshalState and (not @$EndAnimation or event.param == $EndAnimation)"/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="$NextAirmarshalState"/>
                    <remove_value name="$NextAirmarshalState"/>
                  </actions>
                </cue>

                <!-- Sub-States -->

                <cue name="STATE_airmarshal_dispatch">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_dispatch">
                      <actions>
                        <debug_text text="'$NPC is dispatching the ship'" chance="@$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_dispatch'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_dispatch animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_dispatch" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_dispatch_standby" instantiate="true">
                      <conditions>
                        <event_character_animation_started object="$NPC" id="'anim_marshal_dispatch_01'" />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_standby" />
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_undock">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
                <set_value name="$AssignedShip" exact="null" />
                <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                  <set_value name="$AssignedShip" exact="$NPC.$airmarshal_dockingbay.assignedship" />
                </do_if>
              </actions>
              <cues>
                <!-- Enter / Exit actions -->
                <cue name="ENTER_airmarshal_undock">
                  <actions>
                    <do_if value="not $NPC.hasbody">
                      <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="1s" />
                    </do_if>
                    <do_elseif value="not $AssignedShip">
                      <start_actor_sequence actor="$NPC" type="'marshalling_end'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                      <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="10s" />
                    </do_elseif>
                    <do_else>
                      <debug_text text="'$NPC is signalling undocking procedure'" chance="@$DebugChance" />
                      <start_actor_sequence actor="$NPC" type="'marshalling_startengines'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                      <do_if value="not this.$animationstarted">
                        <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                        <set_value name="$NpcLocation" exact="$NPC.container" />
                        <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                        <set_value name="$NPCAttention" exact="$NPC.attention" />

                        <set_value name="$PlayerLocation" exact="player.container" />
                        <do_if value="player.container.isclass.station">
                          <set_value name="$PlayerOnStation" exact="'is on'" />
                        </do_if>
                        <do_else>
                          <set_value name="$PlayerOnStation" exact="'is not on'" />
                        </do_else>

                        <debug_text text="'Unable to start marshalling_hover animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                      </do_if>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_undock" ref="EXIT_Empty" />

                <!-- Transitions -->
                <cue name="TRANSITION_airmarshal_undock_moveup" instantiate="true">
                  <conditions>
                    <event_character_animation_finished object="$NPC" id="'anim_marshal_startengines_01'" />
                  </conditions>
                  <actions>
                    <debug_text text="'TRANSITION FROM UNDOCK TO MOVEUP'" chance="@$DebugChance" />
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moveup" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_undock_standby" instantiate="true">
                  <conditions>
                    <event_object_undocked_from container="$NPC.container" />
                    <check_value value="event.param" exact="$AssignedShip" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_standby" />
                  </actions>
                </cue>

                <!-- Sub-states -->
                <cue name="STATE_airmarshal_moveup">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                    <set_value name="$AssignedShip" exact="null" />
                    <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                      <set_value name="$AssignedShip" exact="$NPC.$airmarshal_dockingbay.assignedship" />
                    </do_if>
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_moveup">
                      <actions>
                        <do_if value="not $NPC.hasbody">
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="1s" />
                        </do_if>
                        <do_elseif value="not $AssignedShip">
                          <start_actor_sequence actor="$NPC" type="'marshalling_end'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="10s" />
                        </do_elseif>
                        <do_else>
                          <debug_text text="'$NPC is signalling that the ship should move up.'" chance="@$DebugChance" />
                          <start_actor_sequence actor="$NPC" type="'marshalling_moveup'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                          <do_if value="not this.$animationstarted">
                            <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                            <set_value name="$NpcLocation" exact="$NPC.container" />
                            <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                            <set_value name="$NPCAttention" exact="$NPC.attention" />

                            <set_value name="$PlayerLocation" exact="player.container" />
                            <do_if value="player.container.isclass.station">
                              <set_value name="$PlayerOnStation" exact="'is on'" />
                            </do_if>
                            <do_else>
                              <set_value name="$PlayerOnStation" exact="'is not on'" />
                            </do_else>

                            <debug_text text="'Unable to start marshalling_moveup animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                          </do_if>
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_moveup" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_moveup_undock" instantiate="true">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_moveup_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'TRANSITION FROM LAND TO STANDBY'" chance="@$DebugChance" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moveup" />
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_leave">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_airmarshal_leave">
                  <actions>
                    <do_all chance="@$DebugChance">
                      <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                    </do_all>
                    <remove_value name="$NPC.$airmarshal_dockingbay"/>

                    <debug_text text="'$NPC wants to go back to idling'" chance="@$DebugChance" />
                    <do_if value="$NPC.hasbody">
                      <start_actor_sequence actor="$NPC" type="'marshalling_end'" behavior="'generic'" transition="true" result="this.$animationstarted"/>
                      <do_if value="not this.$animationstarted">
                        <do_all chance="@$DebugChance">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_end animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station. - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                        </do_all>
                        <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                      </do_if>
                      <!--Else, state change via TRANSITION_airmarshal_leave_reinit when animation ends-->
                    </do_if>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_leave" ref="EXIT_Empty"/>

                <cue name="TRANSITION_airmarshal_leave_reinit" instantiate="true">
                  <conditions>
                    <event_character_animation_finished object="$NPC" id="'anim_stand_conversation_01'"/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_idle_stay">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!-- Enter / Exit Actions -->
                <cue name="ENTER_airmarshal_idle_stay">
                  <actions>
                    <do_if value="not $NPC.hasbody">
                      <set_value name="$staytime" min="1min" max="2min" />
                    </do_if>
                    <do_else>
                      <do_if value="$staytime?">
                        <set_value name="$staytime" min="5s" max="30s" />
                      </do_if>
                      <do_else>
                        <set_value name="$staytime" min="30s" max="60s" />
                      </do_else>
                    </do_else>
                    <signal_objects object="$NPC" param="'airmarshal_idle_stay__end'" delay="$staytime" />
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_idle_stay" ref="EXIT_Empty" />

                <!-- Transitions -->
                <cue name="TRANSITION_airmarshal_idle_stay_near" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'airmarshal_idle_stay__end'" />
                    <check_value value="$NPC.attention ge attention.nearby" />
                  </conditions>
                  <actions>
                    <include_actions ref="Validate_Usecase_Reservation"/>
                    <do_if value="@$UsecaseCue.exists">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_idle_stay" />
                    </do_if>
                    <do_elseif value="@$NPC.$airmarshal_dockingbay.exists">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_find" />
                    </do_elseif>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_idle_stay_distant" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'airmarshal_idle_stay__end'" />
                    <check_value value="$NPC.attention lt attention.nearby" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_idle_stay" />
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_roulette_dealer">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_roulette_dealer">
              <actions>
                <set_value name="this.$SuitableSlot" exact="false"/>
                <do_if value="@$NPC.$roulette_dealer_slot.hastag.roulette_dealer">
                  <set_value name="this.$SuitableSlot" exact="true"/>
                </do_if>

                <do_if value="this.$SuitableSlot">
                  <signal_cue_instantly cue="ChangeState" param="STATE_roulette_dealer_find_customers"/>
                </do_if>
                <do_else>
                  <!--No roulette dealer slot defined. Re-init, back to service behaviour-->
                  <remove_value name="$NPC.$roulette_dealer_slot"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_roulette_dealer" ref="EXIT_Empty" />

            <!--Transitions-->

            <!--Sub-states-->
            <cue name="STATE_roulette_dealer_find_customers">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>

                <!-- Enter / Exit Actions -->
                <cue name="ENTER_roulette_dealer_find_customers">
                  <actions>
                    <set_value name="this.$Delay" min="1s" max="2s"/>
                    <set_value name="this.$CurrentPlayers" exact="[]"/>
                    <set_value name="this.$PlayerReady" exact="false"/>
                    <find_npc_slot name="this.$TableSlots" object="$NPC.room" tags="tag.roulette_player" excludefilled="false" multiple="true"/>
                    <do_for_each name="$TableSlot" in="this.$TableSlots" reverse="true">
                      <do_if value="$NPC.$roulette_dealer_slot.group != $TableSlot.group">
                        <remove_from_list name="this.$TableSlots" exact="$TableSlot"/>
                      </do_if>
                    </do_for_each>
                    <set_value name="this.$FreeSlotCount" exact="0"/>
                    <do_if value="this.$TableSlots.count">
                      <do_for_each name="$TableSlot" in="this.$TableSlots">
                        <set_value name="this.$NPCPlayer" exact="$TableSlot.component.slotactor.{$TableSlot}"/>
                        <do_if value="this.$NPCPlayer">
                          <append_to_list name="this.$CurrentPlayers" exact="this.$NPCPlayer"/>
                          <do_if value="not this.$NPCPlayer.isintransit">
                            <set_value name="this.$PlayerReady" exact="true"/>
                          </do_if>
                        </do_if>
                        <do_else>
                          <set_value name="this.$FreeSlotCount" operation="add"/>
                        </do_else>
                      </do_for_each>
                      <do_if value="this.$FreeSlotCount">
                        <set_value name="this.$NearNPCs" exact="[]"/>
                        <set_value name="this.$SearchLocations" exact="[]"/>
                        <debug_text text="'Current number of reserved player slots ' + this.$CurrentPlayers.count" chance="@$DebugChance"/>
                        <!--If there are no players, try to grab some from nearby and in failing that, the whole station. Otherwise only request new players on occasion-->
                        <do_if value="this.$CurrentPlayers.count == 0">
                          <append_to_list name="this.$SearchLocations" exact="$NPC.room"/>
                          <append_to_list name="this.$SearchLocations" exact="$NPC.object"/>
                        </do_if>
                        <do_else>
                          <append_to_list name="this.$SearchLocations" exact="$NPC.object" chance="50"/>
                        </do_else>
                        <do_for_each name="$SearchLocation" in="this.$SearchLocations">
                          <!--TODO @Owen support 'entityrole' lists-->
                          <find_object_component name="this.$NearNPCs" object="$SearchLocation" class="class.npc" entityrole="entityrole.service" multiple="true"/>
                          <find_object_component name="this.$NearNPCs" object="$SearchLocation" class="class.npc" entityrole="entityrole.passenger" multiple="true" append="true"/>
                          <do_for_each name="$NearNPC" in="this.$NearNPCs" reverse="true">
                            <do_if value="(not @$NearNPC.$casual and not @$NearNPC.$station_visitor) or @$NearNPC.$roulette_dealer_slot or @$NearNPC.roomslot.hastag.roulette_player">
                              <remove_from_list name="this.$NearNPCs" exact="$NearNPC"/>
                            </do_if>
                          </do_for_each>
                          <do_if value="this.$NearNPCs.count">
                            <break/>
                          </do_if>
                        </do_for_each>

                        <do_if value="this.$NearNPCs.count">
                          <shuffle_list list="this.$NearNPCs"/>
                          <do_for_each name="$NearNPC" in="this.$NearNPCs">
                            <do_if value="this.$FreeSlotCount == 0">
                              <break/>
                            </do_if>
                            <set_value name="this.$MoveDelay" min="0s" max="2s"/>
                            <debug_text text="'Requesting NPC ' + $NearNPC + ' ' + $NearNPC.knownname + ' to join roulette group ' + $NPC.$roulette_dealer_slot.group" chance="@$DebugChance"/>
                            <signal_objects object="$NearNPC" param="'moveto_roulette'" param2="$NPC"/>
                            <set_value name="this.$FreeSlotCount" operation="subtract"/>
                            <break chance="50"/>
                          </do_for_each>
                          <set_value name="this.$Delay" min="8s" max="10s"/>
                        </do_if>
                      </do_if>
                      <do_if value="this.$CurrentPlayers.count">
                        <do_if value="this.$PlayerReady">
                          <!--A player is ready. After the delay, transition to the game starting-->
                        </do_if>
                        <do_else>
                          <set_value name="this.$Delay" min="4s" max="6s"/>
                        </do_else>
                      </do_if>
                    </do_if>
                  </actions>
                  <delay exact="this.$Delay"/>
                  <actions>
                    <do_if value="this.$PlayerReady">
                      <signal_cue_instantly cue="ChangeState" param="STATE_roulette_dealer_start_game"/>
                    </do_if>
                    <do_else>
                      <!--Check if any players are ready yet-->
                      <reset_cue cue="this"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_roulette_dealer_find_customers" ref="EXIT_Empty" />

                <!-- Transitions -->
              </cues>
            </cue>

            <cue name="STATE_roulette_dealer_start_game">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>

                <!-- Enter / Exit Actions -->
                <cue name="ENTER_roulette_dealer_start_game">
                  <actions>
                    <start_actor_sequence actor="$NPC" type="'busy'" behavior="'stand_terminal_forward'" transition="true" immediate="true" result="this.$animationstarted" chance="if $NPC.hasbody then 100 else 0" />
                  </actions>
                  <delay min="3s" max="4s"/>
                  <actions>
                    <set_value name="this.$CurrentPlayers" exact="[]"/>
                    <find_npc_slot name="this.$TableSlots" object="$NPC.room" tags="tag.roulette_player" excludefilled="false" multiple="true"/>
                    <do_for_each name="$TableSlot" in="this.$TableSlots" reverse="true">
                      <do_if value="$NPC.$roulette_dealer_slot.group != $TableSlot.group">
                        <remove_from_list name="this.$TableSlots" exact="$TableSlot"/>
                      </do_if>
                    </do_for_each>
                    <do_for_each name="$TableSlot" in="this.$TableSlots">
                      <set_value name="this.$NPCPlayer" exact="$TableSlot.component.slotactor.{$TableSlot}"/>
                      <do_if value="this.$NPCPlayer and not this.$NPCPlayer.isintransit">
                        <append_to_list name="this.$CurrentPlayers" exact="this.$NPCPlayer"/>
                      </do_if>
                    </do_for_each>
                    <do_for_each name="$CurrentPlayer" in="this.$CurrentPlayers">
                      <set_value name="this.$NPCDelay" min="0s" max="0.2s"/>
                      <signal_objects object="$CurrentPlayer" param="'roulette_start'" param2="$NPC.$roulette_dealer_slot" delay="this.$NPCDelay"/>
                    </do_for_each>
                    <trigger_animation object="$NPC.room" group="$NPC.$roulette_dealer_slot.group" trigger="activate"/>
                  </actions>
                  <delay exact="1s"/>
                  <actions>
                    <start_actor_sequence actor="$NPC" type="'conversation'" behavior="'stand'" transition="true" immediate="false" result="this.$animationstarted" chance="if $NPC.hasbody then 100 else 0" />
                  </actions>
                  <delay min="7s" max="8s"/>
                  <actions>
                    <do_for_each name="$CurrentPlayer" in="this.$CurrentPlayers">
                      <do_if value="@$CurrentPlayer.roomslot.hastag.roulette_player">
                        <set_value name="this.$NPCDelay" min="0s" max="0.2s"/>
                        <do_any>
                          <signal_objects object="$CurrentPlayer" param="'roulette_win'" param2="$NPC.$roulette_dealer_slot" delay="this.$NPCDelay" weight="30"/>
                          <signal_objects object="$CurrentPlayer" param="'roulette_lose'" param2="$NPC.$roulette_dealer_slot" delay="this.$NPCDelay" weight="60"/>
                        </do_any>
                      </do_if>
                    </do_for_each>
                  </actions>
                  <delay exact="6s"/>
                  <actions>
                    <start_actor_sequence actor="$NPC" type="'busy'" behavior="'stand_terminal_forward'" transition="true" immediate="true" result="this.$animationstarted" chance="if $NPC.hasbody then 100 else 0" />
                  </actions>
                  <delay exact="3s"/>
                  <actions>
                    <shuffle_list list="this.$CurrentPlayers"/>
                    <do_for_each name="$CurrentPlayer" in="this.$CurrentPlayers">
                      <do_if value="@$CurrentPlayer.roomslot.hastag.roulette_player">
                        <set_actor_lookat actor="$NPC" component="$CurrentPlayer"/>
                        <break/>
                      </do_if>
                    </do_for_each>
                    <start_actor_sequence actor="$NPC" type="'conversation'" behavior="'stand'" transition="true" immediate="false" result="this.$animationstarted" chance="if $NPC.hasbody then 100 else 0" />
                    <trigger_animation object="$NPC.room" group="$NPC.$roulette_dealer_slot.group" trigger="deactivate"/>
                  </actions>
                  <delay exact="6s"/>
                  <actions>
                    <clear_actor_lookat actor="$NPC"/>
                    <signal_cue_instantly cue="ChangeState" param="STATE_roulette_dealer_find_customers"/>
                  </actions>
                </cue>

                <cue name="EXIT_roulette_dealer_start_game" ref="EXIT_Empty" />

                <!-- Transitions -->
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_prisoner">
          <conditions>
            <event_cue_signalled />
            <check_value value="not @event.param" />
          </conditions>
          <actions>
            <include_actions ref="Init_State" />
          </actions>
          <cues>
            <!-- Enter / Exit actions -->
            <cue name="EXIT_prisoner" ref="EXIT_Empty" />

            <!-- Transitions -->

            <!--event.param2 = table[
            $slot = Target slot (optional),
            $movementspeed = Movement speed (optional)]-->
            <cue name="TRANSITION_prisoner_escape" instantiate="true">
              <conditions>
                <event_object_signalled object="$NPC"/>
                <check_any>
                  <check_value value="event.param == 'escape_prison'"/>
                  <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <set_value name="STATE_despawn.$ParamTable" exact="event.param2"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
                </do_if>
                <do_else>
                  <debug_text text="'$AssignedShip has undocked from station - requesting queued state change to undock state'" chance="@$DebugChance" />
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_trader">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="EXIT_trader" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_marine_guard">
          <conditions>
            <event_cue_signalled />
            <check_value value="not @event.param" />
          </conditions>
          <actions>
            <include_actions ref="Init_State" />
          </actions>
          <cues>
            <!-- Enter / Exit Actions -->
            <cue name="Enter_marine_guard">
              <actions>
                <do_if value="not $NPC.roleobject">
                  <do_if value="$NPC.controllable.people.{$NPC.npctemplate}.exists">
                    <set_entity_role_object entity="$NPC" object="$NPC.controllable"/>
                  </do_if>
                </do_if>
                <assert value="$NPC.role" text="'Entity does not have a role in this NPC state'" />
                <do_if value="$NPC.roleobject.exists">
                  <debug_text text="'$NPC.controllable ' + $NPC.controllable + '$NPC.roleobject ' + $NPC.roleobject" chance="@$DebugChance" />
                  <do_if value="$NPC.controllable == $NPC.roleobject">
                    <do_if value="$NPC.roomslot and $NPC.roomslot.hastag.{$NPC.role.tag}">
                      <signal_cue_instantly cue="ChangeState" param="STATE_marine_guard_stay" />
                    </do_if>
                    <do_else>
                      <find_npc_slot name="$destinationslot" object="$NPC.roleobject" role="$NPC.role" />
                      <do_if value="$destinationslot">
                        <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment" />
                      </do_if>
                      <do_elseif value="$NPC.roleobject.isclass.station">
                        <!--Currently no marine slots on station docks, so have them stay where they are-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_marine_guard_stay" />
                      </do_elseif>
                      <do_else>
                        <!-- No available room slot, despawn -->
                        <signal_cue_instantly cue="ChangeState" param="STATE_despawn" />
                      </do_else>
                    </do_else>
                  </do_if>
                  <do_else>
                    <!-- Not on-board object -->
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment" />
                  </do_else>
                </do_if>
                <do_else>
                  <assert value="$NPC.roleobject.exists" text="'Entity does not know what object it has a role for. It is on board controllable ' + $NPC.controllable + ' ' + @NPC.controllable.knownname" />
                  <destroy_object object="$NPC" />
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_marine_guard">
              <conditions>
                <event_cue_signalled cue="parent" />
                <check_value value="@event.param == 'exit'" />
              </conditions>
              <actions>
                <do_if value="$staytime?">
                  <remove_value name="$staytime" />
                </do_if>
              </actions>
            </cue>

            <!-- Sub-states -->
            <cue name="STATE_marine_guard_stay">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!--Allow usecases
                If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                <cue name="USECASE_CHECK_marine_guard_stay" instantiate="true">
                  <conditions>
                    <event_cue_signalled cue="parent"/>
                    <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                  </conditions>
                  <actions>
                    <include_actions ref="Allow_Usecase"/>
                  </actions>
                </cue>

                <!-- Enter / Exit Actions -->
                <cue name="ENTER_marine_guard_stay">
                  <actions>
                    <do_if value="not $NPC.hasbody">
                      <set_value name="$staytime" min="1min" max="2min" />
                    </do_if>
                    <do_else>
                      <do_if value="$staytime?">
                        <set_value name="$staytime" min="5s" max="30s" />
                      </do_if>
                      <do_else>
                        <set_value name="$staytime" min="30s" max="60s" />
                      </do_else>
                    </do_else>
                    <signal_objects object="$NPC" param="'marine_guard_stay__end'" delay="$staytime" />
                  </actions>
                </cue>

                <cue name="EXIT_marine_guard_stay" ref="EXIT_Empty" />

                <!-- Transitions -->
                <cue name="TRANSITION_marine_guard_stay_near" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'marine_guard_stay__end'" />
                    <check_value value="$NPC.attention ge attention.nearby" />
                  </conditions>
                  <actions>
                    <include_actions ref="Validate_Usecase_Reservation"/>
                    <do_if value="@$UsecaseCue.exists">
                      <signal_cue_instantly cue="ChangeState" param="STATE_marine_guard_stay" />
                    </do_if>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment" />
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_marine_guard_stay_distant" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'marine_guard_stay__end'" />
                    <check_value value="$NPC.attention lt attention.nearby" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_marine_guard_stay" />
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_dockarea_movement_test">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_dockarea_movement_test">
              <actions>
                <signal_cue_instantly cue="ChangeState" param="STATE_dockarea_movement_test_stay"/>
              </actions>
            </cue>

            <cue name="EXIT_dockarea_movement_test">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <do_if value="$staytime?">
                  <remove_value name="$staytime"/>
                </do_if>
              </actions>
            </cue>

            <!--Sub-states-->
            <cue name="STATE_dockarea_movement_test_stay">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_dockarea_movement_test_stay">
                  <actions>
                    <set_value name="$staytime" exact="1s"/>
                  </actions>
                  <cues>
                    <cue name="ENTER_dockarea_movement_test_stay_interrupt">
                      <delay exact="$staytime"/>
                      <actions>
                        <signal_objects object="$NPC" param="'dockarea_movement_test_stay__end'"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="EXIT_dockarea_movement_test_stay" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_dockarea_movement_test_attempt_move">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'dockarea_movement_test_stay__end'"/>
                  </conditions>
                  <delay exact="10ms"/>
                  <actions>
                    <do_if value="$ProblematicSlot?">
                      <debug_text text="'NPC ' + $NPC"/>
                      <debug_text text="player.age + ' Testing movement to ' + $ProblematicSlot"/>
                      <do_if value="$NPC.roomslot">
                        <debug_text text="'start: ' + $NPC.roomslot + ' ' + $NPC.roomslot.component.knownname"/>
                      </do_if>
                      <do_else>
                        <debug_text text="'start: room ' + $NPC.parent + ' ' + $NPC.parent.knownname"/>
                      </do_else>
                      <debug_text text="'end: ' + $ProblematicSlot + ' ' + $ProblematicSlot.component.knownname"/>
                      <set_value name="this.$destinationslot" exact="$ProblematicSlot"/>
                      <!--<include_actions ref="GetNextTargetPoint"/>-->
                      <check_walk_path actor="$NPC" end="$ProblematicSlot" result="$WalkResult"/>
                      <do_if value="$WalkResult">
                        <debug_text text="'it finally worked'"/>
                      </do_if>
                      <do_else>
                        <debug_text text="'it still failed'"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <!-- set_value name="$DebugChance" exact="100"/ -->
                      <!--TODO @Owen find out why .dockarea isn't working in some cases-->
                      <set_value name="$DockArea" exact="null"/>
                      <set_value name="$Parent" exact="$NPC.parent"/>
                      <do_while value="$Parent">
                        <do_if value="$Parent.isclass.walkablemodule">
                          <set_value name="$DockArea" exact="$Parent"/>
                          <break/>
                        </do_if>
                        <set_value name="$Parent" exact="$Parent.parent"/>
                      </do_while>

                      <do_if value="$DockArea">
                        <find_dockingbay name="$DockingBays" object="$DockArea" multiple="true">
                          <match_dock storage="false" size="tag.dock_s" walkable="true"/>
                        </find_dockingbay>

                        <create_group groupname="this.$Ships"/>
                        <do_all exact="$DockingBays.count" counter="$i">
                          <debug_text text="'dock ' + $DockingBays.{$i}"/>
                          <do_if value="$DockingBays.{$i}.assignedship">
                            <add_to_group object="$DockingBays.{$i}.assignedship" groupname="this.$Ships"/>
                          </do_if>
                        </do_all>
                        <debug_text text="'ships ' + this.$Ships.count"/>
                        <set_value name="$ShipBackroomSlots" exact="[]"/>
                        <do_all exact="this.$Ships.count" counter="$i">
                          <find_npc_waypoint name="$ShipBackroomSlots" append="true" object="this.$Ships.{$i}" tags="tag.npctransport" multiple="true"/>
                        </do_all>
                        <find_npc_slot name="$DockAreaSlots" object="$DockArea" multiple="true"/>

                        <debug_text text="'Found ' + $ShipBackroomSlots.count + ' ship backroom waypoint slots'"/>
                        <debug_text text="'Found ' + $DockAreaSlots.count + ' dock area slots'"/>

                        <shuffle_list list="$ShipBackroomSlots"/>
                        <shuffle_list list="$DockAreaSlots"/>

                        <do_any>
                          <do_all>
                            <set_value name="$FirstList" exact="$ShipBackroomSlots"/>
                            <set_value name="$SecondList" exact="$DockAreaSlots"/>
                          </do_all>
                          <do_all>
                            <set_value name="$FirstList" exact="$DockAreaSlots"/>
                            <set_value name="$SecondList" exact="$ShipBackroomSlots"/>
                          </do_all>
                        </do_any>

                        <do_all exact="2" counter="$i">
                          <do_if value="$i == 1">
                            <set_value name="$List" exact="$FirstList"/>
                          </do_if>
                          <do_else>
                            <set_value name="$List" exact="$SecondList"/>
                          </do_else>

                          <do_all exact="$List.count" counter="$k">
                            <set_value name="this.$destinationslot" exact="$List.{$k}"/>
                            <do_if value="this.$destinationslot and not this.$destinationslot.hastag.airmarshal">
                              <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                                <param name="NPC" value="$NPC"/>
                                <param name="DestinationSlot" value="this.$destinationslot"/>
                                <param name="DebugChance" value="@$DebugChance"/>
                              </run_actions>
                              <do_if value="this.$pathtable">
                                <!--Clear and try the next one-->
                                <remove_value name="this.$pathtable"/>
                              </do_if>
                              <do_else>
                                <!--<assert value="false" text="player.age + ' Unable to find path from ' + (if $NPC.roomslot then $NPC.roomslot else $NPC.parent) + ' to destinationslot ' + this.$destinationslot + ' - NPC ' + $NPC + ' will repeat again and for debugging'" break="always"/>-->
                                <set_value name="$ProblematicSlot" exact="this.$destinationslot"/>
                                <run_actions result="this.$pathtable" ref="GetNextTargetPoint_ToSlot">
                                  <param name="NPC" value="$NPC"/>
                                  <param name="DestinationSlot" value="$ProblematicSlot"/>
                                  <param name="DebugChance" value="@$DebugChance"/>
                                </run_actions>
                                <!--Turning off output to save on state change spam-->
                                <set_value name="$DebugChance" exact="0"/>
                                <break/>
                              </do_else>
                            </do_if>
                          </do_all>
                        </do_all>

                        <do_if value="not $ProblematicSlot?">
                          <do_if value="$ShipBackroomSlots.count and $DockAreaSlots.count">
                            <do_any>
                              <set_value name="this.$NewSlot" exact="$ShipBackroomSlots.random"/>
                              <set_value name="this.$NewSlot" exact="$DockAreaSlots.random"/>
                            </do_any>
                          </do_if>
                          <do_elseif value="$ShipBackroomSlots.count">
                            <set_value name="this.$NewSlot" exact="$ShipBackroomSlots.random"/>
                          </do_elseif>
                          <do_elseif value="$DockAreaSlots.count">
                            <set_value name="this.$NewSlot" exact="$DockAreaSlots.random"/>
                          </do_elseif>

                          <debug_text text="'Warping NPC to new slot to try again. ' + this.$NewSlot"/>

                          <do_if value="this.$NewSlot">
                            <add_actor_to_room actor="$NPC" slot="this.$NewSlot"/>
                          </do_if>
                        </do_if>
                      </do_if>
                    </do_else>

                    <signal_cue_instantly cue="ChangeState" param="STATE_dockarea_movement_test"/>

                    <!--Standard tranition exit handling-->
                    <include_actions ref="Transition_Exit"/>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>


        <!--
        ##################
        Libraries
        ##################-->

        <!--Library to initialise a state, adding it to the $ActiveStates list and processing any queued transtion requests which may ultimatly result in ending this state-->
        <library name="Init_State">
          <actions>
            <append_to_list name="$ActiveStates" exact="this"/>
            <debug_text text="'Activated state ' + this" chance="@$DebugChance"/>
            <debug_text text="'Currently active states are: ' + $ActiveStates" chance="@$DebugChance"/>

            <!--If there is a request waiting, prepare to process it. The running state may request another state change, which may be ignored if non-critical and another request is waiting after a critical state-->
            <do_if value="@$QueuedTransitionRequests.count">
              <signal_cue_instantly cue="QueuedStateChangeTrigger"/>
            </do_if>
          </actions>
        </library>

        <!--Library run when a state is initialising, marking it as a state which can allow a usecase to take this NPC.-->
        <library name="Allow_Usecase">
          <actions>
            <set_value name="parent.$AllowUsecaseReservation"/>
          </actions>
        </library>

        <!--Cue to signal to disallow usecase interrupts for a certain staterun when a state is initialising, marking it as a state which can allow a usecase to take this NPC.-->
        <library name="Disallow_Usecase">
          <actions>
            <set_value name="parent.$AllowUsecaseReservation" exact="false"/>
          </actions>
        </library>

        <library name="EXIT_Empty">
          <conditions>
            <event_cue_signalled cue="parent"/>
            <check_value value="@event.param == 'exit'"/>
          </conditions>
          <!--This doesn't do anything but currently helps keep STATE_ cues alive, as they would be cleaned up if they had no waiting sub-cues-->
        </library>

        <library name="State_Exit_Actions">
          <actions>
            <reset_cue cue="parent"/>
          </actions>
        </library>

        <library name="Transition_Exit">
          <actions>
            <!--No state change was requested. Reset this transition-->
            <do_if value="ChangeState.state == cuestate.waiting">
              <reset_cue cue="this"/>
            </do_if>
          </actions>
        </library>

        <!--If NPC is currently hidden, this.$startslot will be set, to be used as the spawning location-->
        <library name="CheckStartLocation" purpose="run_actions">
          <params>
            <param name="NPC"/>
            <!--TODO @Owen - Destination position for non-slot cases-->
            <param name="DestinationSlot" default="null"/>
            <param name="DebugChance" default="0"/>
          </params>
          <actions>
            <set_value name="$ResultSlot" exact="null"/>
            <do_if value="$NPC.ishidden">
              <debug_text text="'NPC is hidden. Finding a slot to have them appear at.'" chance="@$DebugChance"/>
              <do_if value="$DestinationSlot and (if $DestinationSlot.component.isclass.object then $DestinationSlot.component else $DestinationSlot.component.object) != $NPC.object
                     and not (if $DestinationSlot.component.isclass.object then $DestinationSlot.component else $DestinationSlot.component.object).commoncontext.{$NPC}.isclass.space">
                <debug_text text="'NPC destination is on another object that may be reachable by walking. Look for an exit transporter.'" chance="@$DebugChance"/>

                <find_npc_waypoint name="$StartSlots" object="$NPC.room" tags="tag.npc_location_exit" multiple="true"/>
                <remove_from_list name="$StartSlots" exact="$DestinationSlot"/>
                <do_if value="$StartSlots.count">
                  <set_value name="$ResultSlot" exact="$StartSlots.random"/>
                  <debug_text text="$ResultSlot + ' was selected as the start slot'" chance="@$DebugChance"/>
                  <return value="$StartSlots.random"/>
                </do_if>
              </do_if>

              <find_npc_waypoint name="$StartSlots" object="$NPC.room" tags="tag.npctransport" multiple="true"/>
              <debug_text text="'potential room startslots ' + $StartSlots" chance="@$DebugChance"/>
              <do_if value="$DestinationSlot">
                <remove_from_list name="$StartSlots" exact="$DestinationSlot"/>
              </do_if>

              <do_if value="not $StartSlots.count">
                <find_npc_waypoint name="$StartSlots" object="$NPC.container" tags="tag.npctransport" multiple="true"/>
                <debug_text text="'potential object [' + $NPC.container + '] startslots ' + $StartSlots" chance="@$DebugChance"/>
                <do_if value="$DestinationSlot">
                  <remove_from_list name="$StartSlots" exact="$DestinationSlot"/>
                </do_if>
              </do_if>
              <do_if value="$StartSlots.count">
                <do_if value="$DestinationSlot">
                  <sort_list list="$StartSlots" sortbyvalue="$DestinationSlot.distanceto.{loop.element}" sortdescending="false"/>
                </do_if>
                <do_else>
                  <sort_list list="$StartSlots" sortbyvalue="$NPC.distanceto.{loop.element}" sortdescending="false"/>
                </do_else>
                <set_value name="$ResultSlot" exact="$StartSlots.{1}"/>
              </do_if>
              <debug_text text="$ResultSlot + ' was selected as the start slot'" chance="@$DebugChance"/>
            </do_if>
            <return value="$ResultSlot"/>
          </actions>
        </library>

        <!--result saved to this.$destinationslot-->
        <library name="FindLocalDespawnLocation">
          <actions>
            <find_npc_waypoint name="this.$destinationslot" object="$NPC.room" tags="tag.npctransport"/>
            <do_if value="not this.$destinationslot">
              <find_npc_waypoint name="this.$destinationslots" object="$NPC.container" tags="tag.npctransport" multiple="true"/>
              <do_if value="this.$destinationslots.count">
                <do_all exact="this.$destinationslots.count" counter="$destslotscounter">
                  <check_walk_path actor="$NPC" end="this.$destinationslots.{$destslotscounter}" result="$walkresult" checkstate="false"/>
                  <do_if value="$walkresult">
                    <set_value name="this.$destinationslot" exact="this.$destinationslots.{$destslotscounter}"/>
                    <break/>
                  </do_if>
                </do_all>
                <do_if value="not this.$destinationslot">
                  <set_value name="this.$destinationslot" exact="this.$destinationslots.random"/>
                </do_if>
              </do_if>
            </do_if>
            <do_if value="not this.$destinationslot">
              <debug_text text="'unable to find a place to despawn ' + $NPC + ' ' + $NPC.knownname" filter="error"/>
              <find_npc_slot name="this.$destinationslot" object="$NPC.room" tags="tag.npc_generic"/>
            </do_if>
          </actions>
        </library>

        <library name="MoveFailedHandling_ToSlot" purpose="run_actions">
          <params>
            <param name="NPC"/>
            <param name="DestinationSlot"/>
            <param name="DestinationOffset" default="null"/>
            <param name="DestinationRotation" default="null"/>

            <param name="DebugChance" default="0"/>
          </params>
          <actions>
            <debug_text text="player.age + ' Unable to find path from ' + (if $NPC.roomslot then $NPC.roomslot else $NPC.parent) + ' to destinationslot ' + $DestinationSlot + ' - NPC will disappear instantly.'" filter="error" chance="@$DebugChance"/>

            <!--Uncomment below line with DebugChange at 100 for a repeat attempt at pathing with output-->
            <!--<include_actions ref="GetNextTargetPoint"/>-->

            <do_if value="not $DestinationSlot.hastag.npc">
              <clear_actor_roomslot actor="$NPC"/>
            </do_if>
            <set_entity_traits entity="$NPC" hidden="$DestinationSlot.hastag.npctransport" intransit="false"/>

            <!--TODO @Owen @Klaus Allow passing in null values for positions and rotations-->
            <do_if value="$DestinationOffset and $DestinationRotation">
              <add_actor_to_room actor="$NPC" slot="$DestinationSlot">
                <position value="$DestinationOffset"/>
                <rotation value="$DestinationRotation"/>
              </add_actor_to_room>
            </do_if>
            <do_elseif value="$DestinationOffset">
              <add_actor_to_room actor="$NPC" slot="$DestinationSlot">
                <position value="$DestinationOffset"/>
              </add_actor_to_room>
            </do_elseif>
            <do_elseif value="$DestinationRotation">
              <add_actor_to_room actor="$NPC" slot="$DestinationSlot">
                <rotation value="$DestinationRotation"/>
              </add_actor_to_room>
            </do_elseif>
            <do_else>
              <add_actor_to_room actor="$NPC" slot="$DestinationSlot"/>
            </do_else>

            <do_if value="$DestinationSlot.component.ischairslot.{$DestinationSlot}">
              <animate_chair slot="$DestinationSlot" actor="$NPC" chairtrigger="activate_chair"/>
            </do_if>

            <do_if value="$NPC.podarrivaltime">
              <clear_actor_pod_arrival_time actor="$NPC"/>
            </do_if>
          </actions>
        </library>

        <library name="MoveFailedHandling_ToPosition" purpose="run_actions">
          <params>
            <param name="NPC"/>
            <param name="DestinationContext"/>
            <param name="DestinationContextRoom"/>
            <param name="DestinationOffset"/>
            <param name="DestinationRotation" default="null"/>

            <param name="DebugChance" default="0"/>
          </params>
          <actions>
            <debug_text text="player.age + ' Unable to find path from ' + (if $NPC.roomslot then $NPC.roomslot else $NPC.parent) + ' to destination ' + $DestinationContext + ' ' + $DestinationOffset + ' - NPC will disappear instantly.'" filter="error" chance="@$DebugChance"/>

            <!--Uncomment below line with DebugChange at 100 for a repeat attempt at pathing with output-->
            <!--<include_actions ref="GetNextTargetPoint"/>-->

            <clear_actor_roomslot actor="$NPC"/>
            <set_entity_traits entity="$NPC" hidden="false" intransit="false"/>

            <!--Warp to $destinationcontextroom at position $destinationoffset in coordinate space $destinationcontext-->
            <do_if value="$DestinationRotation">
              <add_actor_to_room actor="$NPC" object="$DestinationContextRoom">
                <position value="$DestinationOffset" object="$DestinationContext" space="$DestinationContextRoom"/>
                <rotation value="$DestinationRotation"/>
              </add_actor_to_room>
            </do_if>
            <do_else>
              <add_actor_to_room actor="$NPC" object="$DestinationContextRoom">
                <position value="$DestinationOffset" object="$DestinationContext" space="$DestinationContextRoom"/>
              </add_actor_to_room>
            </do_else>

            <do_if value="$NPC.podarrivaltime">
              <clear_actor_pod_arrival_time actor="$NPC"/>
            </do_if>
          </actions>
        </library>

        <!--TODO @Owen recognise ships docked in storage. Walk to elevator to despawn-->

        <library name="GetNextTargetPoint_ToSlot" purpose="run_actions">
          <params>
            <param name="NPC"/>
            <param name="StartSlot" default="null"/>
            <param name="AnimateAtEnd" default="true"/>

            <param name="DestinationSlot"/>
            <param name="DestinationOffset" default="null"/>
            <param name="DestinationRotation" default="null"/>
            <param name="DestinationTags" default="null" comment="List of floor tags at the destination position"/>

            <param name="DebugChance" default="0"/>
          </params>
          <actions>
            <!--Initialise some values just to simplify GetNextTargetPoint-->
            <set_value name="$DestinationContext" exact="null"/>
            <set_value name="$DestinationContextRoom" exact="null"/>
            <include_actions ref="GetNextTargetPoint"/>
            <do_if value="$PathTable">
              <!--Add destination info to the path table-->
              <set_value name="$PathTable.$destinationslot"             exact="$DestinationSlot"/>
              <set_value name="$PathTable.$destinationoffset"           exact="$DestinationOffset"/>
              <set_value name="$PathTable.$destinationrotation"         exact="$DestinationRotation"/>
              <set_value name="$PathTable.$destinationtags"             exact="$DestinationTags"/>
            </do_if>
            <return value="$PathTable"/>
          </actions>
        </library>

        <library name="GetNextTargetPoint_ToPosition" purpose="run_actions">
          <params>
            <param name="NPC"/>
            <param name="StartSlot" default="null"/>
            <param name="AnimateAtEnd" default="true"/>

            <param name="DestinationContext"/>
            <param name="DestinationContextRoom"/>
            <param name="DestinationOffset"/>
            <param name="DestinationRotation" default="null"/>
            <param name="DestinationTags" default="null" comment="List of floor tags at the destination position"/>

            <param name="DebugChance" default="0"/>
          </params>
          <actions>
            <!--Initialise some values just to simplify GetNextTargetPoint-->
            <set_value name="$DestinationSlot" exact="null"/>
            <include_actions ref="GetNextTargetPoint"/>
            <do_if value="$PathTable">
              <!--Add destination info to the path table-->
              <set_value name="$PathTable.$destinationcontext"          exact="$DestinationContext"/>
              <set_value name="$PathTable.$destinationcontextroom"      exact="$DestinationContextRoom"/>
              <set_value name="$PathTable.$destinationoffset"           exact="$DestinationOffset"/>
              <set_value name="$PathTable.$destinationrotation"         exact="$DestinationRotation"/>
              <set_value name="$PathTable.$destinationtags"             exact="$DestinationTags"/>
            </do_if>
            <return value="$PathTable"/>
          </actions>
        </library>

        <!--INTERNAL USE ONLY-->
        <library name="GetNextTargetPoint">
          <actions>
            <do_if value="$StartSlot">
              <debug_text text="'already have a $StartSlot which is ' + $StartSlot" chance="@$DebugChance"/>
            </do_if>
            <do_else>
              <run_actions ref="CheckStartLocation" result="$StartSlot">
                <param name="NPC" value="$NPC"/>
                <param name="DestinationSlot" value="$DestinationSlot"/>
                <param name="DebugChance" value="@$DebugChance"/>
              </run_actions>
              <debug_text text="'Was not provided with $StartSlot. Searched for one and found ' + $StartSlot" chance="@$DebugChance"/>
            </do_else>

            <set_value name="$PathTable" exact="null"/>
            <set_value name="$LocalWaypointTagList" exact="[tag.npctransport, tag.ladder_top, tag.ladder_bottom, tag.elevator_wait_top, tag.elevator_bottom]"/>
            <set_value name="$LocalEntrypointTagList" exact="[tag.npc_location_exit, tag.ladder_bottom, tag.elevator_bottom]"/>
            <set_value name="$LocalWaypointCache" exact="table[]"/>
            <!--Validate parameter types-->
            <do_if value="$DestinationOffset and typeof $DestinationOffset != datatype.position">
              <debug_text text="'Invalid position value $DestinationOffset ' + $DestinationOffset + ' - setting to null'" filter="error"/>
              <set_value name="$DestinationOffset" exact="null"/>
            </do_if>

            <do_if value="$DestinationRotation and typeof $DestinationRotation != datatype.rotation">
              <debug_text text="'Invalid rotation value $DestinationRotation ' + $DestinationRotation + ' - setting to null'" filter="error"/>
              <set_value name="$DestinationRotation" exact="null"/>
            </do_if>

            <do_if value="$DestinationTags and typeof $DestinationTags != datatype.list">
              <debug_text text="'Invalid destinationtags value $DestinationTags ' + $DestinationTags + ' - setting to null'" filter="error"/>
              <set_value name="$DestinationTags" exact="null"/>
            </do_if>
            <!--Validate that $DestinationContext exists and is provided with $DestinationOffset and $DestinationContextRoom, or $DestinationSlot was provided-->
            <do_if value="$DestinationContext.exists and $DestinationOffset and $DestinationContextRoom.exists">
              <assert value="not $DestinationSlot" text="'destination slot ' + $DestinationSlot + ' was provided along with a context offset, clearing [Owen]'"/>
              <set_value name="$DestinationSlot" exact="null"/>
            </do_if>
            <do_else>
              <set_value name="$DestinationContext" exact="null"/>
              <set_value name="$DestinationContextRoom" exact="null"/>
            </do_else>
            <assert value="$DestinationSlot or $DestinationContext" text="'destination is neither a slot nor a position [Owen]'"/>
            <assert value="not @$DestinationSlot.component.ischairslot.{$DestinationSlot} or not $DestinationOffset" text="'Attempting to walk to a chair slot with an additional offset. Will probably interfere with the approach position, so ignoring. [Owen]'"/>
            <!--TODO @Owen look into this assert firing-->
            <!--<assert value="($DestinationSlot.hastag.airmarshal != 0) == @$NPC.$airmarshal_dockingbay.exists" text="'non-airmarshal NPC trying to walk to airmarshal slot.'"/>-->
            <debug_text text="'NPC room is ' + $NPC.room + ' ' + $NPC.room.knownname + ' - Pos: ' + $NPC.position" chance="@$DebugChance"/>
            <do_if value="$DestinationSlot or $DestinationContext">
              <!--$ResolvedDestinationContext is a helper variable which is either $DestinationContext or the component of $DestinationSlot-->
              <set_value name="$ResolvedDestinationContext" exact="null"/>
              <set_value name="$DestinationWalkSlot" exact="null"/>
              <do_if value="$DestinationSlot">
                <!--Set $DestinationWalkSlot as the final slot walk checks should target. This prevents having to check further down if the destination is a chair slot with an approach slot.
                If an offset is provided, do not attempt to find a chair approach slot.-->
                <set_value name="$DestinationWalkSlot" exact="if $DestinationOffset then $DestinationSlot else $DestinationSlot.component.chairapproachslot.{$DestinationSlot}"/>
                <do_if value="not $DestinationWalkSlot">
                  <set_value name="$DestinationWalkSlot" exact="$DestinationSlot"/>
                </do_if>
                <debug_text text="'Current NPC roomslot is ' + $NPC.roomslot + ' looking for path to slot ' + $DestinationSlot + ' with the final slot to walk to being ' + $DestinationWalkSlot" chance="@$DebugChance"/>
                <set_value name="$ResolvedDestinationContext" exact="$DestinationSlot.component"/>
              </do_if>
              <do_else>
                <debug_text text="'Current NPC roomslot is ' + $NPC.roomslot + ' looking for path to position ' + $DestinationOffset + ' in context ' + $DestinationContext + ' ' + $DestinationContext.knownname" chance="@$DebugChance"/>
                <set_value name="$ResolvedDestinationContext" exact="$DestinationContext"/>
              </do_else>
              <do_if value="$ResolvedDestinationContext.isclass.object">
                <set_value name="$ResolvedDestinationContextObject" exact="$ResolvedDestinationContext"/>
              </do_if>
              <do_else>
                <set_value name="$ResolvedDestinationContextObject" exact="$ResolvedDestinationContext.object"/>
              </do_else>
              <assert value="$ResolvedDestinationContextObject" text="'Unable to resolve an object from ' + $ResolvedDestinationContext + ' [Owen]'"/>

              <!--Create definition for start position-->
              <set_value name="$BaseSubTargetDefinition" exact="table[]"/>
              <do_if value="$StartSlot">
                <set_value name="$BaseSubTargetDefinition.$targetslot" exact="$StartSlot" comment="the startslot may not be where the NPC currently is"/>
                <set_value name="$BaseSubTargetDefinition.$context" exact="$StartSlot.component"/>
              </do_if>
              <do_else>
                <set_value name="$BaseSubTargetDefinition.$targetslot" exact="null" comment="when null, use $NPC"/>
                <set_value name="$BaseSubTargetDefinition.$context" exact="$NPC.room.slotcontext"/>
              </do_else>

              <do_if value="@$DestinationSlot.hastag.npc">
                <!--$roomslot is a room slot which the NPC should reserve when walking towards it, those tagged as 'npc'-->
                <set_value name="$BaseSubTargetDefinition.$roomslot" exact="$DestinationSlot"/>
              </do_if>

              <!--Create definition for end position (can just throw all destination parameters in there)-->
              <set_value name="$DestinationDefinition" exact="table[]"/>
              <set_value name="$DestinationDefinition.$context" exact="$ResolvedDestinationContext"/>
              <set_value name="$DestinationDefinition.$targetslot" exact="$DestinationSlot"/>
              <set_value name="$DestinationDefinition.$targetoffset" exact="$DestinationOffset"/>
              <set_value name="$DestinationDefinition.$targetrotation" exact="$DestinationRotation"/>
              <set_value name="$DestinationDefinition.$targetroom" exact="$DestinationContextRoom" comment="Only set when walking to a non-slot position"/>

              <!--Prepare the tables for use in the GetNextSubTargetPoint library-->
              <!--Note: this is not the place to check if the NPC can walk from A-B in an attempt to skip the pathing library. It does more e.g. chair actions-->
              <set_value name="$CommonContext" exact="$NPC.commoncontext.{$ResolvedDestinationContext}"/>
              <debug_text text="'Common context: ' + $CommonContext" chance="@$DebugChance"/>

              <set_value name="$StartContainer" exact="null"/>
              <do_if value="$StartSlot">
                <set_value name="$StartContainer" exact="if $StartSlot.component.isclass.container then $StartSlot.component else $StartSlot.component.container"/>
              </do_if>
              <do_else>
                <set_value name="$StartContainer" exact="$NPC.container"/>
              </do_else>
              <set_value name="$DestinationContainer" exact="if $ResolvedDestinationContext.isclass.container then $ResolvedDestinationContext else $ResolvedDestinationContext.container"/>
              <set_value name="$StartContainsDestination" exact="$DestinationContainer.hascontext.{$StartContainer}"/>
              <!--List of objects from the start container to the destination-->
              <set_value name="$ObjectMovementList" exact="[]"/>
              <do_if value="$StartContainer == $DestinationContainer">
                <debug_text text="'Start and destination are the same object. No need to find the entry or exit points.'" chance="@$DebugChance"/>
              </do_if>
              <do_else>
                <do_if value="$CommonContext.isclass.space">
                  <debug_text text="'Start and destination do not share a common object context. They will be the only objects in this movement.'" chance="@$DebugChance"/>
                  <append_to_list name="$ObjectMovementList" exact="$StartContainer"/>
                  <append_to_list name="$ObjectMovementList" exact="$DestinationContainer"/>
                </do_if>
                <do_else>
                  <!--From the $StartContainer, go up through the objects until the common context is reached and then to the destination object (which could be the common context)-->
                  <set_value name="$CurrentContainer" exact="$StartContainer"/>
                  <do_while value="$CurrentContainer">
                    <append_to_list name="$ObjectMovementList" exact="$CurrentContainer"/>
                    <do_if value="$CurrentContainer == $CommonContext or not $CurrentContainer.hascontext.{$CommonContext}">
                      <!--Reached the top context we're interested in-->
                      <break/>
                    </do_if>
                    <do_else>
                      <!--TODO @Owen Potential place to optimise. When walking up from a ship to a station, take the walkable module into account so it's not potentially checking all slots on the station?-->
                      <set_value name="$CurrentContainer" exact="$CurrentContainer.container"/>
                    </do_else>
                  </do_while>
                  <remove_value name="$CurrentContainer"/>
                </do_else>
                <do_if value="$DestinationContainer != $ObjectMovementList.last">
                  <!--The destination container is not yet in the $ObjectMovementList. Go up through the objects until the common context is reached, but add these to the list in reverse-->
                  <set_value name="$TempObjectMovementList" exact="[]"/>
                  <set_value name="$CurrentContainer" exact="$DestinationContainer"/>
                  <do_while value="$CurrentContainer">
                    <do_if value="$CurrentContainer == $CommonContext or not $CurrentContainer.hascontext.{$CommonContext}">
                      <!--Reached the top context we're interested in-->
                      <break/>
                    </do_if>
                    <do_else>
                      <!--Unlike the StartContainer case, don't add the CommonContext container to this list-->
                      <append_to_list name="$TempObjectMovementList" exact="$CurrentContainer"/>
                      <set_value name="$CurrentContainer" exact="$CurrentContainer.container"/>
                    </do_else>
                  </do_while>
                  <do_for_each name="$TempContainer" in="$TempObjectMovementList" reverse="true">
                    <append_to_list name="$ObjectMovementList" exact="$TempContainer"/>
                  </do_for_each>
                  <remove_value name="$CurrentContainer"/>
                  <remove_value name="$TempObjectMovementList"/>
                </do_if>

                <do_if value="@$DebugChance">
                  <debug_text text="'Path will likely lead through the following objects:'"/>
                  <do_for_each name="$TempContainer" in="$ObjectMovementList">
                    <debug_text text="$TempContainer + ' ' + $TempContainer.knownname"/>
                  </do_for_each>
                </do_if>
              </do_else>

              <set_value name="$ContainerEntryPoints" exact="[]"/>
              <!--Find entry point slots for the relevant objects-->
              <do_for_each name="$TempContainer" in="$ObjectMovementList" counter="$oml_count">
                <do_if value="$TempContainer == $StartContainer and $oml_count != $ObjectMovementList.count and not $StartContainsDestination">
                  <debug_text text="'Skipping entry points for ' + $TempContainer + ' ' + $TempContainer.knownname + ' as it is the start container and the destination is outside'" chance="@$DebugChance"/>
                </do_if>
                <do_else>
                  <!--Find transporters exiting the object and bottoms of ladders-->
                  <find_npc_waypoint name="$EntryPoints" object="$TempContainer" anytag="$LocalEntrypointTagList" multiple="true"/>
                  <!--TODO @Owen - disabled until corrected-->
                  <do_if value="false and not $EntryPoints.count and $DestinationSlotContainer.hascontext.{$TempContainer}">
                    <!--There are no entry points for this object which contains the destination object. Check if there are transporters which can be walked to from outside to reach the destination.
                    This may be a M ship with a cockpit reachable from outside. It may have a transporter also reachable from outside which is not tagged npc_location_exit-->
                    <find_npc_waypoint name="$EntryPoints" object="$TempContainer" tags="tag.npctransport" multiple="true"/>
                  </do_if>
                  <do_if value="$EntryPoints.count">
                    <append_to_list name="$ContainerEntryPoints" exact="$EntryPoints"/>
                    <debug_text text="'Entry points for ' + $TempContainer + ' ' + $TempContainer.knownname + ' are ' + $EntryPoints" chance="@$DebugChance"/>
                  </do_if>
                </do_else>
              </do_for_each>

              <set_value name="$TempSlotStorer" exact="[]" comment="List to store a sequence of slots when iterating over potential pashs. Used to prevent going backwards."/>
              <set_value name="$CheckedTransporterObjects" exact="[]" comment="List of objects which have already had exit transporters checked. Optimisation to prevent doing the same checks multiple times."/>
              <do_if value="$BaseSubTargetDefinition.$targetslot">
                <!--If $targetslot is set for the base subtarget definition, it means the NPC will be warped there to start their path. Used when moving NPCs which were hidden.-->
                <set_value name="$BaseSubTargetDefinition.$warp" exact="true"/>
                <!--Add the start slot to the $TempSlotStorer to prevent the NPC finding it as a potential destination-->
                <append_to_list name="$TempSlotStorer" exact="$BaseSubTargetDefinition.$targetslot"/>
              </do_if>

              <set_value name="$definition" exact="$BaseSubTargetDefinition.clone"/>
              <run_actions ref="GetNextSubTargetPoint" result="$NextSubTarget_Result">
                <param name="NPC" value="$NPC"/>
                <param name="Top" value="this"/>
                <!--First, try to find a path without using a lift to help traverse distant objects-->
                <param name="AllowDistantTeleportation" value="false"/>

                <param name="PreviousDefinition" value="$definition"/>
                <param name="DebugChance" value="@$DebugChance"/>
              </run_actions>

              <do_if value="not $NextSubTarget_Result and $CommonContext.isclass.space">
                <!--run again, but with AllowDistantTeleportation as true.-->
                <debug_text text="'Running again but with $AllowDistantTeleportation as true'" chance="@$DebugChance"/>
                <set_value name="$definition" exact="$BaseSubTargetDefinition.clone"/>
                <clear_list list="$TempSlotStorer"/>
                <do_if value="$BaseSubTargetDefinition.$targetslot">
                  <append_to_list name="$TempSlotStorer" exact="$BaseSubTargetDefinition.$targetslot"/>
                </do_if>

                <run_actions ref="GetNextSubTargetPoint" result="$NextSubTarget_Result">
                  <param name="NPC" value="$NPC"/>
                  <param name="Top" value="this"/>
                  <param name="AllowDistantTeleportation" value="true"/>

                  <param name="PreviousDefinition" value="$definition"/>
                  <param name="DebugChance" value="@$DebugChance"/>
                </run_actions>
              </do_if>


              <debug_text text="'End ' + $definition" chance="@$DebugChance"/>

              <do_if value="$NextSubTarget_Result">
                <!--Success-->
                <do_if value="@$DebugChance">
                  <debug_text text="'The basic path is: '"/>
                  <set_value name="$SubDef" exact="$definition"/>
                  <do_while value="$SubDef">
                    <set_value name="$DebugSubDef" exact="$SubDef.clone"/>
                    <remove_value name="$DebugSubDef.$subdefinition"/>
                    <debug_text text="$DebugSubDef"/>
                    <do_if value="@$SubDef.$targetslot">
                      <debug_text text="'slot: ' + $SubDef.$targetslot + ' object: ' + $SubDef.$targetslot.component.knownname"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'Start position'"/>
                    </do_else>
                    <set_value name="$SubDef" exact="@$SubDef.$subdefinition"/>
                  </do_while>
                  <remove_value name="$SubDef"/>
                </do_if>

                <!--Perform the post processing of the path, inserting supplementary definitions such as climbing ladders to rotating chairs-->
                <run_actions ref="PathPostProcessing" result="$RootDefinition">
                  <param name="NPC" value="$NPC"/>
                  <param name="PathDefinition" value="$definition"/>
                  <param name="AnimateAtEnd" value="$AnimateAtEnd"/>
                  <param name="DebugChance" value="@$DebugChance"/>
                </run_actions>
                <do_if value="@$definition.$roomslot and not @$RootDefinition.$roomslot">
                  <!--Not the cleanest solution, but as $RootDefinition may be a different table to $definition, the $roomslot key may be lost.
                  TODO @Owen is that slot even needed in the path table anymore? Could be passed into the movement library as its own parameter.-->
                  <set_value name="$RootDefinition.$roomslot" exact="$definition.$roomslot"/>
                </do_if>

                <do_if value="@$DebugChance">
                  <debug_text text="'The processed path is: '"/>
                  <set_value name="$SubDef" exact="$definition"/>
                  <do_while value="$SubDef">
                    <set_value name="$DebugSubDef" exact="$SubDef.clone"/>
                    <set_value name="$DebugSubDef.$subdefinition" exact="null"/>
                    <debug_text text="$DebugSubDef"/>
                    <do_if value="@$SubDef.$targetslot">
                      <debug_text text="'slot: ' + $SubDef.$targetslot + ' object: ' + $SubDef.$targetslot.component.knownname"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'Start position'"/>
                    </do_else>
                    <set_value name="$SubDef" exact="@$SubDef.$subdefinition"/>
                  </do_while>
                  <remove_value name="$SubDef"/>
                </do_if>

                <set_value name="$PathTable" exact="$RootDefinition"/>
              </do_if>
            </do_if>
          </actions>
        </library>

        <!--Helper library which is called from GetNextTargetPoint and then calls itself recursivly to find a path-->
        <library name="GetNextSubTargetPoint" purpose="run_actions">
          <params>
            <param name="NPC"/>
            <param name="Top" comment="Top namespace storing shared variables between iterations e.g. $DestinationSlot and $DestinationDefinition"/>
            <param name="AllowDistantTeleportation" default="false" comment="Allow using transporters to warp to destination objects without a common object context"/>

            <param name="PreviousDefinition" comment="Previous definition table. The definition from this iteration is saved to $PreviousDefinition.$subdefinition"/>
            <param name="IterationDepth" default="1"/>
            <param name="DebugChance" default="0"/>
          </params>
          <actions>
            <do_if value="($Top.$DestinationSlot or $Top.$DestinationContext) and typeof $PreviousDefinition == datatype.table and typeof $Top == datatype.cue">
              <assert value="not $PreviousDefinition.$targetslot or $PreviousDefinition.$targetslot.component == $PreviousDefinition.$context"
                      text="$PreviousDefinition.$targetslot.component + ' ' + $PreviousDefinition.$targetslot.component.knownname + ' is not ' + $PreviousDefinition.$context + ' ' + $PreviousDefinition.$context.knownname" break="always"/>
              <!--Set up the debug indent-->
              <do_all chance="@$DebugChance">
                <set_value name="$DebugIndent" exact="''"/>
                <do_all exact="$IterationDepth">
                  <set_value name="$DebugIndent" operation="add" exact="' '"/>
                </do_all>
              </do_all>
              <do_if value="@$PreviousDefinition.$targetslot and $PreviousDefinition.$targetslot == $Top.$DestinationSlot">
                <!--
                ################
                RETURN
                A successful path was found to the destination slot with the previous definition.
                ################-->
                <debug_text text="$DebugIndent + 'Previous definition ended at the destination slot. Path successful.'" chance="@$DebugChance"/>
                <return value="true"/>
              </do_if>
              <debug_text text="$DebugIndent + 'Trying to find next point from ' + $PreviousDefinition" chance="@$DebugChance"/>

              <do_if value="$IterationDepth == 1">
                <!--Save a reference to the base definition in the $Top namespace-->
                <set_value name="$Top.$BaseDefinitionRef" exact="$PreviousDefinition"/>
              </do_if>

              <do_if value="$PreviousDefinition.$targetslot and not @$PreviousDefinition.$warp">
                <!--Check if the previous targetslot was a container entry point. If so, remove all container entry points for that object and any following objects-->
                <do_if value="$Top.$ContainerEntryPoints.count">
                  <do_all exact="$Top.$ContainerEntryPoints.count" counter="$CEP_i">
                    <do_if value="$Top.$ContainerEntryPoints.{$CEP_i}.indexof.{$PreviousDefinition.$targetslot}">
                      <debug_text text="$DebugIndent + 'Container entry point was used. Disregarding all reamaining entry points on this level and precursor levels. ' + $Top.$ContainerEntryPoints.{$CEP_i}" chance="@$DebugChance"/>
                      <clear_list list="$Top.$ContainerEntryPoints.{$CEP_i}"/>
                    </do_if>
                  </do_all>
                  <do_all exact="$Top.$ContainerEntryPoints.count" counter="$CEP_i" reverse="true">
                    <do_if value="$Top.$ContainerEntryPoints.{$CEP_i}.count == 0">
                      <remove_value name="$Top.$ContainerEntryPoints.{$CEP_i}"/>
                    </do_if>
                  </do_all>
                </do_if>
              </do_if>

              <!--
              ##################
              The below sections attempt to add suitable path definitions to the next point in the path.
              This may be multiple definitions for 'waypoint pairs' e.g. add 'Walk to ladder bottom' and also 'Stand at top of ladder'.
              
              If the last definition ends at the destination, the path is finalised and this stack of libraries will end.
              If the destination is yet to be reached, this library will then be called again with the last added definition as $PreviousDefinition
              
              Historical note: This library was previously far more recursive, not dealing with 'waypoint pairs' well. For the climbing ladder case, it would have run 3 iterations:
              Iteration #1: add a definition which instructs a walk to the bottom of the ladder
              Iteration #2: recognise that the previous point was the bottom of the ladder and add a '$climbingladder_up' definition which instructs an animation
              Iteration #3: recognise that the previous definition was a ladder climb and add a '$climbedladder_attop' definition
              
              It will now add definitions #1 and #3 in the same iteration, as if you walk to a ladder, you're going to end at the other end.
              #2, the animation instruction, is added in the post process once the path is finalised.
              ##################
              -->

              <!--First check if this is the start of the path and if something has to be handled before pathing as normal e.g. starting from a chair-->
              <do_if value="$IterationDepth == 1" >
                <!--This is the first entry of the path.-->

                <!--
                ***********************
                NPC STARTING IN A CHAIR
                ***********************-->
                <set_value name="$ChairRoomSlot" exact="null"/>
                <do_if value="@$PreviousDefinition.$targetslot.component.ischairslot.{$PreviousDefinition.$targetslot}">
                  <set_value name="$ChairRoomSlot" exact="$PreviousDefinition.$targetslot"/>
                  <debug_text text="$DebugIndent + 'NPC will warp to chair slot ' + $ChairRoomSlot + ' to start from.'" chance="@$DebugChance"/>
                </do_if>
                <do_elseif value="not $PreviousDefinition.$targetslot">
                  <set_value name="$ChairSlot" exact="$NPC.currentchair"/>
                  <do_if value="$ChairSlot">
                    <set_value name="$ChairRoomSlot" exact="$ChairSlot.component.chairroomslot.{$ChairSlot}"/>
                    <do_if value="$ChairRoomSlot">
                      <debug_text text="$DebugIndent + 'NPC will start from chair slot ' + $ChairRoomSlot + '. Overriding the first definition target point to this chair slot.'" chance="@$DebugChance"/>
                      <set_value name="$PreviousDefinition.$targetslot" exact="$ChairRoomSlot"/>
                    </do_if>
                  </do_if>
                </do_elseif>
                <do_if value="$ChairRoomSlot">
                  <debug_text text="$DebugIndent + 'Path from the chair approach slot position.'" chance="@$DebugChance"/>
                  <!--Set the value $PreviousDefinition.$prepare_leave_chair so the post processing easily regognises that definition and then adds additional definitions for the animations-->
                  <set_value name="$PreviousDefinition.$prepare_leave_chair" exact="true"/>

                  <!--Create the next definition at the chair approach pos to test walking away-->
                  <set_value name="$SubTargetDefinition" exact="table[]"/>
                  <set_value name="$SubTargetDefinition.$targetslot" exact="$ChairRoomSlot.component.chairapproachslot.{$ChairRoomSlot}"/>
                  <do_if value="not $SubTargetDefinition.$targetslot">
                    <!--If there is no chair approach slot defined, simply use the chair slot itself-->
                    <set_value name="$SubTargetDefinition.$targetslot" exact="$ChairRoomSlot"/>
                  </do_if>
                  <set_value name="$SubTargetDefinition.$context" exact="$ChairRoomSlot.component"/>

                  <set_value name="$PreviousDefinition.$subdefinition" exact="$SubTargetDefinition"/>

                  <!--Recursive call to GetNextSubTargetPoint-->
                  <run_actions ref="GetNextSubTargetPoint" result="$NextSubTarget_Result">
                    <param name="NPC" value="$NPC"/>
                    <param name="Top" value="$Top"/>
                    <param name="AllowDistantTeleportation" value="$AllowDistantTeleportation"/>

                    <param name="PreviousDefinition" value="$SubTargetDefinition"/>
                    <param name="IterationDepth" value="$IterationDepth + 1"/>
                    <param name="DebugChance" value="@$DebugChance"/>
                  </run_actions>

                  <do_if value="$NextSubTarget_Result">
                    <!--
                    ################
                    RETURN
                    A successful path was found, starting with getting out of this chair.
                    ################-->
                    <return value="true"/>
                  </do_if>
                  <do_else>
                    <!--Could not find a successful path. Cleanup and continue.-->
                    <set_value name="$PreviousDefinition.$subdefinition" exact="null"/>
                    <remove_value name="$PreviousDefinition.$prepare_leave_chair"/>
                    <remove_value name="$SubTargetDefinition"/>
                  </do_else>
                </do_if>
                <remove_value name="$ChairSlot"/>
                <remove_value name="$ChairRoomSlot"/>

                <!--Note: If the NPC started in a transporter, that is handled below just so we don't have 2 sections dealing with finding exit transporters.-->

              </do_if>

              <!--
              ***********************
              WALK TO DESTINATION CHECK
              ***********************-->
              <!--Check if the NPC can walk to the destination, otherwise find another reachable point which may lead to the destination-->
              <set_value name="$CanWalk" exact="false"/>

              <do_if value="$Top.$DestinationSlot">
                <do_if value="$PreviousDefinition.$targetslot">
                  <do_if value="$Top.$DestinationOffset">
                    <check_walk_path actor="$NPC" start="$PreviousDefinition.$targetslot" end="$Top.$DestinationWalkSlot" result="$CanWalk" checkstate="false">
                      <end value="$Top.$DestinationOffset"/>
                    </check_walk_path>
                  </do_if>
                  <do_else>
                    <check_walk_path actor="$NPC" start="$PreviousDefinition.$targetslot" end="$Top.$DestinationWalkSlot" result="$CanWalk" checkstate="false"/>
                  </do_else>
                  <debug_text text="$DebugIndent + 'Checking walk from slot ' + $PreviousDefinition.$targetslot + ' to ' + $Top.$DestinationWalkSlot + ' offset ' + $Top.$DestinationOffset" chance="@$DebugChance"/>
                </do_if>
                <do_else>
                  <do_if value="$Top.$DestinationOffset">
                    <check_walk_path actor="$NPC" end="$Top.$DestinationWalkSlot" result="$CanWalk" checkstate="false">
                      <end value="$Top.$DestinationOffset"/>
                    </check_walk_path>
                  </do_if>
                  <do_else>
                    <check_walk_path actor="$NPC" end="$Top.$DestinationWalkSlot" result="$CanWalk" checkstate="false"/>
                  </do_else>
                  <debug_text text="$DebugIndent + 'Checking walk from NPC position to ' + $Top.$DestinationWalkSlot + ' offset ' + $Top.$DestinationOffset" chance="@$DebugChance"/>
                </do_else>
              </do_if>
              <do_else>
                <!--Not a slot destination. $Top.$DestinationContext, $Top.$DestinationOffset-->
                <do_if value="$PreviousDefinition.$targetslot">
                  <check_walk_path actor="$NPC" start="$PreviousDefinition.$targetslot" end="$Top.$DestinationContext" result="$CanWalk" checkstate="false" destination="$Top.$DestinationContextRoom" destinationtags="$Top.$DestinationTags">
                    <end value="$Top.$DestinationOffset"/>
                  </check_walk_path>
                  <debug_text text="$DebugIndent + 'Checking walk from slot ' + $PreviousDefinition.$targetslot + ' to position ' + $Top.$DestinationOffset + ' of ' + $Top.$DestinationContext" chance="@$DebugChance"/>
                </do_if>
                <do_else>
                  <check_walk_path actor="$NPC" end="$Top.$DestinationContext" result="$CanWalk" checkstate="false" destination="$Top.$DestinationContextRoom" destinationtags="$Top.$DestinationTags">
                    <end value="$Top.$DestinationOffset"/>
                  </check_walk_path>
                  <debug_text text="$DebugIndent + 'Checking walk from NPC position to position ' + $Top.$DestinationOffset + ' of ' + $Top.$DestinationContext" chance="@$DebugChance"/>
                </do_else>
              </do_else>

              <do_if value="$CanWalk">
                <!--Can walk to the destination. Prepare to set the destination definition as the final subdefinition-->
                <debug_text text="$DebugIndent + 'Can walk directly to destination.'" chance="@$DebugChance"/>

                <!--Check if the $DestinationWalkSlot needs special handling e.g. approaching a chair-->
                <do_if value="$Top.$DestinationSlot != $Top.$DestinationWalkSlot and $Top.$DestinationSlot.component.ischairslot.{$Top.$DestinationSlot} and $Top.$DestinationSlot.component.chairapproachslot.{$Top.$DestinationSlot} == $Top.$DestinationWalkSlot">
                  <!--Approaching a chair. Create a subdefinition to the approach position and flag it for the post-process step.-->
                  <set_value name="$ChairApproachDefinition" exact="table[]"/>
                  <set_value name="$ChairApproachDefinition.$context" exact="$Top.$DestinationSlot.component"/>
                  <set_value name="$ChairApproachDefinition.$targetslot" exact="$Top.$DestinationSlot"/>
                  <set_value name="$ChairApproachDefinition.$chair_walkto" exact="true"/>
                  <!--Flag the approach definition to not trigger default animations on arrival-->
                  <set_value name="$ChairApproachDefinition.$preventanimation"/>
                  <set_value name="$ChairApproachDefinition.$hintedanimation" exact="['sitdown', 'generic']"/>
                  <!--Walk to a position relative to the base of the chair. The exact position may be different per character depending on the start position of their sitdown animation. Adjust positions below.-->
                  <do_if value="$NPC.race == race.argon or $NPC.race == race.terran or $NPC.race == race.split">
                    <do_if value="$NPC.isfemale">
                      <set_value name="$ChairApproachDefinition.$targetoffset" exact="position.[0m, 0m, -0.25m]"/>
                    </do_if>
                    <do_else>
                      <set_value name="$ChairApproachDefinition.$targetoffset" exact="position.[0m, 0m, -0.27m]"/>
                    </do_else>
                  </do_if>
                  <do_elseif value="$NPC.race == race.boron">
                    <set_value name="$ChairApproachDefinition.$targetoffset" exact="position.[0m, 0m, -0.44m]"/>
                  </do_elseif>
                  <do_elseif value="$NPC.race == race.teladi">
                    <set_value name="$ChairApproachDefinition.$targetoffset" exact="position.[0m, 0m, -0.25m]"/>
                  </do_elseif>
                  <do_elseif value="$NPC.race == race.paranid">
                    <set_value name="$ChairApproachDefinition.$targetoffset" exact="position.[0m, 0m, -0.54m]"/>
                  </do_elseif>
                  <do_else>
                    <set_value name="$ChairApproachDefinition.$targetoffset" exact="position.[0m, 0m, -0.27m]"/>
                  </do_else>

                  <!--Add the chair approach definition before the destination definition-->
                  <set_value name="$PreviousDefinition.$subdefinition" exact="$ChairApproachDefinition"/>
                  <set_value name="$ChairApproachDefinition.$subdefinition" exact="$Top.$DestinationDefinition"/>
                </do_if>
                <do_else>
                  <!--Ordinary walk to the destination. Set the destination definition as the final subdefinition.-->
                  <set_value name="$PreviousDefinition.$subdefinition" exact="$Top.$DestinationDefinition"/>
                </do_else>
                <!--
                ################
                RETURN
                A successful path to the destination was found.
                ################-->
                <return value="true"/>
              </do_if>
              <do_else>
                <!--Can't walk to the destination. Look for waypoints to travel to.-->
                <!--NPC can't walk directly from here.-->
                <debug_text text="$DebugIndent + 'Cannot walk directly to destination.'" chance="@$DebugChance"/>
                <debug_text text="$DebugIndent + 'Looking for slots on ' + $PreviousDefinition.$context.knownname + ' ' + $PreviousDefinition.$context" chance="@$DebugChance"/>

                <!--Construct a list of containers in the path which have already been exited so we can disregard them below. Also check which objects have had a transporter be entered.-->
                <set_value name="$EnteredTransporterObjects" exact="[]"/>
                <set_value name="$ExitedContainers" exact="[]"/>
                <set_value name="$PastDefinition" exact="$Top.$BaseDefinitionRef"/>
                <set_value name="$Definition_Idx" exact="1"/>
                <do_while value="$PastDefinition">
                  <set_value name="$DefinitionContainer" exact="if $PastDefinition.$context.isclass.container then $PastDefinition.$context else $PastDefinition.$context.container"/>
                  <set_value name="$NextDefinitionContainer" exact="null"/>
                  <set_value name="$NextDefinition" exact="@$PastDefinition.$subdefinition"/>
                  <do_if value="$NextDefinition">
                    <set_value name="$NextDefinitionContainer" exact="if $NextDefinition.$context.isclass.container then $NextDefinition.$context else $NextDefinition.$context.container"/>
                  </do_if>
                  <do_if value="$DefinitionContainer and $ExitedContainers.indexof.{$DefinitionContainer} == 0 and (($NextDefinitionContainer and $DefinitionContainer != $NextDefinitionContainer) or $PastDefinition.$exitingtransporter?)">
                    <append_to_list name="$ExitedContainers" exact="$DefinitionContainer"/>
                    <debug_text text="$DebugIndent + 'Object ' + $DefinitionContainer + ' ' + $DefinitionContainer.knownname + ' was already exited'" chance="@$DebugChance"/>
                  </do_if>

                  <do_if value="@$PastDefinition.$targetslot and $PastDefinition.$targetslot.hastag.npctransport and $Definition_Idx gt 1 and not $PastDefinition.$exitingtransporter?">
                    <append_to_list name="$EnteredTransporterObjects" exact="if $PastDefinition.$targetslot.component.isclass.object then $PastDefinition.$targetslot.component else $PastDefinition.$targetslot.component.object"/>
                    <debug_text text="$DebugIndent + 'NPC already entered a transporter ' + $PastDefinition.$targetslot + ' on ' + $EnteredTransporterObjects.last.knownname" chance="@$DebugChance"/>
                  </do_if>
                  <set_value name="$PastDefinition" exact="@$PastDefinition.$subdefinition"/>
                  <set_value name="$Definition_Idx" operation="add"/>
                </do_while>
                <remove_value name="$PastDefinition"/>
                <remove_value name="$NextDefinition"/>
                <remove_value name="$DefinitionContainer"/>
                <remove_value name="$NextDefinitionContainer"/>
                <remove_value name="$Definition_Idx"/>

                <set_value name="$waypoints" exact="[]"/>

                <!--TODO @Owen check if a walkable context exists at all before checking if you can walk to the entry points-->
                <do_if value="$Top.$ContainerEntryPoints? and $Top.$ContainerEntryPoints.count">
                  <!--Check if they can walk to any of the container entry points-->
                  <do_all exact="$Top.$ContainerEntryPoints.{$Top.$ContainerEntryPoints.count}.count" counter="$CEP_i">
                    <!--TODO @Owen sort by distance to NPC-->
                    <debug_text text="$DebugIndent + 'adding container entry point ' + $Top.$ContainerEntryPoints.{$Top.$ContainerEntryPoints.count}.{$CEP_i} + ' on ' + $Top.$ContainerEntryPoints.{$Top.$ContainerEntryPoints.count}.{$CEP_i}.component.knownname" chance="@$DebugChance"/>
                    <append_to_list name="$waypoints" exact="$Top.$ContainerEntryPoints.{$Top.$ContainerEntryPoints.count}.{$CEP_i}"/>
                  </do_all>
                </do_if>

                <!--
                Here we will look at the previous definition to find which object we need to be looking at for the next slots
                Ordinarily, the object to look at would be the one of the previous slot, but in cases such as leaving the bottom of ladders, it should be the containing object-->

                <set_value name="$tempwaypoints" exact="[]"/>
                <do_if value="@$PreviousDefinition.$climbedladder_atbottom and $PreviousDefinition.$targetslot.hastag.ladder_bottom and $PreviousDefinition.$context.object">
                  <!--At the bottom after climbing down. Find slots on parent.-->
                  <debug_text text="$DebugIndent + 'At bottom of ladder. Looking for slots on object ' + $PreviousDefinition.$context.object.knownname + ' ' +  $PreviousDefinition.$context.object" chance="@$DebugChance"/>
                  <do_if value="not $Top.$LocalWaypointCache.{$PreviousDefinition.$context.object}?">
                    <find_npc_waypoint name="$Top.$LocalWaypointCache.{$PreviousDefinition.$context.object}" object="$PreviousDefinition.$context.object" anytag="$Top.$LocalWaypointTagList" multiple="true"/>
                  </do_if>
                  <append_list_elements name="$tempwaypoints" other="$Top.$LocalWaypointCache.{$PreviousDefinition.$context.object}"/>
                </do_if>
                <do_elseif value="@$PreviousDefinition.$context.walkablemodule">
                  <do_if value="$ExitedContainers.indexof.{$PreviousDefinition.$context.container} == 0">
                    <debug_text text="$DebugIndent + 'Finding waypoints on context dockarea ' + $PreviousDefinition.$context.walkablemodule.knownname + ' ' + $PreviousDefinition.$context.walkablemodule" chance="@$DebugChance"/>
                    <do_if value="not $Top.$LocalWaypointCache.{$PreviousDefinition.$context.walkablemodule}?">
                      <find_npc_waypoint name="$Top.$LocalWaypointCache.{$PreviousDefinition.$context.walkablemodule}" object="$PreviousDefinition.$context.walkablemodule" anytag="$Top.$LocalWaypointTagList" multiple="true"/>
                    </do_if>
                    <append_list_elements name="$tempwaypoints" other="$Top.$LocalWaypointCache.{$PreviousDefinition.$context.walkablemodule}"/>
                  </do_if>
                  <do_else>
                    <debug_text text="$DebugIndent + 'NPC has already exited ' + $PreviousDefinition.$context.container.knownname + ' ' + $PreviousDefinition.$context.container + ' so do not find waypoints again on walkable module ' + $PreviousDefinition.$context.walkablemodule.knownname + ' ' + $PreviousDefinition.$context.walkablemodule" chance="@$DebugChance"/>
                  </do_else>
                </do_elseif>
                <do_elseif value="$PreviousDefinition.$context.isclass.room and @$PreviousDefinition.$context.dynamicinterior">
                  <!--If the previous slot was in a dynamic interior, take all of waypoints in the contained rooms into consideration-->
                  <debug_text text="$DebugIndent + 'Finding waypoints in dynamic interior: ' + $PreviousDefinition.$context.dynamicinterior.knownname + ' ' + $PreviousDefinition.$context.dynamicinterior" chance="@$DebugChance"/>
                  <do_if value="not $Top.$LocalWaypointCache.{$PreviousDefinition.$context.dynamicinterior}?">
                    <set_value name="$Top.$LocalWaypointCache.{$PreviousDefinition.$context.dynamicinterior}" exact="[]"/>
                    <do_for_each name="$NavContextRoom" in="$PreviousDefinition.$context.dynamicinterior.rooms">
                      <debug_text text="$DebugIndent + 'Finding waypoints in dynamic room: ' + $NavContextRoom.knownname + ' ' + $NavContextRoom" chance="@$DebugChance"/>
                      <find_npc_waypoint name="$Top.$LocalWaypointCache.{$PreviousDefinition.$context.dynamicinterior}" object="$NavContextRoom" anytag="$Top.$LocalWaypointTagList" multiple="true" append="true"/>
                    </do_for_each>
                  </do_if>
                  <append_list_elements name="$tempwaypoints" other="$Top.$LocalWaypointCache.{$PreviousDefinition.$context.dynamicinterior}"/>
                </do_elseif>
                <do_else>
                  <do_if value="not $AllowDistantTeleportation and $PreviousDefinition.$context != @$Top.$DestinationSlot.component and $PreviousDefinition.$context != $Top.$DestinationContext">
                    <!--In this case we are attempting to find waypoints such as transporters or ladders and use them to exit the current object-->
                    <!--First, find any transporters tagged with npc_location_exit. If they can be walked to by the previous definition we can assume we can simply walk off the object without need of any other waypoint here.-->
                    <find_npc_waypoint name="$temp_exitlocations" object="$PreviousDefinition.$context" tags="tag.npc_location_exit" multiple="true"/>
                    <set_value name="$canwalktoexit" exact="false"/>
                    <do_for_each name="$temp_exitlocation" in="$temp_exitlocations">
                      <do_if value="$PreviousDefinition.$targetslot">
                        <check_walk_path result="$canwalktoexit" actor="$NPC" start="$PreviousDefinition.$targetslot" end="$temp_exitlocation" checkstate="false"/>
                      </do_if>
                      <do_else>
                        <check_walk_path result="$canwalktoexit" actor="$NPC" end="$temp_exitlocation" checkstate="false"/>
                      </do_else>
                      <do_if value="$canwalktoexit">
                        <break/>
                      </do_if>
                    </do_for_each>
                    <remove_value name="$temp_exitlocations"/>
                    <do_if value="$canwalktoexit">
                      <debug_text text="$DebugIndent + 'NPC could walk from previous waypoint to npc_location_exit waypoint so no need to find other waypoints off object ' + $PreviousDefinition.$context.knownname + ' ' + $PreviousDefinition.$context" chance="@$DebugChance"/>
                    </do_if>
                    <do_else>
                      <!--If previous definition has a different context to the destination, do not allow cabins or exit transporters to be used. This would lead to people thinking they could use them as transporters to another object.-->
                      <find_npc_waypoint name="$tempwaypoints_2" object="$PreviousDefinition.$context" anytag="$Top.$LocalWaypointTagList" multiple="true"/>
                      <debug_text text="$DebugIndent + 'Finding non cabin or entry transporters waypoints on object ' + $PreviousDefinition.$context.knownname + ' ' + $PreviousDefinition.$context" chance="@$DebugChance"/>
                      <do_for_each name="$tempwp" in="$tempwaypoints_2">
                        <do_if value="$tempwp.group != tag.cabin_01 and not $tempwp.hastag.npc_location_exit">
                          <debug_text text="$DebugIndent + 'Accepting transporter location ' + $tempwp" chance="@$DebugChance"/>
                          <append_to_list name="$tempwaypoints" exact="$tempwp"/>
                        </do_if>
                        <do_else>
                          <debug_text text="$DebugIndent + 'Rejecting transporter location ' + $tempwp" chance="@$DebugChance"/>
                        </do_else>
                      </do_for_each>
                    </do_else>
                    <remove_value name="$canwalktoexit"/>
                  </do_if>
                  <do_else>
                    <debug_text text="$DebugIndent + 'Finding waypoints on object ' + $PreviousDefinition.$context.knownname + ' ' + $PreviousDefinition.$context" chance="@$DebugChance"/>
                    <do_if value="not $Top.$LocalWaypointCache.{$PreviousDefinition.$context}?">
                      <find_npc_waypoint name="$Top.$LocalWaypointCache.{$PreviousDefinition.$context}" object="$PreviousDefinition.$context" anytag="$Top.$LocalWaypointTagList" multiple="true"/>
                    </do_if>
                    <append_list_elements name="$tempwaypoints" other="$Top.$LocalWaypointCache.{$PreviousDefinition.$context}"/>
                  </do_else>

                  <!--Add waypoints from next object en-route to the destination-->
                  <do_if value="$Top.$ObjectMovementList.count">
                    <set_value name="$CurrentContainer" exact="if $PreviousDefinition.$context.isclass.container then $PreviousDefinition.$context else $PreviousDefinition.$context.container"/>
                    <set_value name="$NextContainer" exact="if $Top.$ObjectMovementList.last == $CurrentContainer then null else $Top.$ObjectMovementList.{$Top.$ObjectMovementList.indexof.{$CurrentContainer} + 1}"/>
                    <do_if value="$NextContainer">
                      <debug_text text="$DebugIndent + 'Finding waypoints on upcoming object ' + $NextContainer + ' ' + $NextContainer.knownname" chance="@$DebugChance"/>
                      <do_if value="not $Top.$LocalWaypointCache.{$NextContainer}?">
                        <find_npc_waypoint name="$Top.$LocalWaypointCache.{$NextContainer}" object="$NextContainer" anytag="$Top.$LocalWaypointTagList" multiple="true"/>
                      </do_if>
                      <append_list_elements name="$tempwaypoints" other="$Top.$LocalWaypointCache.{$NextContainer}"/>
                    </do_if>
                    <remove_value name="$CurrentContainer"/>
                    <remove_value name="$NextContainer"/>
                  </do_if>
                </do_else>

                <!--TODO @Owen as the container entry points are added first, the NPC would prefer a 500m walk to a ladder instead of taking a transporter shortcut-->
                <do_if value="$tempwaypoints.count">
                  <sort_list list="$tempwaypoints" sortbyvalue="$NPC.distanceto.{loop.element}" sortdescending="false"/>
                  <append_list_elements name="$waypoints" other="$tempwaypoints"/>
                </do_if>

                <!--
                ###################
                WAYPOINT EVALUATION
                We now have our list of $waypoints that we want to try to see if they help us path towards the destination.
                Some waypoints are simple walk destinations while others are ladder points or teleporters
                If $PreviousDefinition.$targetslot exists, use that as the start point, otherwise use the NPC
                ###################-->

                <set_value name="$waypoint_iterations" exact="$waypoints.count"/>
                <do_if value="$IterationDepth == 1 and $PreviousDefinition.$targetslot and $PreviousDefinition.$targetslot.hastag.npctransport and ($AllowDistantTeleportation or $PreviousDefinition.$targetslot.component == $Top.$ResolvedDestinationContextObject or $PreviousDefinition.$targetslot.component.hascontext.{$Top.$ResolvedDestinationContextObject})">
                  <!--### CREATIVE SOLUTION ###-->
                  <!--If the player spawned in a transporter and no ordinary path was found by using the ordinary waypoints, iterate one more time with the spawn slot as the waypoint and look for an exit transporter
                  This saves having to duplicate or move the section finding an exit transporter
                  
                  Only do it if $AllowDistantTeleportation == true, or the destination is local.
                  if $AllowDistantTeleportation == false and no path is found, the library will be run again with $AllowDistantTeleportation == true and a path may well be found properly-->
                  <debug_text text="$DebugIndent + 'This is the first set of waypoint checks. If it fails, looks for exit elevators on related objects and treat the NPCs current position as a teleportation point. Startslot: ' + $PreviousDefinition.$targetslot" chance="@$DebugChance"/>
                  <set_value name="$waypoint_iterations" operation="add"/>
                </do_if>

                <do_all exact="$waypoint_iterations" counter="$wp_i">
                  <do_if value="$wp_i le $waypoints.count">
                    <set_value name="$waypoint" exact="$waypoints.{$wp_i}"/>
                    <set_value name="$IsStartSlot" exact="false"/>
                    <debug_text text="$DebugIndent + 'Evaluating waypoint ' + $waypoint" chance="@$DebugChance"/>
                  </do_if>
                  <do_else>
                    <set_value name="$waypoint" exact="@$PreviousDefinition.$targetslot"/>
                    <set_value name="$IsStartSlot" exact="true"/>
                    <do_all chance="@$DebugChance">
                      <do_if value="$waypoint">
                        <debug_text text="$DebugIndent + 'Evaluating spawn slot ' + $waypoint + ' and searching for an exit transporter'"/>
                      </do_if>
                      <do_else>
                        <debug_text text="$DebugIndent + 'Evaluating start position as a teleport point and searching for an exit transporter'"/>
                      </do_else>
                    </do_all>
                  </do_else>

                  <set_value name="$CanWalkwaypoint" exact="false"/>
                  <do_if value="not $IsStartSlot">
                    <do_if value="$waypoint != $Top.$DestinationSlot and $Top.$TempSlotStorer.indexof.{$waypoint}">
                      <debug_text text="$DebugIndent + 'Evaluated slot ' + $waypoint + ' was already in this path. Disregarding.'" chance="@$DebugChance"/>
                      <continue/>
                    </do_if>
                    <do_if value="@$PreviousDefinition.$targetslot">
                      <check_walk_path result="$CanWalkwaypoint" actor="$NPC" start="$PreviousDefinition.$targetslot" end="$waypoint" checkstate="false"/>
                      <do_all chance="@$DebugChance">
                        <do_if value="$CanWalkwaypoint">
                          <debug_text text="$DebugIndent + 'NPC can walk from ' + $PreviousDefinition.$targetslot + ' to ' + $waypoint"/>
                        </do_if>
                        <do_else>
                          <debug_text text="$DebugIndent + 'NPC can not walk from ' + $PreviousDefinition.$targetslot + ' to ' + $waypoint + ' on ' + $waypoint.component.knownname"/>
                        </do_else>
                      </do_all>
                    </do_if>
                    <do_else>
                      <check_walk_path result="$CanWalkwaypoint" actor="$NPC" end="$waypoint" checkstate="false"/>
                      <do_all chance="@$DebugChance">
                        <do_if value="$CanWalkwaypoint">
                          <debug_text text="$DebugIndent + 'NPC can walk to ' + $waypoint"/>
                        </do_if>
                        <do_else>
                          <debug_text text="$DebugIndent + 'NPC can not walk to ' + $waypoint"/>
                        </do_else>
                      </do_all>
                    </do_else>
                  </do_if>

                  <do_if value="$CanWalkwaypoint or $IsStartSlot">
                    <!--Can walk to the waypoint or the waypoint is the start slot. Check to see what type it is.-->
                    <do_if value="$IsStartSlot or $waypoint.hastag.npctransport">
                      <do_if value="not $IsStartSlot and not $AllowDistantTeleportation and $waypoint.group == tag.cabin_01">
                        <!--
                        ###################
                        CABINS
                        ###################-->
                        <debug_text text="$DebugIndent + $waypoint + ' is a cabin. Do not walk to one unless it is the destination or distant teleportation is allowed.'" chance="@$DebugChance"/>
                      </do_if>

                      <!--
                      ###################
                      TRANSPORTERS
                      ###################-->
                      <do_elseif value="not $IsStartSlot and ($EnteredTransporterObjects.indexof.{$waypoint.component} or (not $waypoint.component.isclass.object and $EnteredTransporterObjects.indexof.{$waypoint.component.object}))">
                        <debug_text text="$DebugIndent + $waypoint + ' is a transporter but the path already contains a transporter on this object being entered. No need to do it again.'" chance="@$DebugChance"/>
                      </do_elseif>
                      <do_else>
                        <!--TODO @Owen if the destination is a transporter and we're already considering exit transporters on that object, no need to actally exit-->
                        <do_all chance="@$DebugChance">
                          <do_if value="$waypoint">
                            <debug_text text="$DebugIndent + $waypoint + ' is a transporter. Look for exit transporters.'"/>
                          </do_if>
                          <do_else>
                            <debug_text text="$DebugIndent + 'Treating start point as a transporter. Look for exit transporters.'"/>
                          </do_else>
                        </do_all>

                        <set_value name="$DestinationExitSlots" exact="[]"/>
                        <set_value name="$DynamicInterior" exact="if $Top.$ResolvedDestinationContext.isclass.navcontext then $Top.$ResolvedDestinationContext else @$Top.$ResolvedDestinationContext.dynamicinterior"/>
                        <do_if value="$DynamicInterior">
                          <debug_text text="$DebugIndent + 'Destination slot is in a dynamic interior. Find all exit transporters within all rooms of the dynamic interior ' + $DynamicInterior + ' ' + $DynamicInterior.knownname" chance="@$DebugChance"/>
                          <do_for_each name="$NavContextRoom" in="$DynamicInterior.rooms">
                            <debug_text text="$DebugIndent + 'Appending waypoints from room ' + $NavContextRoom" chance="@$DebugChance"/>
                            <find_npc_waypoint name="$DestinationExitSlots" object="$NavContextRoom" tags="tag.npctransport" append="true" multiple="true"/>
                          </do_for_each>
                        </do_if>
                        <do_elseif value="@$Top.$DestinationSlot.component.isclass.room">
                          <find_npc_waypoint name="$DestinationExitSlots" object="$Top.$DestinationSlot.component" tags="tag.npctransport" multiple="true" append="true"/>
                          <do_if value="@$Top.$DestinationSlot.component.parent.isclass.walkablemodule">
                            <find_room name="$ModuleRooms" object="$Top.$DestinationSlot.component.parent" multiple="true"/>
                            <do_for_each name="$ModuleRoom" in="$ModuleRooms">
                              <find_npc_waypoint name="$DestinationExitSlots" object="$ModuleRoom" tags="tag.npctransport" multiple="true" append="true"/>
                            </do_for_each>
                          </do_if>
                        </do_elseif>
                        <do_elseif value="$Top.$ResolvedDestinationContext">
                          <find_npc_waypoint name="$DestinationExitSlots" object="$Top.$ResolvedDestinationContext" tags="tag.npctransport" multiple="true" append="true"/>
                        </do_elseif>
                        <!--Sort the distance between the component slot and the destination-->
                        <do_if value="$Top.$DestinationSlot">
                          <sort_list list="$DestinationExitSlots" sortbyvalue="loop.element.distanceto.{$Top.$DestinationSlot}" sortdescending="false"/>
                        </do_if>
                        <do_else>
                          <sort_list list="$DestinationExitSlots" sortbyvalue="loop.element.distanceto.[$Top.$DestinationContext, $Top.$DestinationOffset]" sortdescending="false"/>
                        </do_else>

                        <set_value name="$ExitTransporterSlots" exact="[]"/>
                        <do_if value="$AllowDistantTeleportation and ((not $waypoint and $NPC.commoncontext.{$Top.$ResolvedDestinationContextObject}.isclass.space) or (@$waypoint.component.commoncontext.{$Top.$ResolvedDestinationContextObject}.isclass.space))">
                          <!--Destination has no common object context with the entered transporter and allowing distant warping is allowed. Find exit slots on the destination object, starting with the destination room.-->
                          <set_value name="$ExitTransporterSlots" exact="$DestinationExitSlots"/>
                        </do_if>
                        <do_else>
                          <!--Attempt to exit on the next logical object. Add all exit transporter slots on upcoming objects in order-->
                          <set_value name="$CurrentContainer" exact="if $waypoint.component.isclass.container then $waypoint.component else $waypoint.component.container"/>
                          <set_value name="$CurrentContainerIdx" exact="$Top.$ObjectMovementList.indexof.{$CurrentContainer}"/>
                          <do_all exact="$Top.$ObjectMovementList.count" counter="$oml_i">
                            <do_if value="$oml_i ge $CurrentContainerIdx and $ExitedContainers.indexof.{$Top.$ObjectMovementList.{$oml_i}} == 0">
                              <debug_text text="$DebugIndent + 'Finding exit waypoints on current or upcoming object ' + $Top.$ObjectMovementList.{$oml_i} + ' ' + $Top.$ObjectMovementList.{$oml_i}.knownname" chance="@$DebugChance"/>
                              <find_npc_waypoint name="$ObjectExitSlots" object="$Top.$ObjectMovementList.{$oml_i}" tags="tag.npctransport" multiple="true"/>
                              <!--Sort the distance between the component slot and the destination-->
                              <do_if value="$Top.$DestinationSlot">
                                <sort_list list="$ObjectExitSlots" sortbyvalue="loop.element.distanceto.{$Top.$DestinationSlot}" sortdescending="false"/>
                              </do_if>
                              <do_else>
                                <sort_list list="$ObjectExitSlots" sortbyvalue="loop.element.distanceto.[$Top.$DestinationContext, $Top.$DestinationOffset]" sortdescending="false"/>
                              </do_else>
                              <append_list_elements name="$ExitTransporterSlots" other="$ObjectExitSlots"/>
                            </do_if>
                          </do_all>
                          <append_list_elements name="$ExitTransporterSlots" other="$DestinationExitSlots"/>
                        </do_else>

                        <do_if value="$waypoint">
                          <remove_from_list name="$ExitTransporterSlots" exact="$waypoint"/>
                        </do_if>

                        <do_if value="$ExitTransporterSlots.count">
                          <!--Remove slots that have already been evaluated-->
                          <do_all exact="$ExitTransporterSlots.count" counter="$ets_i" reverse="true">
                            <set_value name="$ExitTransporterSlot" exact="$ExitTransporterSlots.{$ets_i}"/>
                            <do_if value="$ExitTransporterSlot != $Top.$DestinationSlot and $Top.$TempSlotStorer.indexof.{$ExitTransporterSlot}">
                              <debug_text text="$DebugIndent + 'Exit transporter slot ' + $ExitTransporterSlot + ' was already in this path. Disregarding.'" chance="@$DebugChance"/>
                              <remove_value name="$ExitTransporterSlots.{$ets_i}"/>
                            </do_if>
                            <remove_value name="$ExitTransporterSlot"/>
                          </do_all>

                          <do_if value="$ExitTransporterSlots.count">
                            <!--Loop over remaining and sorted transporter exit slots. Create a new definition for the entry and exit points and call GetNextSubTargetPoint again-->

                            <!--Defintion to enter the $waypoint entry transporter-->
                            <do_if value="$waypoint">
                              <set_value name="$EnterTransporterDefinition" exact="table[]"/>
                              <set_value name="$EnterTransporterDefinition.$context" exact="$waypoint.component"/>
                              <set_value name="$EnterTransporterDefinition.$targetslot" exact="$waypoint"/>
                              <set_value name="$PreviousDefinition.$subdefinition" exact="$EnterTransporterDefinition"/>
                              <append_to_list name="$Top.$TempSlotStorer" exact="$waypoint"/>
                            </do_if>

                            <do_for_each name="$ExitTransporterSlot" in="$ExitTransporterSlots">
                              <debug_text text="$DebugIndent + 'Checking exit slot ' + $ExitTransporterSlot + ' in ' + $ExitTransporterSlot.component.macro.id" chance="@$DebugChance"/>
                              <set_value name="$ExitTransporterDefinition" exact="table[]"/>
                              <set_value name="$ExitTransporterDefinition.$context" exact="$ExitTransporterSlot.component"/>
                              <set_value name="$ExitTransporterDefinition.$targetslot" exact="$ExitTransporterSlot"/>
                              <set_value name="$ExitTransporterDefinition.$exitingtransporter" exact="true"/>
                              <append_to_list name="$Top.$TempSlotStorer" exact="$ExitTransporterSlot"/>

                              <do_if value="$waypoint">
                                <set_value name="$EnterTransporterDefinition.$subdefinition" exact="$ExitTransporterDefinition"/>
                              </do_if>
                              <do_else>
                                <set_value name="$PreviousDefinition.$subdefinition" exact="$ExitTransporterDefinition"/>
                              </do_else>

                              <!--Recursive call to GetNextSubTargetPoint-->
                              <run_actions ref="GetNextSubTargetPoint" result="$NextSubTarget_Result">
                                <param name="NPC" value="$NPC"/>
                                <param name="Top" value="$Top"/>
                                <param name="AllowDistantTeleportation" value="$AllowDistantTeleportation"/>

                                <param name="PreviousDefinition" value="$ExitTransporterDefinition"/>
                                <param name="IterationDepth" value="$IterationDepth + 1"/>
                                <param name="DebugChance" value="@$DebugChance"/>
                              </run_actions>

                              <do_if value="$NextSubTarget_Result">
                                <!--
                                ################
                                RETURN
                                Exiting this transporter lead to a successful path to the destination
                                ################-->
                                <return value="true"/>
                              </do_if>
                              <do_else>
                                <!--This exit waypoint does not lead to the destination. Cleanup and try the next exit transporter point.-->
                                <do_if value="$waypoint">
                                  <set_value name="$EnterTransporterDefinition.$subdefinition" exact="null"/>
                                </do_if>
                                <do_else>
                                  <set_value name="$PreviousDefinition.$subdefinition" exact="null"/>
                                </do_else>
                                <remove_value name="$ExitTransporterDefinition"/>
                              </do_else>
                            </do_for_each>

                            <!--$waypoint did not lead to the destination. Cleanup and try next $waypoint-->
                            <set_value name="$PreviousDefinition.$subdefinition" exact="null"/>
                            <remove_value name="$EnterTransporterDefinition"/>
                          </do_if>
                        </do_if>
                      </do_else>


                    </do_if>
                    <do_elseif value="$waypoint.hasanytag.[tag.ladder_top, tag.ladder_bottom]">
                      <!--
                      ###################
                      LADDERS
                      ###################-->
                      <do_if value="$waypoint.hastag.ladder_top">
                        <find_npc_waypoint name="$OppositeLadderSlots" object="$waypoint.component" tags="tag.ladder_bottom" multiple="true"/>
                      </do_if>
                      <do_else>
                        <find_npc_waypoint name="$OppositeLadderSlots" object="$waypoint.component" tags="tag.ladder_top" multiple="true"/>
                      </do_else>
                      <do_if value="$OppositeLadderSlots.count">
                        <do_if value="$OppositeLadderSlots.count == 1">
                          <set_value name="$OppositeLadderSlot" exact="$OppositeLadderSlots.{1}"/>
                        </do_if>
                        <do_else>
                          <assert value="$waypoint.group" text="'Multiple ladder slots found but ladder waypoint ' + $waypoint + ' is not grouped [Owen]'" break="1"/>
                          <set_value name="$OppositeLadderSlot" exact="null"/>
                          <do_for_each name="$tmp_ladder_wp" in="$OppositeLadderSlots">
                            <do_if value="$tmp_ladder_wp.group == $waypoint.group">
                              <set_value name="$OppositeLadderSlot" exact="$tmp_ladder_wp"/>
                              <break/>
                            </do_if>
                          </do_for_each>
                          <do_if value="not $OppositeLadderSlot">
                            <assert value="false" text="'Unable to find the opposite ladder slot for ' + $waypoint + ' of group ' + $waypoint.group + ' [Owen]'" break="1"/>
                          </do_if>
                        </do_else>
                        <do_if value="$OppositeLadderSlot">
                          <!--Create a new definition for the start and end ladder waypoints and call GetNextSubTargetPoint again-->

                          <!--Defintion to the first ladder waypoint-->
                          <set_value name="$FirstLadderDefinition" exact="table[]"/>
                          <set_value name="$FirstLadderDefinition.$context" exact="$waypoint.component"/>
                          <set_value name="$FirstLadderDefinition.$targetslot" exact="$waypoint"/>
                          <set_value name="$PreviousDefinition.$subdefinition" exact="$FirstLadderDefinition"/>
                          <append_to_list name="$Top.$TempSlotStorer" exact="$waypoint"/>
                          <do_if value="$waypoint.hastag.ladder_top">
                            <!--When walking to the ladder, adjust the offset and rotation to match the animation of the character-->
                            <do_if value="$NPC.race == race.paranid">
                              <set_value name="$FirstLadderDefinition.$targetoffset" exact="position.[0m, 0m, 0.6m]"/>
                            </do_if>
                            <do_else>
                              <!--Default-->
                              <set_value name="$FirstLadderDefinition.$targetoffset" exact="position.[0m, 0m, 0.5m]"/>
                            </do_else>
                            <set_value name="$FirstLadderDefinition.$targetrotation" exact="rotation.[180deg, 0deg, 0deg]"/>
                          </do_if>

                          <!--Defintion to the second ladder waypoint-->
                          <set_value name="$SecondLadderDefinition" exact="table[]"/>
                          <set_value name="$SecondLadderDefinition.$context" exact="$OppositeLadderSlot.component"/>
                          <set_value name="$SecondLadderDefinition.$targetslot" exact="$OppositeLadderSlot"/>
                          <append_to_list name="$Top.$TempSlotStorer" exact="$OppositeLadderSlot"/>

                          <set_value name="$FirstLadderDefinition.$subdefinition" exact="$SecondLadderDefinition"/>

                          <!--Recursive call to GetNextSubTargetPoint-->
                          <run_actions ref="GetNextSubTargetPoint" result="$NextSubTarget_Result">
                            <param name="NPC" value="$NPC"/>
                            <param name="Top" value="$Top"/>
                            <param name="AllowDistantTeleportation" value="$AllowDistantTeleportation"/>

                            <param name="PreviousDefinition" value="$SecondLadderDefinition"/>
                            <param name="IterationDepth" value="$IterationDepth + 1"/>
                            <param name="DebugChance" value="@$DebugChance"/>
                          </run_actions>

                          <do_if value="$NextSubTarget_Result">
                            <!--
                          ################
                          RETURN
                          Using this ladder lead to a successful path to the destination. I guess you could call it a leadder.
                          ################-->
                            <return value="true"/>
                          </do_if>
                          <do_else>
                            <!--ladder did not lead to the destination. Cleanup and try next $waypoint-->
                            <set_value name="$PreviousDefinition.$subdefinition" exact="null"/>
                            <remove_value name="$FirstLadderDefinition"/>
                            <remove_value name="$SecondLadderDefinition"/>
                          </do_else>
                        </do_if>
                      </do_if>
                      <do_else>
                        <assert value="false" text="'Unable to find the opposite ladder slot for ' + $waypoint + ' [Owen]'" break="1"/>
                      </do_else>
                    </do_elseif>
                    <do_elseif value="$waypoint.hasanytag.[tag.elevator_wait_top, tag.elevator_bottom]">
                      <!--
                      ###################
                      Elevators
                      ###################-->
                      <!--The elevator_bottom slot should always be at a valid position of the navmesh, as it rests at where the outside object floor should be.
                      The elevator_top slot however is positioned at the top of the elevator, and may not be valid if the platform is down.
                      We use elevator_wait_top to check paths when approaching the elevator from the top, or to the next destination if coming up the elevator.
                      The elevator_wait_top slot is replaced with the elevator_top slot when the path has been checked.-->
                      <!--TODO @Owen #group check group-->
                      <do_if value="$waypoint.hastag.elevator_wait_top">
                        <debug_text text="$DebugIndent + 'Attempting to find the elevator_bottom tagged elevator slot related to ' + $waypoint" chance="@$DebugChance"/>
                        <find_npc_waypoint name="$OppositeElevatorSlots" object="$waypoint.component" tags="tag.elevator_bottom" multiple="true"/>
                      </do_if>
                      <do_else>
                        <debug_text text="$DebugIndent + 'Attempting to find the elevator_wait_top tagged elevator slot related to ' + $waypoint" chance="@$DebugChance"/>
                        <find_npc_waypoint name="$OppositeElevatorSlots" object="$waypoint.component" tags="tag.elevator_wait_top" multiple="true"/>
                      </do_else>
                      <set_value name="$OppositeElevatorSlot" exact="null"/>
                      <do_for_each name="$PotentialOppositeElevatorSlot" in="$OppositeElevatorSlots">
                        <do_if value="$waypoint.group == $PotentialOppositeElevatorSlot.group">
                          <set_value name="$OppositeElevatorSlot" exact="$PotentialOppositeElevatorSlot"/>
                          <break/>
                        </do_if>
                      </do_for_each>
                      <do_if value="$OppositeElevatorSlot">
                        <debug_text text="$DebugIndent + 'Opposite elevator slot found: ' + $OppositeElevatorSlot" chance="@$DebugChance"/>
                        <!--Create a new definition for the start and end elevator waypoints and call GetNextSubTargetPoint again-->

                        <!--Defintion to the first elevator waypoint-->
                        <set_value name="$FirstElevatorDefinition" exact="table[]"/>
                        <set_value name="$FirstElevatorDefinition.$context" exact="$waypoint.component"/>
                        <set_value name="$FirstElevatorDefinition.$targetslot" exact="$waypoint"/>
                        <set_value name="$PreviousDefinition.$subdefinition" exact="$FirstElevatorDefinition"/>
                        <append_to_list name="$Top.$TempSlotStorer" exact="$waypoint"/>

                        <!--Defintion to the second elevator waypoint-->
                        <set_value name="$SecondElevatorDefinition" exact="table[]"/>
                        <set_value name="$SecondElevatorDefinition.$context" exact="$OppositeElevatorSlot.component"/>
                        <set_value name="$SecondElevatorDefinition.$targetslot" exact="$OppositeElevatorSlot"/>
                        <append_to_list name="$Top.$TempSlotStorer" exact="$OppositeElevatorSlot"/>

                        <set_value name="$FirstElevatorDefinition.$subdefinition" exact="$SecondElevatorDefinition"/>

                        <!--Recursive call to GetNextSubTargetPoint-->
                        <run_actions ref="GetNextSubTargetPoint" result="$NextSubTarget_Result">
                          <param name="NPC" value="$NPC"/>
                          <param name="Top" value="$Top"/>
                          <param name="AllowDistantTeleportation" value="$AllowDistantTeleportation"/>

                          <param name="PreviousDefinition" value="$SecondElevatorDefinition"/>
                          <param name="IterationDepth" value="$IterationDepth + 1"/>
                          <param name="DebugChance" value="@$DebugChance"/>
                        </run_actions>

                        <do_if value="$NextSubTarget_Result">
                          <!--
                          ################
                          RETURN
                          Using this elevator lead to a successful path to the destination.
                          ################-->
                          <return value="true"/>
                        </do_if>
                        <do_else>
                          <!--elevator did not lead to the destination. Cleanup and try next $waypoint-->
                          <set_value name="$PreviousDefinition.$subdefinition" exact="null"/>
                          <remove_value name="$FirstElevatorDefinition"/>
                          <remove_value name="$SecondElevatorDefinition"/>
                        </do_else>
                      </do_if>
                      <do_else>
                        <assert value="false" text="'Unable to find the opposite elevator slot for ' + $waypoint + ' [Owen]'" break="1"/>
                      </do_else>
                    </do_elseif>
                    <do_else>
                      <assert value="false" text="'Unable to recognise this type of waypoint. ' + $waypoint + ' with tags ' + $waypoint.tags + ' [Owen]'"/>
                    </do_else>
                  </do_if>
                </do_all>
              </do_else>
            </do_if>
            <do_else>
              <assert value="false" text="'neither $Top.$DestinationSlot nor $destoffsetlist was not valid or $SubTargetLists does not have a valid entry [Owen]'" break="1"/>
            </do_else>
            <return value="false"/>
          </actions>
        </library>

        <!--
        #####################
        Path post prossessing
        #####################-->

        <library name="PathPostProcessing" purpose="run_actions">
          <params>
            <param name="NPC"/>
            <param name="PathDefinition"/>
            <param name="AnimateAtEnd" default="true"/>

            <param name="DebugChance" default="0"/>
          </params>
          <actions>
            <!--The root definition is the first to be enacted and may change below. This is the value returned.-->
            <set_value name="$RootDefinition" exact="$PathDefinition"/>

            <!--loop over the definitions-->
            <set_value name="$CurrentDefinition" exact="$PathDefinition"/>
            <set_value name="$PreviousDefinition" exact="null"/>
            <set_value name="$Iterations" exact="0"/>
            <do_while value="$CurrentDefinition and $Iterations lt 100">
              <set_value name="$Iterations" operation="add"/>
              <set_value name="$NextDefinition" exact="null"/>
              <debug_text text="$NPC.debugname + ' Checking definition: ' + $CurrentDefinition" chance="@$DebugChance"/>

              <!--
              ########################
              Getting up from static seat
              Only checked if the first definition
              ########################-->
              <do_if value="$Iterations == 1 and @$NPC.roomslot.hasanytag.[tag.sit, tag.sit_bar, tag.sit_table] and not $NPC.roomslot.component.ischairslot.{$NPC.roomslot}">
                <!--Give a new name for this definition so it's clearer when we work with it below-->
                <set_value name="$StoodUpDefinition" exact="$CurrentDefinition"/>

                <!--Create a new defintion for getting up-->
                <set_value name="$GetUpDefinition" exact="table[]"/>
                <set_value name="$GetUpDefinition.$stand_up_static" exact="true"/>
                <set_value name="$GetUpDefinition.$targetslot" exact="$NPC.roomslot"/>

                <!--Adjust all other definitions so they're in the right order-->
                <set_value name="$RootDefinition" exact="$GetUpDefinition"/>
                <set_value name="$GetUpDefinition.$subdefinition" exact="$StoodUpDefinition"/>

                <!--The next definition to look at is the one after $StoodUpDefinition-->
                <set_value name="$PreviousDefinition" exact="$StoodUpDefinition"/>
                <set_value name="$NextDefinition" exact="$StoodUpDefinition.$subdefinition"/>

                <!--Precache the get up animation-->
                <precache_actor_animation_hint actor="$NPC" type="'standupwithprep'" behavior="'generic'"/>

              </do_if>

              <!--
              ########################
              Walking to top of ladder
              ########################-->
              <do_elseif value="@$CurrentDefinition.$targetslot.hastag.ladder_top">
                <!--Give a new name for this definition so it's clearer when we work with it below-->
                <set_value name="$AtTopDefinition" exact="$CurrentDefinition"/>
                <!--Hint the climb down animation while approaching the ladder-->
                <set_value name="$AtTopDefinition.$hintedanimation" exact="['climbingdown', 'generic']"/>

                <!--The next definition should be at the bottom of the ladder-->
                <set_value name="$AtBottomDefinition" exact="$AtTopDefinition.$subdefinition"/>
                <assert value="$AtBottomDefinition.$targetslot.hastag.ladder_bottom" text="'Next point in path was not to the bottom of a ladder as expected. Next slot: ' + $AtBottomDefinition.$targetslot + ' [Owen]'"/>

                <!--Add a new definition for the climb down animation-->
                <set_value name="$ClimbDownDefinition" exact="table[]"/>
                <set_value name="$ClimbDownDefinition.$context" exact="$AtTopDefinition.$context"/>
                <set_value name="$ClimbDownDefinition.$targetslot" exact="$AtTopDefinition.$targetslot"/>

                <!--insert the climb down definition between the two-->
                <set_value name="$AtTopDefinition.$subdefinition" exact="$ClimbDownDefinition"/>
                <set_value name="$ClimbDownDefinition.$subdefinition" exact="$AtBottomDefinition"/>

                <!--Flag the definitions-->
                <set_value name="$ClimbDownDefinition.$climbingladder_down" exact="true"/>
                <set_value name="$AtBottomDefinition.$climbedladder_atbottom" exact="true"/>

                <!--The next definition to look at is the one after $AtBottomDefinition-->
                <set_value name="$PreviousDefinition" exact="$AtBottomDefinition"/>
                <set_value name="$NextDefinition" exact="$AtBottomDefinition.$subdefinition"/>
              </do_elseif>

              <!--
              ########################
              Walking to bottom of ladder
              ########################-->
              <do_elseif value="@$CurrentDefinition.$targetslot.hastag.ladder_bottom">
                <!--Give a new name for this definition so it's clearer when we work with it below-->
                <set_value name="$AtBottomDefinition" exact="$CurrentDefinition"/>
                <set_value name="$AtBottomDefinition.$targetoffset" exact="position.[0m, 0m, -0.12m]"/>
                <!--Hint the climb up animation while approaching the ladder-->
                <set_value name="$AtBottomDefinition.$hintedanimation" exact="['climbingup', 'generic']"/>

                <!--The next definition should be at the top of the ladder-->
                <set_value name="$AtTopDefinition" exact="$AtBottomDefinition.$subdefinition"/>
                <assert value="$AtTopDefinition.$targetslot.hastag.ladder_top" text="'Next point in path was not to the top of a ladder as expected. Next slot: ' + $AtTopDefinition.$targetslot + ' [Owen]'"/>

                <!--Add a new definition for the climbing animation-->
                <set_value name="$ClimbUpDefinition" exact="table[]"/>
                <set_value name="$ClimbUpDefinition.$context" exact="$AtBottomDefinition.$context"/>
                <set_value name="$ClimbUpDefinition.$targetslot" exact="$AtBottomDefinition.$targetslot"/>

                <!--insert the climbing definition between the two-->
                <set_value name="$AtBottomDefinition.$subdefinition" exact="$ClimbUpDefinition"/>
                <set_value name="$ClimbUpDefinition.$subdefinition" exact="$AtTopDefinition"/>

                <!--Flag the definitions-->
                <set_value name="$ClimbUpDefinition.$climbingladder_up" exact="true"/>
                <set_value name="$AtTopDefinition.$climbedladder_attop" exact="true"/>

                <!--The next definition to look at is the one after $AtTopDefinition-->
                <set_value name="$PreviousDefinition" exact="$AtTopDefinition"/>
                <set_value name="$NextDefinition" exact="$AtTopDefinition.$subdefinition"/>
              </do_elseif>
              <!--
              ########################
              Walking to the top of an elevator
              ########################-->
              <do_elseif value="@$CurrentDefinition.$targetslot.hasanytag.[tag.elevator_top, tag.elevator_wait_top]">
                <!--Give a new name for this definition so it's clearer when we work with it below-->
                <set_value name="$ApproachTopDefinition" exact="$CurrentDefinition"/>
                <set_value name="$ApproachTopDefinition.$elevator_approach_top"/>

                <!--The next definition should be for standing on the lowered elevator-->
                <set_value name="$AtBottomDefinition" exact="$ApproachTopDefinition.$subdefinition"/>
                <assert value="$AtBottomDefinition.$targetslot.hastag.elevator_bottom" text="'Next point in path was not to the lowered elevator as expected. Next slot: ' + $AtBottomDefinition.$targetslot + ' [Owen]'"/>

                <!--Flag the at bottom definition-->
                <set_value name="$AtBottomDefinition.$elevator_atbottom" exact="true"/>

                <!--The next definition to look at is the one after $AtBottomDefinition-->
                <set_value name="$PreviousDefinition" exact="$AtBottomDefinition"/>
                <set_value name="$NextDefinition" exact="$AtBottomDefinition.$subdefinition"/>
              </do_elseif>

              <!--
              ########################
              Walking to the bottom of an elevator
              ########################-->
              <do_elseif value="@$CurrentDefinition.$targetslot.hastag.elevator_bottom">
                <!--Give a new name for this definition so it's clearer when we work with it below-->
                <set_value name="$AtBottomDefinition" exact="$CurrentDefinition"/>
                <set_value name="$AtBottomDefinition.$elevator_approach_bottom"/>

                <!--The next definition should be for standing on the raised elevator-->
                <set_value name="$AtTopDefinition" exact="$AtBottomDefinition.$subdefinition"/>
                <do_if value="$AtTopDefinition.$targetslot.hastag.elevator_wait_top">
                  <!--Replace the elevator_wait_top slot which was used for path checking with the correct elevator_top slot-->
                  <!--TODO @Owen #group check group-->
                  <find_npc_waypoint name="$TopOfElevatorSlots" object="$AtTopDefinition.$context" tags="tag.elevator_top" multiple="true"/>
                  <set_value name="$TopOfElevatorSlot" exact="null"/>
                  <do_for_each name="$PotentialTopOfElevatorSlot" in="$TopOfElevatorSlots">
                    <do_if value="$CurrentDefinition.$targetslot.group == $PotentialTopOfElevatorSlot.group">
                      <set_value name="$TopOfElevatorSlot" exact="$PotentialTopOfElevatorSlot"/>
                      <break/>
                    </do_if>
                  </do_for_each>
                  <remove_value name="$TopOfElevatorSlots"/>
                  <do_if value="$TopOfElevatorSlot">
                    <set_value name="$AtTopDefinition.$targetslot" exact="$TopOfElevatorSlot"/>
                  </do_if>
                </do_if>
                <assert value="$AtTopDefinition.$targetslot.hastag.elevator_top" text="'Next point in path was not to the raised elevator as expected. Next slot: ' + $AtTopDefinition.$targetslot + ' [Owen]'"/>

                <!--Flag the definition-->
                <set_value name="$AtTopDefinition.$elevator_attop" exact="true"/>

                <!--The next definition to look at is the one after $AtTopDefinition-->
                <set_value name="$PreviousDefinition" exact="$AtTopDefinition"/>
                <set_value name="$NextDefinition" exact="$AtTopDefinition.$subdefinition"/>
              </do_elseif>
              <!--
              ########################
              Leave animated chair
              ########################-->
              <do_elseif value="@$CurrentDefinition.$prepare_leave_chair">
                <!--Give a new name for this definition so it's clearer when we work with it below-->
                <set_value name="$TurnBackwardsDefinition" exact="$CurrentDefinition"/>
                <set_value name="$ChairSlot" exact="$TurnBackwardsDefinition.$targetslot"/>

                <!--The next definition should be at the chair approach pos-->
                <set_value name="$StoodUpDefinition" exact="$TurnBackwardsDefinition.$subdefinition"/>
                <do_if value="$ChairSlot.component.ischairslot.{$ChairSlot}">
                  <assert value="$TurnBackwardsDefinition.$targetslot.component.chairapproachslot.{$TurnBackwardsDefinition.$targetslot} == $StoodUpDefinition.$targetslot" text="'Next slot should reference the approach slot of the chair but instead references: ' + $StoodUpDefinition.$targetslot + ' [Owen]'"/>

                  <!--Create a new defintion for getting up-->
                  <set_value name="$GetUpDefinition" exact="table[]"/>
                  <set_value name="$GetUpDefinition.$context" exact="$TurnBackwardsDefinition.$context"/>
                  <set_value name="$GetUpDefinition.$targetslot" exact="$TurnBackwardsDefinition.$targetslot"/>

                  <!--insert the get up definition between the two-->
                  <set_value name="$TurnBackwardsDefinition.$subdefinition" exact="$GetUpDefinition"/>
                  <set_value name="$GetUpDefinition.$subdefinition" exact="$StoodUpDefinition"/>

                  <!--Flag the definitions-->
                  <set_value name="$TurnBackwardsDefinition.$chair_rotatebackward" exact="true"/>
                  <set_value name="$GetUpDefinition.$chair_getup" exact="true"/>
                  <set_value name="$StoodUpDefinition.$chair_leave" exact="true"/>
                  <set_value name="$StoodUpDefinition.$chairslot" exact="$ChairSlot"/>

                  <!--The next definition to look at is the one after $StoodUpDefinition-->
                  <set_value name="$PreviousDefinition" exact="$StoodUpDefinition"/>
                  <set_value name="$NextDefinition" exact="$StoodUpDefinition.$subdefinition"/>

                  <!--Precache the get up animation-->
                  <precache_actor_animation_hint actor="$NPC" type="'prepstandup'" behavior="'generic'"/>
                  <precache_actor_animation_hint actor="$NPC" type="'standup'" behavior="'generic'"/>
                </do_if>
                <do_else>
                  <assert value="false" text="'Definition to get out of chair did not reference a chair slot. Slot: ' + $ChairSlot + ' [Owen]'"/>
                </do_else>

              </do_elseif>

              <!--
              ########################
              Walk to animated chair
              ########################-->
              <do_elseif value="@$CurrentDefinition.$chair_walkto">
                <!--Give a new name for this definition so it's clearer when we work with it below-->
                <set_value name="$ApproachChairDefinition" exact="$CurrentDefinition"/>

                <!--The next definition should be the final chair slot position, and the ultimate destination-->
                <set_value name="$FacingForwardDefinition" exact="$ApproachChairDefinition.$subdefinition"/>
                <set_value name="$ChairSlot" exact="$FacingForwardDefinition.$targetslot"/>
                <do_if value="$ChairSlot.component.ischairslot.{$ChairSlot}">
                  <assert value="not @$FacingForwardDefinition.$subdefinition" text="'Definition was expected to be the final destination definition. It should not have a subdefinition. ' + $FacingForwardDefinition + ' [Owen]'"/>

                  <!--Create a new defintion for sitting down-->
                  <set_value name="$SitDownDefinition" exact="table[]"/>
                  <set_value name="$SitDownDefinition.$context" exact="$ChairSlot.component"/>
                  <set_value name="$SitDownDefinition.$targetslot" exact="$ChairSlot"/>
                  <set_value name="$SitDownDefinition.$targetoffset" exact="position.[-$ApproachChairDefinition.$targetoffset.x, -$ApproachChairDefinition.$targetoffset.y, -$ApproachChairDefinition.$targetoffset.z]"/>

                  <!--Create a new defintion for rotating forward-->
                  <set_value name="$RotateForwardDefinition" exact="table[]"/>
                  <set_value name="$RotateForwardDefinition.$context" exact="$ChairSlot.component"/>
                  <set_value name="$RotateForwardDefinition.$targetslot" exact="$ChairSlot"/>

                  <!--insert the new definitions between the approach and destination definitions-->
                  <set_value name="$ApproachChairDefinition.$subdefinition" exact="$SitDownDefinition"/>
                  <set_value name="$SitDownDefinition.$subdefinition" exact="$RotateForwardDefinition"/>
                  <set_value name="$RotateForwardDefinition.$subdefinition" exact="$FacingForwardDefinition"/>

                  <!--Flag the new definitions-->
                  <set_value name="$SitDownDefinition.$chair_sitdown" exact="true"/>
                  <set_value name="$RotateForwardDefinition.$chair_rotateforward" exact="true"/>
                  <set_value name="$FacingForwardDefinition.$chair_facingforward" exact="true"/>

                  <!--This is the end-->
                  <set_value name="$PreviousDefinition" exact="$FacingForwardDefinition"/>
                  <set_value name="$NextDefinition" exact="'end'"/>
                </do_if>
                <do_else>
                  <assert value="false" text="'Definition after chair approach does not reference a chair slot. Slot: ' + $ChairSlot + ' [Owen]'"/>
                </do_else>
              </do_elseif>

              <!--
              ########################
              Walk to static seat
              ########################-->
              <do_elseif value="$Iterations gt 1 and @$CurrentDefinition.$targetslot.hastag.sit">
                <!--Give a new name for this definition so it's clearer when we work with it below-->
                <set_value name="$SatDownDefinition" exact="$CurrentDefinition"/>
                <set_value name="$SatDownDefinition.$sat_down_at_static"/>

                <!--Create a new defintion for moving to the approach position-->
                <set_value name="$ApproachDefinition" exact="table[]"/>
                <set_value name="$ApproachDefinition.$context" exact="$CurrentDefinition.$targetslot.component"/>
                <set_value name="$ApproachDefinition.$targetslot" exact="$CurrentDefinition.$targetslot"/>
                <do_if value="$NPC.race == race.argon or $NPC.race == race.terran or $NPC.race == race.split">
                  <do_if value="$NPC.isfemale">
                    <set_value name="$ApproachDefinition.$targetoffset" exact="position.[0m, 0m, 0.25m]"/>
                  </do_if>
                  <do_else>
                    <set_value name="$ApproachDefinition.$targetoffset" exact="position.[0m, 0m, 0.27m]"/>
                  </do_else>
                </do_if>
                <do_elseif value="$NPC.race == race.teladi">
                  <set_value name="$ApproachDefinition.$targetoffset" exact="position.[0m, 0m, 0.25m]"/>
                </do_elseif>
                <do_else>
                  <debug_text text="'NPC ' + $NPC.debugname + ' is attempting to sit at a static seat slot which is not allowed for ' + $NPC.race" filter="error"/>
                  <set_value name="$ApproachDefinition.$targetoffset" exact="position.[0m, 0m, 0.27m]"/>
                </do_else>
                <set_value name="$ApproachDefinition.$targetrotation" exact="rotation.[180deg, 0deg, 0deg]"/>
                <set_value name="$ApproachDefinition.$preventanimation"/>
                <set_value name="$ApproachDefinition.$hintedanimation" exact="['sitdown', 'generic']"/>
                <set_value name="$ApproachDefinition.$approach_static_seat"/>

                <!--Create a new defintion for starting the sit down animation-->
                <set_value name="$SitDownDefinition" exact="table[]"/>
                <set_value name="$SitDownDefinition.$context" exact="$CurrentDefinition.$targetslot.component"/>
                <set_value name="$SitDownDefinition.$targetslot" exact="$CurrentDefinition.$targetslot"/>
                <set_value name="$SitDownDefinition.$sit_down_static" exact="true"/>

                <do_if value="$CurrentDefinition == $PathDefinition">
                  <!--Set the approach definition to the RootDefinition if it is the first-->
                  <set_value name="$RootDefinition" exact="$ApproachDefinition"/>
                </do_if>
                <do_elseif value="$PreviousDefinition">
                  <!--Otherwise, adjust the previous definition's subdefinition-->
                  <set_value name="$PreviousDefinition.$subdefinition" exact="$ApproachDefinition"/>
                </do_elseif>

                <!--Adjust other definitions so they're in the right order-->
                <set_value name="$ApproachDefinition.$subdefinition" exact="$SitDownDefinition"/>
                <set_value name="$SitDownDefinition.$subdefinition" exact="$SatDownDefinition"/>

                <set_value name="$PreviousDefinition" exact="$SatDownDefinition"/>
                <set_value name="$NextDefinition" exact="'end'"/>
              </do_elseif>

              <!--
              ########################
              Walking into an elevator or cabin
              ########################-->
              <do_elseif value="@$CurrentDefinition.$targetslot.hastag.npctransport">
                <do_if value="$CurrentDefinition.$targetslot.group == tag.cabin_01">
                  <!--Cabin-->
                  <do_if value="$CurrentDefinition == $PathDefinition or @$CurrentDefinition.$exitingtransporter">
                    <!--The NPC is spawning in or leaving a cabin.-->

                    <!--Give a new name for this definition so it's clearer when we work with it below-->
                    <set_value name="$AppearInCabinDefinition" exact="$CurrentDefinition"/>
                    <!--TODO @Owen if warping to a cabin, the doors are open-->

                    <!--Create a new definition to close the doors-->
                    <set_value name="$CloseDoorsDefinition" exact="table[]"/>
                    <set_value name="$CloseDoorsDefinition.$context" exact="$AppearInCabinDefinition.$context"/>
                    <set_value name="$CloseDoorsDefinition.$targetslot" exact="$AppearInCabinDefinition.$targetslot"/>

                    <do_if value="$CurrentDefinition == $PathDefinition">
                      <!--Set the close door as the first definition, followed by the appear definition-->
                      <set_value name="$RootDefinition" exact="$CloseDoorsDefinition"/>
                    </do_if>
                    <do_elseif value="$PreviousDefinition">
                      <set_value name="$PreviousDefinition.$subdefinition" exact="$CloseDoorsDefinition"/>
                    </do_elseif>
                    <set_value name="$CloseDoorsDefinition.$subdefinition" exact="$AppearInCabinDefinition"/>

                    <!--Flag the definitions-->
                    <set_value name="$CloseDoorsDefinition.$cabinspawn_closedoor" exact="true"/>
                    <do_if value="$PreviousDefinition">
                      <!--Should people pods be launched when this part of the path is being performed? Whether a pod is launched depends on the state of the objects at the moment that this definition is performed.-->
                      <set_value name="$CloseDoorsDefinition.$possiblepodlaunch" exact="$NPC.isplayerowned" comment="extend pod launch checks here if needed"/>
                      <set_value name="$CloseDoorsDefinition.$previouscontext" exact="$PreviousDefinition.$context"/>
                    </do_if>

                    <set_value name="$AppearInCabinDefinition.$cabinspawn_appear" exact="true"/>

                    <!--The next definition to look at is the one after $AppearInCabinDefinition-->
                    <set_value name="$PreviousDefinition" exact="$AppearInCabinDefinition"/>
                    <do_if value="@$AppearInCabinDefinition.$subdefinition">
                      <set_value name="$NextDefinition" exact="$AppearInCabinDefinition.$subdefinition"/>
                    </do_if>
                    <do_else>
                      <set_value name="$NextDefinition" exact="'end'"/>
                    </do_else>
                  </do_if>
                  <do_else>
                    <!--NPC is walking to a cabin (may not be the end of their path)-->

                    <!--Give a new name for this definition so it's clearer when we work with it below-->
                    <set_value name="$WalkIntoCabinAndCloseDefinition" exact="$CurrentDefinition"/>

                    <!--Create a new definition to hide the NPC after the doors have closed-->
                    <set_value name="$HideNPCDefinition" exact="table[]"/>
                    <set_value name="$HideNPCDefinition.$context" exact="$WalkIntoCabinAndCloseDefinition.$context"/>
                    <set_value name="$HideNPCDefinition.$targetslot" exact="$WalkIntoCabinAndCloseDefinition.$targetslot"/>

                    <!--Append the hide definition to follow the walk into cabin definition-->
                    <set_value name="$HideNPCDefinition.$subdefinition" exact="@$WalkIntoCabinAndCloseDefinition.$subdefinition"/>
                    <set_value name="$WalkIntoCabinAndCloseDefinition.$subdefinition" exact="$HideNPCDefinition"/>

                    <!--Flag the definitions-->
                    <set_value name="$WalkIntoCabinAndCloseDefinition.$walkintocabin" exact="true"/>
                    <set_value name="$HideNPCDefinition.$hideincabin" exact="true"/>

                    <set_value name="$PreviousDefinition" exact="$HideNPCDefinition"/>
                    <do_if value="@$HideNPCDefinition.$subdefinition">
                      <!--The next definition to look at is the one after $HideNPCDefinition-->
                      <set_value name="$NextDefinition" exact="$HideNPCDefinition.$subdefinition"/>
                    </do_if>
                    <do_else>
                      <set_value name="$NextDefinition" exact="'end'"/>
                    </do_else>
                  </do_else>
                </do_if>

                <do_else>
                  <!--Other elevator-->
                  <do_if value="$CurrentDefinition == $PathDefinition or @$CurrentDefinition.$exitingtransporter">
                    <!--The NPC is spawning in or leaving a transporter.-->

                    <!--Give a new name for this definition so it's clearer when we work with it below-->
                    <set_value name="$AppearInTransporterDefinition" exact="$CurrentDefinition"/>

                    <!--Create a new definition to close the doors-->
                    <set_value name="$CloseDoorsDefinition" exact="table[]"/>
                    <set_value name="$CloseDoorsDefinition.$context" exact="$AppearInTransporterDefinition.$context"/>
                    <set_value name="$CloseDoorsDefinition.$targetslot" exact="$AppearInTransporterDefinition.$targetslot"/>

                    <do_if value="$CurrentDefinition == $PathDefinition">
                      <!--Set the close door as the first definition, followed by the appear definition-->
                      <set_value name="$RootDefinition" exact="$CloseDoorsDefinition"/>
                    </do_if>
                    <do_elseif value="$PreviousDefinition">
                      <set_value name="$PreviousDefinition.$subdefinition" exact="$CloseDoorsDefinition"/>
                    </do_elseif>
                    <set_value name="$CloseDoorsDefinition.$subdefinition" exact="$AppearInTransporterDefinition"/>

                    <!--Flag the definitions-->
                    <set_value name="$CloseDoorsDefinition.$lockingtransporter" exact="true"/>
                    <do_if value="$PreviousDefinition">
                      <!--Should people pods be launched when this part of the path is being performed? Whether a pod is launched depends on the state of the objects at the moment that this definition is performed.-->
                      <set_value name="$CloseDoorsDefinition.$possiblepodlaunch" exact="$NPC.isplayerowned" comment="extend pod launch checks here if needed"/>
                      <set_value name="$CloseDoorsDefinition.$previouscontext" exact="$PreviousDefinition.$context"/>
                    </do_if>
                    <set_value name="$AppearInTransporterDefinition.$exitingtransporter" exact="true"/>

                    <!--The next definition to look at is the one after $AppearInTransporterDefinition-->
                    <set_value name="$PreviousDefinition" exact="$AppearInTransporterDefinition"/>
                    <do_if value="@$AppearInTransporterDefinition.$subdefinition">
                      <set_value name="$NextDefinition" exact="$AppearInTransporterDefinition.$subdefinition"/>
                    </do_if>
                    <do_else>
                      <set_value name="$NextDefinition" exact="'end'"/>
                    </do_else>
                  </do_if>
                  <do_else>
                    <!--NPC is walking to a transporter-->

                    <!--Give a new name for this definition so it's clearer when we work with it below-->
                    <set_value name="$WalkIntoTransporterAndCloseDefinition" exact="$CurrentDefinition"/>

                    <!--Create a new definition to snap the NPC to the slot after the doors have closed so the path can continue or conclude-->
                    <set_value name="$HideNPCDefinition" exact="table[]"/>
                    <set_value name="$HideNPCDefinition.$context" exact="$WalkIntoTransporterAndCloseDefinition.$context"/>
                    <set_value name="$HideNPCDefinition.$targetslot" exact="$WalkIntoTransporterAndCloseDefinition.$targetslot"/>

                    <!--Append the hide definition to follow the walk into cabin definition-->
                    <set_value name="$HideNPCDefinition.$subdefinition" exact="@$WalkIntoTransporterAndCloseDefinition.$subdefinition"/>
                    <set_value name="$WalkIntoTransporterAndCloseDefinition.$subdefinition" exact="$HideNPCDefinition"/>

                    <set_value name="$WalkIntoTransporterAndCloseDefinition.$enteringtransporter" exact="true"/>
                    <set_value name="$HideNPCDefinition.$warp" exact="true"/>
                    <set_value name="$HideNPCDefinition.$activatetransporter" exact="true"/>

                    <set_value name="$PreviousDefinition" exact="$HideNPCDefinition"/>
                    <do_if value="@$HideNPCDefinition.$subdefinition">
                      <!--The next definition to look at is the one after $HideNPCDefinition-->
                      <set_value name="$NextDefinition" exact="$HideNPCDefinition.$subdefinition"/>
                    </do_if>
                    <do_else>
                      <set_value name="$NextDefinition" exact="'end'"/>
                    </do_else>
                  </do_else>
                </do_else>

              </do_elseif>

              <do_if value="$NextDefinition">
                <do_if value="$NextDefinition == 'end'">
                  <set_value name="$CurrentDefinition" exact="null"/>
                </do_if>
                <do_else>
                  <set_value name="$CurrentDefinition" exact="$NextDefinition"/>
                </do_else>
              </do_if>
              <do_else>
                <set_value name="$PreviousDefinition" exact="$CurrentDefinition"/>
                <set_value name="$CurrentDefinition" exact="@$CurrentDefinition.$subdefinition"/>
              </do_else>

              <do_if value="not $CurrentDefinition and $PreviousDefinition">
                <!--Set flags on the final definition-->
                <do_if value="not $AnimateAtEnd">
                  <set_value name="$PreviousDefinition.$preventanimation"/>
                </do_if>
              </do_if>
            </do_while>

            <assert value="$Iterations lt 100" text="'Too many iterations try and post process the path. Likely a loop. [Owen]'"/>
            <return value="$RootDefinition"/>
          </actions>
        </library>

        <library name="PerformPath" namespace="this">
          <params>
            <param name="NPC"/>
            <param name="pathtable"/>
            <param name="signalcue"/>
            <param name="DebugChance" default="0"/>
          </params>
          <actions>
            <set_value name="$NPC.$state_machine_critical" exact="false"/>
          </actions>
          <cues>
            <cue name="PerformPath_Evaluate" checkinterval="1ms" version="2">
              <conditions>
                <check_value value="$NPC != player.conversationactor"/>
              </conditions>
              <actions>
                <debug_text text="$NPC.debugname + ' into PerformPath_Evaluate'" chance="@$DebugChance"/>

                <set_value name="$nextpath" exact="null"/>
                <set_value name="$finished" exact="false"/>
                <set_value name="$waitforwalk" exact="false"/>
                <set_value name="$endanimation" exact="null"/>
                <set_value name="$NPC.$state_machine_critical" exact="false"/>
                <!--if there is a pod arrival time, that must elapse before a NPC will start their path.
                The other approach would be to make the state machine critical during a pod arrival but that would prevent interrupting state for too long e.g. having a pilot become busy so the player can take control.-->

                <do_if value="$pathtable and $pathtable.$subdefinition? and not $NPC.podarrivaltime">
                  <do_if value="@$pathtable.$speed gt 0">
                    <!--TODO @Owen look ahead to see if this walk is too short to run. For now, just prevent on small ships.-->
                    <do_if value="$pathtable.$speed gt $NPC.walkspeed and $NPC.object.isclass.ship_s">
                      <set_value name="$speed" exact="$NPC.walkspeed"/>
                      <debug_text text="'reducing $speed from ' + $pathtable.$speed + ' to walkspeed' + $speed + ' roomparent ' + $NPC.room.parent.name" chance="@$DebugChance"/>
                    </do_if>
                    <do_else>
                      <set_value name="$speed" exact="$pathtable.$speed"/>
                      <debug_text text="'keeping $speed ' + $speed + ' roomparent ' + $NPC.room.parent.name" chance="@$DebugChance"/>
                    </do_else>
                  </do_if>
                  <do_else>
                    <set_value name="$speed" exact="$NPC.walkspeed"/>
                    <debug_text text="'setting $speed to ' + $speed + ' roomparent ' + $NPC.room.parent.name" chance="@$DebugChance"/>
                  </do_else>
                  <!--$pathtable can be the first movement definition if the NPC is to warp to the start e.g. when starting from an elevator.-->
                  <set_value name="$subdefinition" exact="$pathtable"/>
                  <set_value name="$previousdefinition" exact="null"/>
                  <do_while value="$subdefinition">
                    <do_if value="not @$subdefinition.$targetslot and not @$subdefinition.$targetoffset">
                      <set_value name="$subdefinition.$finished" exact="true"/>
                    </do_if>
                    <remove_value name="$hintedanimations"/>

                    <do_if value="not @$subdefinition.$finished">
                      <set_entity_traits entity="$NPC" intransit="true"/>
                      <!--this point has not been done yet-->
                      <debug_text text="'Performing subdefinition: ' + $subdefinition" chance="@$DebugChance"/>
                      <do_if value="$subdefinition.$hintedanimation? and $NPC.attention ge attention.nearby">
                        <set_value name="$hintedanimation" exact="$subdefinition.$hintedanimation"/>
                      </do_if>
                      <!--
                      #########
                      TRANSPORTER
                      #########-->
                      <do_if value="@$subdefinition.$enteringtransporter">
                        <do_if value="@$subdefinition.$walkdone">
                          <!--walk was done-->
                          <debug_text text="player.age + ' walked to transporter ' + $subdefinition.$targetslot + ' with group ' + $subdefinition.$targetslot.group" chance="@$DebugChance"/>
                          <set_triggers_locked object="$subdefinition.$targetslot.component" group="if $subdefinition.$targetslot.group then $subdefinition.$targetslot.group else tag.transporter_01" locked="true" duration="2.5s" />
                          <!-- set_value name="$subdefinition.$finished" exact="true"/ -->
                          <!-- wait for the door to close before continuing with next state (exitingtransporter) -->
                          <signal_cue_instantly cue="PerformPath__Force_Next" param="[$subdefinition, 2s]"/>
                        </do_if>
                        <do_else>
                          <!--walk to the transporter-->
                          <debug_text text="player.age + ' walk to transporter ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                          <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed" triggeranimation="not @$subdefinition.$preventanimation">
                            <!--<rotation yaw="180deg"/>-->
                          </start_actor_walk>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_if>
                      <do_elseif value="@$subdefinition.$lockingtransporter">
                        <set_value name="$launchpod" exact="false"/>
                        <do_if value="not @$subdefinition.$podarrived and @$subdefinition.$possiblepodlaunch and @$subdefinition.$previouscontext.exists
                               and $subdefinition.$previouscontext != $subdefinition.$context
                               and not $subdefinition.$previouscontext.hascontext.{$subdefinition.$context}
                               and not $subdefinition.$context.hascontext.{$subdefinition.$previouscontext}
                               and $subdefinition.$context.commoncontext.{$subdefinition.$previouscontext}.isclass.space
                               and ($NPC.assignedcontrolled or $NPC.roleobject)">
                          <set_value name="$launchpod" exact="true"/>
                        </do_if>
                        <do_if value="$launchpod">
                          <set_entity_traits entity="$NPC" hidden="true"/>
                          <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                          <signal_cue_instantly cue="md.Conversations.LaunchCrewTransferPod" param="[$NPC, 
                                                if $subdefinition.$previouscontext.isclass.object then $subdefinition.$previouscontext else $subdefinition.$previouscontext.object,
                                                if $subdefinition.$context.isclass.object then $subdefinition.$context else $subdefinition.$context.object]"/>
                        </do_if>
                        <do_else>
                          <set_value name="this.$finishdelay" exact="-1s"/>
                          <do_if value="@$previousdefinition.$activatetransporter and @$previousdefinition.$targetslot.hastag.npctransport and @$subdefinition.$targetslot.hastag.npctransport">
                            <activate_transporter start="$previousdefinition.$targetslot" destination="$subdefinition.$targetslot" entity="$NPC" result="$transportedentities"/>
                            <do_if value="$transportedentities.indexof.{$NPC}">
                              <debug_text text="$NPC + ' ' + $NPC.knownname + ' successfully activated transporter. Moving entities: ' + $transportedentities" chance="@$DebugChance"/>
                              <!--Fallback time. The NPC should be moved by activate_transporter and reevaluate the path on event_entity_transport_finished-->
                              <set_value name="this.$finishdelay" exact="5s"/>
                            </do_if>
                            <do_else>
                              <debug_text text="$NPC + ' ' + $NPC.knownname + ' failed to activate transporter. Will warp to destination slot.'" chance="@$DebugChance"/>
                              <set_entity_traits entity="$NPC" hidden="true"/>
                              <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                            </do_else>
                            <remove_value name="$transportedentities"/>
                          </do_if>
                          <do_else>
                            <set_entity_traits entity="$NPC" hidden="true"/>
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                            <do_if value="not $subdefinition.$targetslot.hastag.virtual_waypoint">
                              <check_animation_state result="this.$transporterisopen" object="$subdefinition.$targetslot.component" group="$subdefinition.$targetslot.group" state="'active'"/>
                              <do_if value="this.$transporterisopen">
                                <debug_text text="player.age + ' locking doors of ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                                <set_triggers_locked object="$subdefinition.$targetslot.component" group="$subdefinition.$targetslot.group" locked="true" duration="2.5s" />
                                <!-- wait for the door to close before un-hiding the NPC -->
                                <set_value name="this.$finishdelay" exact="2s"/>
                              </do_if>
                              <do_else>
                                <debug_text text="player.age + ' doors are closed so no need to lock doors of ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                              </do_else>
                            </do_if>
                          </do_else>
                          <do_if value="this.$finishdelay gt 0s">
                            <signal_cue_instantly cue="PerformPath__Force_Next" param="[$subdefinition, 1.5s]"/>
                          </do_if>
                          <do_else>
                            <set_value name="$subdefinition.$finished" exact="true"/>
                          </do_else>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$hideintransporter">
                        <set_entity_traits entity="$NPC" hidden="true"/>
                        <debug_text text="player.age + ' hiding NPC in transporter ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$exitingtransporter">
                        <debug_text text="player.age + ' appeared in ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                        <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                        <set_entity_traits entity="$NPC" hidden="false"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$approachingtransporter">
                        <do_if value="@$subdefinition.$walkdone">
                          <!--walk was done-->
                          <debug_text text="player.age + ' walked to transporter ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                          <do_if value="not $subdefinition.$targetslot.hastag.virtual_waypoint">
                            <set_triggers_locked object="$subdefinition.$targetslot.component" group="tag.transporter_01" locked="true" duration="2.5s" />
                          </do_if>
                          <!-- wait for the door to close before hiding the NPC -->
                          <signal_cue_instantly cue="PerformPath__Force_Next" param="[$subdefinition, 2s]"/>
                        </do_if>
                        <do_else>
                          <!--walk into the cabin-->
                          <debug_text text="player.age + ' walk to transporter ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                          <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed" triggeranimation="not @$subdefinition.$preventanimation">
                            <rotation yaw="180deg"/>
                          </start_actor_walk>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <!--
                      #########
                      CABIN
                      #########-->
                      <do_elseif value="@$subdefinition.$walkintocabin">
                        <do_if value="@$subdefinition.$walkdone">
                          <!--walk was done-->
                          <debug_text text="player.age + ' walked to cabin ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                          <trigger_animation object="$subdefinition.$targetslot.component" group="'cabin_01'" trigger="close_doors"/>
                          <trigger_animation delay="2s" object="$subdefinition.$targetslot.component" group="'cabin_01'" trigger="open_doors"/>
                          <!-- wait for the door to close before hiding the NPC -->
                          <signal_cue_instantly cue="PerformPath__Force_Next" param="[$subdefinition, 2s]"/>
                        </do_if>
                        <do_else>
                          <!--walk into the cabin-->
                          <debug_text text="player.age + ' walk to cabin ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                          <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed" triggeranimation="not @$subdefinition.$preventanimation">
                            <rotation yaw="180deg"/>
                          </start_actor_walk>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <!--Note: post 3.20 support. $subdefinition.$closingcabin was renamed by $subdefinition.$hideincabin-->
                      <do_elseif value="@$subdefinition.$hideincabin or @$subdefinition.$closingcabin">
                        <set_entity_traits entity="$NPC" hidden="true"/>
                        <debug_text text="player.age + ' opening cabin door ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <!--Note: post 3.20 support. $subdefinition.$appearincabin was renamed by $subdefinition.$cabinspawn_closedoor-->
                      <do_elseif value="@$subdefinition.$cabinspawn_closedoor or @$subdefinition.$appearincabin">
                        <set_entity_traits entity="$NPC" hidden="true"/>
                        <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                        <set_value name="$launchpod" exact="false"/>
                        <do_if value="not @$subdefinition.$podarrived and @$subdefinition.$possiblepodlaunch and @$subdefinition.$previouscontext.exists 
                               and $subdefinition.$previouscontext != $subdefinition.$context
                               and not $subdefinition.$previouscontext.hascontext.{$subdefinition.$context}
                               and not $subdefinition.$context.hascontext.{$subdefinition.$previouscontext}
                               and $subdefinition.$context.commoncontext.{$subdefinition.$previouscontext}.isclass.space">
                          <set_value name="$launchpod" exact="true"/>
                        </do_if>
                        <do_if value="$launchpod">
                          <signal_cue_instantly cue="md.Conversations.LaunchCrewTransferPod" param="[$NPC,
                                                if $subdefinition.$previouscontext.isclass.object then $subdefinition.$previouscontext else $subdefinition.$previouscontext.object,
                                                if $subdefinition.$context.isclass.object then $subdefinition.$context else $subdefinition.$context.object]"/>
                        </do_if>
                        <do_else>
                          <!-- close cabin before spawning in NPC -->
                          <debug_text text="player.age + ' closing cabin for NPC to appear ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                          <trigger_animation object="$subdefinition.$targetslot.component" group="'cabin_01'" trigger="close_doors"/>
                          <trigger_animation delay="2s" object="$subdefinition.$targetslot.component" group="'cabin_01'" trigger="open_doors"/>
                          <!-- wait for the door to close -->
                          <signal_cue_instantly cue="PerformPath__Force_Next" param="[$subdefinition, 2s]"/>
                        </do_else>
                      </do_elseif>
                      <!--Note: post 3.20 support. $subdefinition.$exitingcabin was renamed by $subdefinition.$cabinspawn_appear-->
                      <do_elseif value="@$subdefinition.$cabinspawn_appear or @$subdefinition.$exitingcabin">
                        <!-- unhide NPC in teleporter cabin -->
                        <debug_text text="player.age + ' unhide NPC in cabin and open door ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                        <set_entity_traits entity="$NPC" hidden="false"/>
                        <do_if value="$NPC.hasbody">
                          <start_actor_sequence type="'idle'" behavior="'stand'" actor="$NPC" result="this.$animationstarted" />
                          <!-- cabin door is starting to open now -->
                          <!-- wait for the door to open a bit before start walking -->
                          <signal_cue_instantly cue="PerformPath__Force_Next" param="[$subdefinition, 1s]"/>
                        </do_if>
                        <do_else>
                          <debug_text text="'attention is ' + $NPC.attention + ' - no need to wait for door to open'" chance="@$DebugChance"/>
                          <set_value name="$subdefinition.$finished" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <!--
                      #########
                      LADDER
                      #########-->
                      <do_elseif value="@$subdefinition.$climbingladder_down">
                        <!--Climb down ladder-->
                        <do_if value="$NPC.hasbody">
                          <!--High attention - play climb down animation-->
                          <debug_text text="player.age + ' start climb down animation'" chance="@$DebugChance"/>
                          <set_value name="$NPC.$state_machine_critical" exact="true"/>
                          <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                          <!--Calculate ladder height-->
                          <set_value name="$height" exact="$subdefinition.$targetslot.distanceto.{$subdefinition.$subdefinition.$targetslot}"/>
                          <do_if value="$height gt 4.0">
                            <start_actor_sequence actor="$NPC" type="'climbingdown13'" behavior="'generic'" transition="true" immediate="true" result="this.$animationstarted"/>
                          </do_if>
                          <do_else>
                            <start_actor_sequence actor="$NPC" type="'climbingdown'" behavior="'generic'" transition="true" immediate="true" result="this.$animationstarted"/>
                          </do_else>
                          <do_if value="this.$animationstarted">
                            <set_value name="$endanimation" exact="'anim_stand_conversation_01'"/>
                          </do_if>
                          <do_else>
                            <debug_text text="'failed to start animation \'climbingdown\' on NPC ' + $NPC.knownname + ' ' + $NPC"/>
                            <set_value name="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <!--Low attention - skip animation. Will be connected at bottom of ladder in the next definition-->
                          <debug_text text="'attention is ' + $NPC.attention + ' - skipping climbing animation'" chance="@$DebugChance"/>
                          <set_value name="$subdefinition.$finished" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$climbingladder_up">
                        <!--Climb up ladder-->
                        <do_if value="$NPC.hasbody">
                          <!--High attention - play climb up animation-->
                          <debug_text text="player.age + ' climb up ladder'" chance="@$DebugChance"/>
                          <set_value name="$NPC.$state_machine_critical" exact="true"/>
                          <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                          <!--Calculate ladder height-->
                          <set_value name="$height" exact="$subdefinition.$targetslot.distanceto.{$subdefinition.$subdefinition.$targetslot}"/>
                          <do_if value="$height gt 4.0">
                            <start_actor_sequence actor="$NPC" type="'climbingup13'" behavior="'generic'" transition="true" immediate="true" result="this.$animationstarted"/>
                          </do_if>
                          <do_else>
                            <start_actor_sequence actor="$NPC" type="'climbingup'" behavior="'generic'" transition="true" immediate="true" result="this.$animationstarted"/>
                          </do_else>
                          <do_if value="this.$animationstarted">
                            <set_value name="$endanimation" exact="'climbuptop'"/>
                          </do_if>
                          <do_else>
                            <debug_text text="'failed to start animation \'climbingup\' on NPC ' + $NPC.knownname + ' ' + $NPC"/>
                            <set_value name="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <!--Low attention - skip animation. Will be connected at top of ladder in the next definition-->
                          <debug_text text="'attention is ' + $NPC.attention + ' - skipping climbing animation'" chance="@$DebugChance"/>
                          <set_value name="$subdefinition.$finished" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$climbedladder_attop or @$subdefinition.$climbedladder_atbottom">
                        <!--Connect to top or bottom of ladder-->
                        <debug_text text="player.age + ' ladder animation finished. connecting to ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                        <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                        <!--This is not a state_machine_critical moment as it happens instantly-->
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$elevator_approach_top or @$subdefinition.$elevator_approach_bottom">
                        <!--Trigger the approach elevator listener to handle queuing the elevator request-->
                        <signal_cue_instantly cue="PerformPath__Approach_Elevator_Listener" param="[$subdefinition.$targetslot, $subdefinition]"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$elevator_attop or @$subdefinition.$elevator_atbottom">
                        <!--TODO @Owen find by #group-->
                        <find_npc_waypoint name="this.$ElevatorSlots" object="$subdefinition.$targetslot.component" tags="tag.npc_elevator" multiple="true"/>
                        <set_value name="this.$ElevatorSlot" exact="null"/>
                        <do_for_each name="$PotentialElevatorSlot" in="this.$ElevatorSlots">
                          <do_if value="$subdefinition.$targetslot.group == $PotentialElevatorSlot.group">
                            <set_value name="this.$ElevatorSlot" exact="$PotentialElevatorSlot"/>
                            <break/>
                          </do_if>
                        </do_for_each>
                        <remove_value name="this.$ElevatorSlots"/>
                        <add_actor_to_room actor="$NPC" slot="this.$ElevatorSlot" triggeranimation="false"/>
                        <signal_cue_instantly cue="PerformPath__Force_Next" param="[$subdefinition, 1s]"/>
                        <!--<set_value name="$subdefinition.$finished" exact="true"/>-->
                      </do_elseif>
                      <!--
                      #########
                      ANIMATED CHAIRS
                      #########-->
                      <do_elseif value="@$subdefinition.$chair_walkto">
                        <do_if value="@$subdefinition.$walkdone">
                          <set_value name="$subdefinition.$finished" exact="true"/>
                          <debug_text text="player.age + ' walk to chair was done'" chance="@$DebugChance"/>
                        </do_if>
                        <do_else>
                          <!--Walk to the chair-->
                          <debug_text text="player.age + ' walk to chair ' + $subdefinition.$targetslot" chance="@$DebugChance"/>

                          <!--TODO @Owen - if the chair is very close, don't walk. Wait for the chair to turn, and then walk-->
                          <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot.component.chairbaseslot.{$subdefinition.$targetslot}" roomslot="@$pathtable.$roomslot" speed="$NPC.walkspeed" triggeranimation="not @$subdefinition.$preventanimation">
                            <!--Approach offset may be different per race-->
                            <position value="$subdefinition.$targetoffset"/>
                          </start_actor_walk>
                          <signal_cue_instantly cue="PerformPath__Approach_Chair_Listener" param="$subdefinition.$targetslot"/>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_sitdown">
                        <!--Add actor to seat - start the animation to sit down-->
                        <debug_text text="player.age + ' NPC preparing to sit down.'" chance="@$DebugChance"/>
                        <!--The NPC must be moved to the chair in the same frame the sitdown animation starts, which is the next frame. Prevents a frame of jumping into the chair.-->
                        <set_value name="$NPC.$state_machine_critical" exact="true"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <do_if value="PerformPath__Approach_Chair_Listener.state == cuestate.complete">
                          <reset_cue cue="PerformPath__Approach_Chair_Listener"/>
                        </do_if>
                        <debug_text text="player.age + ' connecting NPC to the chair'" chance="@$DebugChance"/>
                        <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false" chairtrigger="invalid">
                          <position value="$subdefinition.$targetoffset"/>
                        </add_actor_to_room>
                        <!--Only start sitdown animation in high attention-->
                        <do_if value="$NPC.hasbody">
                          <debug_text text="'Starting sitdown animation'" chance="@$DebugChance"/>
                          <start_actor_sequence actor="$NPC" type="'sitdown'" behavior="'generic'" transition="true" immediate="true" result="this.$animationstarted"/>
                          <do_if value="this.$animationstarted">
                            <set_value name="$endanimation" exact="'tran_stand_sit_01'"/>
                          </do_if>
                          <do_else>
                            <debug_text text="'failed to start animation \'sitdown\' on NPC ' + $NPC.knownname + ' ' + $NPC"/>
                            <set_value name="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'attention is ' + $NPC.attention + ' - skipping sitdown animation'" chance="@$DebugChance"/>
                          <set_value name="$subdefinition.$finished" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_rotateforward">
                        <!--Turn the chair forward-->
                        <debug_text text="player.age + ' turning chair forwards'" chance="@$DebugChance"/>
                        <set_value name="$NPC.$state_machine_critical" exact="true"/>
                        <precache_actor_animation_hint actor="$NPC" type="'idle'" slot="$subdefinition.$targetslot"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <animate_chair slot="$subdefinition.$targetslot" actor="$NPC" chairtrigger="activate_chair"/>
                        <!--TODO @Owen animation callback event for the chair turning?-->
                        <signal_cue_instantly cue="PerformPath__Force_Next" param="[$subdefinition, 1.2s]"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_facingforward">
                        <!--Chair facing forward-->
                        <debug_text text="player.age + ' chair facing forward.'" chance="@$DebugChance"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$finishedchair">
                        <!--Chair facing forward-->
                        <debug_text text="player.age + ' finished sitting on chair.'" chance="@$DebugChance"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                        <set_value name="$subdefinition.$targetconnectiondone" exact="true"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_rotatebackward">
                        <!--Turn the chair backwards-->
                        <debug_text text="player.age + ' turning chair backwards'" chance="@$DebugChance"/>
                        <set_value name="$NPC.$state_machine_critical" exact="true"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <animate_chair slot="$subdefinition.$targetslot" actor="$NPC" chairtrigger="deactivate_chair"/>
                        <do_if value="$NPC.hasbody and [race.argon, race.teladi, race.terran].indexof.{$NPC.race}">
                          <start_actor_sequence actor="$NPC" type="'prepstandup'" behavior="'generic'" transition="true" immediate="true"/>
                        </do_if>
                        <!--TODO @Owen animation callback event for the chair turning?-->
                        <signal_cue_instantly cue="PerformPath__Force_Next" param="[$subdefinition, 1.0s]"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_getup">
                        <!--Start the animation to get up-->
                        <debug_text text="player.age + ' get out of chair'" chance="@$DebugChance"/>
                        <set_value name="$NPC.$state_machine_critical" exact="true"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <do_if value="$NPC.hasbody">
                          <debug_text text="'Starting standup animation'" chance="@$DebugChance"/>
                          <start_actor_sequence actor="$NPC" type="'standup'" behavior="'generic'" transition="true" immediate="true" result="this.$animationstarted"/>
                          <do_if value="this.$animationstarted">
                            <set_value name="$endanimation" exact="'tran_sit_stand_01'"/>
                          </do_if>
                          <do_else>
                            <debug_text text="'failed to start animation \'standup\' on NPC ' + $NPC.knownname + ' ' + $NPC"/>
                            <set_value name="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'attention is ' + $NPC.attention + ' - skipping standup animation'" chance="@$DebugChance"/>
                          <set_value name="$subdefinition.$finished" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_leave">
                        <!--Turn the chair forward-->
                        <debug_text text="player.age + ' character left the chair. Rotate chair to the forward position after a delay.'" chance="@$DebugChance"/>
                        <!--At the end of the standup animation, the character's offset (which is currently at the seat) will be set to the visible position of the character-->
                        <clear_actor_current_chair actor="$NPC"/>
                        <!--Note: post 3.20 support. $subdefinition.$targetslot was replaced by $subdefinition.$chairslot-->
                        <animate_chair slot="if $subdefinition.$chairslot? then $subdefinition.$chairslot else $subdefinition.$targetslot" chairtrigger="activate_chair" delay="1s"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>

                      <!--
                      #########
                      STATIC CHAIRS
                      #########-->
                      <do_elseif value="@$subdefinition.$sit_down_static">
                        <!--Add actor to seat - start the animation to sit down-->
                        <debug_text text="player.age + ' NPC preparing to sit down.'" chance="@$DebugChance"/>
                        <!--The NPC must be moved to the chair in the same frame the sitdown animation starts, which is the next frame. Prevents a frame of jumping into the chair.-->
                        <set_value name="$NPC.$state_machine_critical" exact="true"/>
                        <do_if value="@$previousdefinition.$approach_static_seat and $subdefinition.$targetslot == $previousdefinition.$targetslot">
                          <debug_text text="player.age + ' connecting NPC to the static seat'" chance="@$DebugChance"/>
                          <add_actor_to_room actor="$NPC" slot="$previousdefinition.$targetslot" triggeranimation="false">
                            <position value="$previousdefinition.$targetoffset"/>
                            <rotation yaw="180deg"/>
                          </add_actor_to_room>
                        </do_if>
                        <!--Only start sitdown animation in high attention-->
                        <do_if value="$NPC.hasbody">
                          <debug_text text="'Starting sitdown animation'" chance="@$DebugChance"/>
                          <precache_actor_animation_hint actor="$NPC" type="'idle'" slot="$subdefinition.$targetslot"/>
                          <start_actor_sequence actor="$NPC" type="'sitdown'" behavior="'generic'" transition="true" immediate="true" result="this.$animationstarted"/>
                          <do_if value="this.$animationstarted">
                            <set_value name="$endanimation" exact="'tran_stand_sit_01'"/>
                          </do_if>
                          <do_else>
                            <debug_text text="'failed to start animation \'sitdown\' on NPC ' + $NPC.knownname + ' ' + $NPC"/>
                            <set_value name="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'attention is ' + $NPC.attention + ' - skipping sitdown animation'" chance="@$DebugChance"/>
                          <set_value name="$subdefinition.$finished" exact="true"/>
                        </do_else>
                      </do_elseif>

                      <do_elseif value="@$subdefinition.$sat_down_at_static">
                        <!--Connect to seat-->
                        <debug_text text="player.age + ' sat down at static seat. connecting to ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                        <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" blend="true"/>
                        <!--This is not a state_machine_critical moment as it happens instantly-->
                        <set_value name="$subdefinition.$finished" exact="true"/>
                        <set_value name="$subdefinition.$targetconnectiondone" exact="true"/>
                      </do_elseif>

                      <do_elseif value="@$subdefinition.$stand_up_static">
                        <debug_text text="player.age + ' get out of chair'" chance="@$DebugChance"/>
                        <set_value name="$NPC.$state_machine_critical" exact="true"/>
                        <do_if value="$NPC.hasbody">
                          <debug_text text="'Starting standup animation'" chance="@$DebugChance"/>
                          <precache_actor_animation_hint actor="$NPC" type="'stand'" behavior="'generic'" comment="prepare the standing animations"/>
                          <do_if value="[race.argon, race.teladi, race.terran].indexof.{$NPC.race}">
                            <start_actor_sequence actor="$NPC" type="'standupwithprep'" behavior="'generic'" transition="true" immediate="true" result="this.$animationstarted"/>
                          </do_if>
                          <do_else>
                            <start_actor_sequence actor="$NPC" type="'standup'" behavior="'generic'" transition="true" immediate="true" result="this.$animationstarted"/>
                          </do_else>
                          <do_if value="this.$animationstarted">
                            <set_value name="$endanimation" exact="'tran_sit_stand_01'"/>
                          </do_if>
                          <do_else>
                            <debug_text text="'failed to start animation \'standup\' on NPC ' + $NPC.knownname + ' ' + $NPC"/>
                            <set_value name="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'attention is ' + $NPC.attention + ' - skipping standup animation'" chance="@$DebugChance"/>
                          <set_value name="$subdefinition.$finished" exact="true"/>
                        </do_else>
                      </do_elseif>

                      <!--Warp to destination-->
                      <do_elseif value="@$subdefinition.$warp">
                        <!--Warp to the destination (probably due to low attention)-->
                        <!--Unset hidden flag first so that the adding of the NPC to the room can trigger the correct animations on them-->
                        <set_entity_traits entity="$NPC" hidden="false"/>
                        <do_if value="$subdefinition.$targetslot">
                          <do_if value="@$subdefinition.$targetposition and @$subdefinition.$targetrotation">
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="not @$subdefinition.$preventanimation">
                              <position value="$subdefinition.$targetposition"/>
                              <rotation value="$subdefinition.$targetrotation"/>
                            </add_actor_to_room>
                          </do_if>
                          <do_elseif value="@$subdefinition.$targetposition">
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="not @$subdefinition.$preventanimation">
                              <position value="$subdefinition.$targetposition"/>
                            </add_actor_to_room>
                          </do_elseif>
                          <do_elseif value="@$subdefinition.$targetrotation">
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="not @$subdefinition.$preventanimation">
                              <rotation value="$subdefinition.$targetrotation"/>
                            </add_actor_to_room>
                          </do_elseif>
                          <do_else>
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="not @$subdefinition.$preventanimation"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <do_if value="@$subdefinition.$targetrotation">
                            <add_actor_to_room actor="$NPC" object="$subdefinition.$targetroom" triggeranimation="not @$subdefinition.$preventanimation">
                              <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                              <rotation value="$subdefinition.$targetrotation"/>
                            </add_actor_to_room>
                          </do_if>
                          <do_else>
                            <add_actor_to_room actor="$NPC" object="$subdefinition.$targetroom" triggeranimation="not @$subdefinition.$preventanimation">
                              <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                            </add_actor_to_room>
                          </do_else>
                        </do_else>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_else>
                        <do_if value="@$subdefinition.$walkdone">
                          <!--Walk was already completed-->
                          <do_if value="@$subdefinition.$finished">
                            <!--already finished - potentially due to the chair animation-->
                            <do_all chance="@$DebugChance">
                              <do_if value="@$subdefinition.$targetslot">
                                <debug_text text="player.age + ' already walked to ' + $subdefinition.$targetslot"/>
                              </do_if>
                              <do_else>
                                <debug_text text="player.age + ' already walked to ' + $subdefinition.$context + ' ' + $subdefinition.$targetoffset"/>
                              </do_else>
                            </do_all>
                          </do_if>
                          <do_else>
                            <!--walk was done-->
                            <do_all chance="@$DebugChance">
                              <do_if value="@$subdefinition.$targetslot">
                                <debug_text text="player.age + ' walked to ' + $subdefinition.$targetslot"/>
                              </do_if>
                              <do_else>
                                <debug_text text="player.age + ' walked to ' + $subdefinition.$context + ' ' + $subdefinition.$targetoffset"/>
                              </do_else>
                            </do_all>
                            <set_value name="$subdefinition.$finished" exact="true"/>
                          </do_else>
                        </do_if>
                        <do_elseif value="@$subdefinition.$targetslot">
                          <do_if value="$subdefinition.$targetslot.component">
                            <!--walk to the next point which is a slot-->
                            <debug_text text="player.age + ' walk to ' + $subdefinition.$targetslot" chance="@$DebugChance"/>
                            <!--TODO @Owen already add the rotation to the definition and not have a npctransport special case-->
                            <do_if value="$subdefinition.$targetslot.hastag.npctransport">
                              <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed" triggeranimation="not @$subdefinition.$preventanimation">
                                <rotation yaw="180deg"/>
                              </start_actor_walk>
                              <set_value name="$waitforwalk" exact="true"/>
                            </do_if>
                            <do_else>
                              <do_if value="@$subdefinition.$targetoffset">
                                <!-- final walk to a specified targetoffset -->
                                <do_if value="@$subdefinition.$targetrotation">
                                  <debug_text text="'start_actor_walk to ' + $subdefinition.$targetslot + ' with $subdefinition.$targetoffset ' + $subdefinition.$targetoffset + ' and rotation ' + $subdefinition.$targetrotation" chance="@$DebugChance"/>
                                  <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed" triggeranimation="not @$subdefinition.$preventanimation">
                                    <position value="$subdefinition.$targetoffset"/>
                                    <rotation value="$subdefinition.$targetrotation"/>
                                  </start_actor_walk>
                                </do_if>
                                <do_else>
                                  <debug_text text="'start_actor_walk to ' + $subdefinition.$targetslot + ' with $subdefinition.$targetoffset ' + $subdefinition.$targetoffset" chance="@$DebugChance"/>
                                  <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed" triggeranimation="not @$subdefinition.$preventanimation">
                                    <position value="$subdefinition.$targetoffset"/>
                                  </start_actor_walk>
                                </do_else>
                              </do_if>
                              <do_else>
                                <debug_text text="'start_actor_walk without offset'" chance="@$DebugChance"/>
                                <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed" triggeranimation="not @$subdefinition.$preventanimation"/>
                              </do_else>
                              <set_value name="$waitforwalk" exact="true"/>
                            </do_else>
                          </do_if>
                          <do_else>
                            <debug_text text="'$subdefinition.$targetslot is no longer valid. Component may have been destroyed or removed. NPC ' + $NPC + ' ' + $NPC.knownname + ' will not walk and will perform the next path action.'" filter="error"/>
                            <set_value name="$waitforwalk" exact="true"/>
                          </do_else>
                        </do_elseif>
                        <do_else>
                          <!--walk to the next point which is a non-slot position-->
                          <debug_text text="player.age + ' walk to ' + $subdefinition.$context + ' ' + $subdefinition.$context.knownname + ' ' + $subdefinition.$targetoffset" chance="@$DebugChance"/>
                          <do_if value ="@$subdefinition.$targetoffset">
                            <!-- final walk to a specified targetoffset -->
                            <debug_text text="'start_actor_walk with $subdefinition.$targetoffset ' + $subdefinition.$targetoffset" chance="@$DebugChance"/>
                            <do_if value="@$subdefinition.$targetrotation">
                              <start_actor_walk actor="$NPC" target="$subdefinition.$targetroom" speed="$speed" triggeranimation="not @$subdefinition.$preventanimation">
                                <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                                <rotation value="$subdefinition.$targetrotation"/>
                              </start_actor_walk>
                            </do_if>
                            <do_else>
                              <start_actor_walk actor="$NPC" target="$subdefinition.$targetroom" speed="$speed" triggeranimation="not @$subdefinition.$preventanimation">
                                <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                              </start_actor_walk>
                            </do_else>
                          </do_if>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_else>

                      <do_if value="@$subdefinition.$finished">
                        <do_if value="@$subdefinition.$subdefinition">
                          <!--continue to next point-->
                          <set_value name="$previousdefinition" exact="@$subdefinition"/>
                          <set_value name="$subdefinition" exact="@$subdefinition.$subdefinition"/>
                        </do_if>
                        <do_else>
                          <!--done-->
                          <debug_text text="'Movement is done'" chance="@$DebugChance"/>
                          <do_if value="not @$subdefinition.$targetconnectiondone">
                            <do_if value="@$subdefinition.$targetslot">
                              <do_if value="$subdefinition.$targetslot.component">
                                <do_if value="$subdefinition.$targetslot.hastag.npctransport">
                                  <set_entity_traits entity="$NPC" hidden="true"/>
                                </do_if>
                                <do_if value="@$subdefinition.$targetoffset">
                                  <do_if value="@$subdefinition.$targetrotation">
                                    <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="not @$subdefinition.$preventanimation">
                                      <position value="$subdefinition.$targetoffset"/>
                                      <rotation value="$subdefinition.$targetrotation"/>
                                    </add_actor_to_room>
                                  </do_if>
                                  <do_else>
                                    <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="not @$subdefinition.$preventanimation">
                                      <position value="$subdefinition.$targetoffset"/>
                                    </add_actor_to_room>
                                  </do_else>
                                </do_if>
                                <do_else>
                                  <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" blend="true" triggeranimation="not @$subdefinition.$preventanimation"/>
                                </do_else>
                              </do_if>
                              <do_else>
                                <debug_text text="'Final $subdefinition.$targetslot is no longer valid. Component may have been destroyed or removed. NPC may not end up where they were intended.'" filter="error"/>
                              </do_else>
                            </do_if>
                            <do_else>
                              <do_if value="@$subdefinition.$targetrotation">
                                <add_actor_to_room actor="$NPC" object="$subdefinition.$targetroom" triggeranimation="not @$subdefinition.$preventanimation">
                                  <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                                  <rotation value="$subdefinition.$targetrotation"/>
                                </add_actor_to_room>
                              </do_if>
                              <do_else>
                                <add_actor_to_room actor="$NPC" object="$subdefinition.$targetroom" triggeranimation="not @$subdefinition.$preventanimation">
                                  <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                                </add_actor_to_room>
                              </do_else>
                            </do_else>
                          </do_if>
                          <set_entity_traits entity="$NPC" intransit="false"/>
                          <remove_value name="$NPC.$state_machine_critical"/>
                          <signal_cue_instantly cue="$signalcue"/>
                          <cancel_cue cue="PerformPath"/>
                          <break/>
                        </do_else>
                      </do_if>
                      <do_else>
                        <!--Must wait for walk or animation to finish-->
                        <set_value name="$nextpath" exact="$subdefinition"/>
                        <break/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <set_value name="$previousdefinition" exact="@$subdefinition"/>
                      <set_value name="$subdefinition" exact="@$subdefinition.$subdefinition"/>
                    </do_else>
                  </do_while>
                </do_if>
              </actions>
              <cues>
                <cue name="PerformPath_KeepAlive">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                </cue>

                <cue name="PerformPath_Animation_Failed" onfail="cancel">
                  <conditions>
                    <check_value value="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                  </conditions>
                  <actions>
                    <debug_text text="player.age + ' animation failed' + $NPC" chance="@$DebugChance"/>
                    <set_value name="$nextpath.$finished" exact="true"/>
                    <reset_cue cue="PerformPath_Evaluate"/>
                  </actions>
                </cue>

                <cue name="PerformPath_Animation_Timeout" onfail="cancel">
                  <conditions>
                    <check_value value="$endanimation"/>
                  </conditions>
                  <!--TODO @Owen @Martin - find out why animations do not send finish events once they are started. Change of attention?-->
                  <delay exact="15s"/>
                  <actions>
                    <debug_text text="player.age + ' animation timeout' + $NPC" chance="@$DebugChance"/>
                    <set_value name="$nextpath.$finished" exact="true"/>
                    <reset_cue cue="PerformPath_Evaluate"/>
                  </actions>
                </cue>

                <cue name="Animation_Hint" onfail="cancel">
                  <conditions>
                    <check_value value="@$hintedanimation"/>
                  </conditions>
                  <actions>
                    <precache_actor_animation_hint actor="$NPC" type="$hintedanimation.{1}" behavior="$hintedanimation.{2}"/>
                    <debug_text text="player.age + ' Hinting animation ' + $hintedanimation" chance="@$DebugChance"/>
                  </actions>
                  <delay exact="3s"/>
                  <actions>
                    <reset_cue cue="this"/>
                  </actions>
                </cue>

                <cue name="PerformPath_Pod_Arrival" onfail="cancel">
                  <conditions>
                    <check_value value="$NPC.podarrivaltime"/>
                  </conditions>
                  <actions>
                    <debug_text text="player.age + ' awaiting pod to arrive at ' + $NPC.podarrivaltime + ' for ' + $NPC + ' ' + $NPC.knownname" chance="@$DebugChance"/>
                  </actions>
                  <cues>
                    <cue name="PerformPath_Pod_Arrived">
                      <conditions>
                        <event_object_signalled object="$NPC" param="'npc__pod_arrived'"/>
                      </conditions>
                      <actions>
                        <debug_text text="player.age + ' pod arrived with ' + $NPC" chance="@$DebugChance"/>
                        <do_if value="$nextpath">
                          <set_value name="$nextpath.$podarrived" exact="true"/>
                        </do_if>
                        <reset_cue cue="PerformPath_Evaluate"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="PerformPath_Walk_Timeout" onfail="cancel" version="2">
                  <conditions>
                    <check_value value="$waitforwalk"/>
                  </conditions>
                  <patch sinceversion="2" state="complete">
                    <debug_text text="player.age + ' ' + $NPC + ' Resetting walk timeout checks after loading.'" filter="savegame"/>
                    <set_value name="$Patch_IgnoreGameLoad" exact="true"/>
                    <reset_cue cue="PerformPath_Walk_Timeout"/>
                  </patch>
                  <cues>
                    <!--Check that walking starts after a certain amount of time. Otherwise skip walking.-->
                    <cue name="PerformPath_Walk_Check" checkinterval="1ms">
                      <conditions>
                        <!--TODO @Owen event_npc_walk_started-->
                        <check_value value="$NPC.iswalking"/>
                      </conditions>
                      <actions>
                        <cancel_cue cue="PerformPath_Walk_Conv_Wait"/>
                        <debug_text text="player.age + ' NPC ' + $NPC + ' ' + $NPC.knownname + ' started walking'" chance="@$DebugChance"/>
                        <set_value name="PerformPath_Walk_Timeout.$LastWalkTime" exact="player.age"/>
                      </actions>
                      <cues>
                        <!--Check that a walking NPC is actually moving-->
                        <cue name="PerformPath_Walk_Stuck_Check" checkinterval="1s">
                          <conditions>
                            <check_any>
                              <check_value value="not $NPC.iswalking and not $NPC.isinconversation"/>
                              <check_value value="$NPC.iswalking and player.age gt PerformPath_Walk_Timeout.$LastWalkTime + 5s and $NPC.relspeed lt 0.01m"/>
                            </check_any>
                          </conditions>
                          <!--Give an additional 5 seconds for the zero speed walking NPC to sort themselves out-->
                          <delay exact="5s"/>
                          <actions>
                            <do_if value="not $NPC.iswalking or $NPC.relspeed lt 0.01m">
                              <!--<debug_text text="player.age + ' NPC ' + $NPC + ' was stuck while walking on ' + $NPC.parent.macro.name" filter="error"/>-->
                              <set_value name="$nextpath.$walkdone" exact="true"/>
                              <stop_actor_walk actor="$NPC"/>
                              <reset_cue cue="PerformPath_Evaluate"/>
                            </do_if>
                            <do_else>
                              <set_value name="PerformPath_Walk_Timeout.$LastWalkTime" exact="player.age"/>
                              <reset_cue cue="PerformPath_Walk_Stuck_Check"/>
                            </do_else>
                          </actions>
                        </cue>
                      </cues>
                    </cue>
                    <cue name="PerformPath_Walk_Conv_Wait" checkinterval="1ms">
                      <conditions>
                        <check_value value="not $NPC.isinconversation"/>
                      </conditions>
                      <cues>
                        <cue name="PerformPath_Walk_Start_Timeout" checktime="parent.time + 3s">
                          <actions>
                            <debug_text text="player.age + ' walk timeout ' + $NPC" chance="@$DebugChance"/>
                            <set_value name="$nextpath.$walkdone" exact="true"/>
                            <stop_actor_walk actor="$NPC"/>
                            <reset_cue cue="PerformPath_Evaluate"/>
                          </actions>
                        </cue>
                      </cues>
                    </cue>
                    <cue name="PerformPath_Walk_Timeout_GameLoaded">
                      <conditions>
                        <event_game_loaded/>
                        <check_value value="not @$Patch_IgnoreGameLoad"/>
                      </conditions>
                      <actions>
                        <do_if value="PerformPath_Walk_Check.state != cuestate.cancelled and PerformPath_Walk_Check.state != cuestate.disabled">
                          <cancel_cue cue="PerformPath_Walk_Check"/>
                        </do_if>
                        <do_if value="PerformPath_Walk_Conv_Wait.state != cuestate.cancelled and PerformPath_Walk_Conv_Wait.state != cuestate.disabled">
                          <cancel_cue cue="PerformPath_Walk_Conv_Wait"/>
                        </do_if>
                      </actions>
                      <delay exact="5s"/>
                      <actions>
                        <reset_cue cue="PerformPath_Walk_Timeout"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <cue name="PerformPath_Walk_Finished" instantiate="true">
              <conditions>
                <event_npc_walk_finished object="$NPC"/>
                <check_value value="$waitforwalk"/>
              </conditions>
              <actions>
                <debug_text text="player.age + ' walk finished'" chance="@$DebugChance"/>
                <set_value name="$nextpath.$walkdone" exact="true"/>
                <reset_cue cue="PerformPath_Evaluate"/>
              </actions>
            </cue>

            <cue name="PerformPath__Animation_Finished" instantiate="true">
              <conditions>
                <event_character_animation_finished object="$NPC" id="$endanimation"/>
              </conditions>
              <delay exact="event.param2"/>
              <actions>
                <debug_text text="player.age + ' animation finished: ' + $endanimation + ' with blend duration ' + event.param2" chance="@$DebugChance"/>
                <set_value name="$nextpath.$finished" exact="true"/>
                <reset_cue cue="PerformPath_Evaluate"/>
              </actions>
            </cue>

            <!--event.param.{1} == pathdefinition to force, .{2} delay-->
            <cue name="PerformPath__Force_Next" instantiate="true" version="2">
              <conditions>
                <event_cue_signalled/>
              </conditions>
              <actions>
                <do_if value="not this.$nextpath?" comment="check needed to avoid spam in patched cases">
                  <set_value name="this.$nextpath" exact="event.param.{1}"/>
                  <set_value name="this.$delay" exact="event.param.{2}"/>
                </do_if>
              </actions>
              <delay exact="this.$delay"/>
              <actions>
                <do_if value="this.$nextpath and not @this.$nextpath.$finished and not @this.$nextpath.$dirty">
                  <debug_text text="player.age + ' forcing current path to be finished: ' + this.$nextpath" chance="@$DebugChance"/>
                  <set_value name="this.$nextpath.$finished" exact="true"/>
                  <reset_cue cue="PerformPath_Evaluate"/>
                </do_if>
              </actions>
              <patch sinceversion="2" state="active">
                <set_value name="this.$nextpath" exact="@$nextpath"/>
                <set_value name="this.$delay" exact="1s"/>
              </patch>
            </cue>

            <cue name="PerformPath__Trigger_Reevaluation" instantiate="true">
              <conditions>
                <check_any>
                  <event_entity_transport_finished entity="$NPC"/>
                  <event_object_signalled object="$NPC" param="'reevaluate_path'"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="event.name == 'event_entity_transport_finished'">
                  <do_if value="event.param2">
                    <debug_text text="$NPC + ' ' + $NPC.knownname + ' arrived in a transporter that they triggered. Continue path.'" chance="@$DebugChance"/>
                  </do_if>
                  <do_else>
                    <debug_text text="$NPC + ' ' + $NPC.knownname + ' arrived in a transporter that they did not trigger. Reevaluate path.'" chance="@$DebugChance"/>
                  </do_else>
                </do_if>
                <do_elseif value="@event.param == 'reevaluate_path'">
                  <debug_text text="$NPC + ' ' + $NPC.knownname + ' was signalled to reevaluate path.'" chance="@$DebugChance"/>
                </do_elseif>
                <include_actions ref="PerformPath__Reevaluate_Path"/>
              </actions>
            </cue>

            <!--Attempt to build a new pathtable from the current position of the NPC.
            Should be used in fail cases where re-evaluation has a high-chance of succeeding, e.g. the NPC was brought along in a transporter by another, but not the one they wanted-->
            <library name="PerformPath__Reevaluate_Path">
              <actions>
                <do_if value="not @$NPC.$state_machine_critical">
                  <do_if value="@$pathtable.$destinationslot">
                    <run_actions result="this.$newpathtable" ref="GetNextTargetPoint_ToSlot">
                      <param name="NPC" value="$NPC"/>
                      <param name="DestinationSlot" value="$pathtable.$destinationslot"/>
                      <param name="DestinationOffset" value="$pathtable.$destinationoffset"/>
                      <param name="DestinationRotation" value="$pathtable.$destinationrotation"/>
                      <param name="DestinationTags" value="$pathtable.$destinationtags"/>
                      <param name="DebugChance" value="@$DebugChance"/>
                    </run_actions>
                  </do_if>
                  <do_elseif value="@$pathtable.$destinationcontext">
                    <run_actions result="this.$newpathtable" ref="GetNextTargetPoint_ToPosition">
                      <param name="NPC" value="$NPC"/>
                      <param name="DestinationContext" value="$pathtable.$destinationcontext"/>
                      <param name="DestinationContextRoom" value="$pathtable.$destinationcontextroom"/>
                      <param name="DestinationOffset" value="$pathtable.$destinationoffset"/>
                      <param name="DestinationRotation" value="$pathtable.$destinationrotation"/>
                      <param name="DestinationTags" value="$pathtable.$destinationtags"/>
                      <param name="DebugChance" value="@$DebugChance"/>
                    </run_actions>
                  </do_elseif>
                  <do_if value="@this.$newpathtable">
                    <set_value name="this.$subdefinition" exact="$pathtable"/>
                    <do_if value="$pathtable.$speed?">
                      <set_value name="this.$newpathtable.$speed" exact="$pathtable.$speed"/>
                    </do_if>
                    <do_while value="this.$subdefinition">
                      <set_value name="this.$subdefinition.$dirty" exact="true"/>
                      <set_value name="this.$subdefinition" exact="@this.$subdefinition.$subdefinition"/>
                    </do_while>
                    <set_value name="$pathtable" exact="this.$newpathtable"/>
                    <debug_text text="$NPC + ' ' + $NPC.knownname + ' successfully evaluated a new path table. Flagging the old one as dirty.'" chance="@$DebugChance"/>
                    <reset_cue cue="PerformPath_Evaluate"/>
                  </do_if>
                  <do_else>
                    <debug_text text="$NPC + ' ' + $NPC.knownname + ' failed to evaluate a new path table. Will continue on current one.'" chance="@$DebugChance"/>
                  </do_else>
                </do_if>
              </actions>
            </library>

            <!--event.param == NPC slot related to the chair-->
            <cue name="PerformPath__Approach_Chair_Listener">
              <conditions>
                <event_cue_signalled/>
                <check_value value="typeof event.param == datatype.componentslot"/>
              </conditions>
              <actions>
                <set_value name="$ChairSlot" exact="event.param"/>
                <debug_text text="player.age + ' setting up chair approach listener for ' + $ChairSlot" chance="@$DebugChance"/>
              </actions>
              <cues>
                <cue name="PerformPath__Approach_Chair_Listener_Near" checkinterval="1ms">
                  <conditions>
                    <check_value value="$NPC.attention ge attention.nearby and $NPC.distanceto.{$ChairSlot} lt 3m"/>
                  </conditions>
                  <actions>
                    <debug_text text="player.age + ' triggering chair deactivation state for ' + $ChairSlot" chance="@$DebugChance"/>
                    <animate_chair slot="$ChairSlot" actor="$NPC" chairtrigger="deactivate_chair"/>
                    <!--Precaching the sitdown animation is important as it has a start offset. Waiting for it to load may lead to the character visibly being in the wrong position until it is loaded.-->
                    <precache_actor_animation_hint actor="$NPC" type="'sitdown'" behavior="'generic'"/>
                  </actions>
                  <cues>
                    <cue name="PerformPath__Approach_Chair_Game_Loaded" instantiate="true">
                      <conditions>
                        <event_game_loaded/>
                        <cue_is_complete cue="PerformPath__Approach_Chair_Listener_Near"/>
                      </conditions>
                      <actions>
                        <debug_text text="player.age + ' Savegame was loaded. Resetting the approach listener to set the chair in the correct state.'" chance="@$DebugChance"/>
                        <reset_cue cue="PerformPath__Approach_Chair_Listener_Near"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <!--event.param
                .{1} == Approach elevator slot
                .{2} == Approach subdefinition table-->
            <cue name="PerformPath__Approach_Elevator_Listener" instantiate="true" namespace="this" version="2">
              <conditions>
                <event_cue_signalled/>
                <check_value value="typeof event.param.{1} == datatype.componentslot"/>
              </conditions>
              <actions>
                <set_value name="$NPC" exact="parent.$NPC"/>
                <set_value name="$DebugChance" exact="@parent.$DebugChance"/>
                <set_value name="$ApproachSlot" exact="event.param.{1}"/>
                <set_value name="$SubdefinitionTable" exact="event.param.{2}"/>
                <set_value name="$ActivateElevator" exact="not $ApproachSlot.hastag.elevator_bottom"/>
                <set_value name="$IsActing" exact="false"/>
                <!--TODO @Owen #group filter-->
                <find_npc_waypoint name="$OppositeSlots" object="$ApproachSlot.component" tags="if $ActivateElevator then tag.elevator_bottom else tag.elevator_top" multiple="true"/>
                <set_value name="$OppositeSlot" exact="null"/>
                <do_for_each name="$PotentialOppositeSlot" in="$OppositeSlots">
                  <do_if value="$ApproachSlot.group == $PotentialOppositeSlot.group">
                    <set_value name="$OppositeSlot" exact="$PotentialOppositeSlot"/>
                    <break/>
                  </do_if>
                </do_for_each>
                <remove_value name="$OppositeSlots"/>
                <find_npc_waypoint name="$ElevatorSlots" object="$ApproachSlot.component" tags="tag.npc_elevator" multiple="true"/>
                <set_value name="$ElevatorSlot" exact="null"/>
                <do_for_each name="$PotentialElevatorSlot" in="$ElevatorSlots">
                  <do_if value="$ApproachSlot.group == $PotentialElevatorSlot.group">
                    <set_value name="$ElevatorSlot" exact="$PotentialElevatorSlot"/>
                    <break/>
                  </do_if>
                </do_for_each>
                <remove_value name="$ElevatorSlots"/>
                <do_if value="$NPC and $OppositeSlot and $ElevatorSlot">
                  <debug_text text="player.age + ' setting up elevator approach listener for ' + $ApproachSlot + ' for NPC ' + $NPC + ' ' + $NPC.knownname" chance="$DebugChance"/>
                  <start_actor_walk actor="$NPC" target="$ApproachSlot"/>
                  <signal_cue_instantly cue="md.NPC_State_Machines.ElevatorManager_AddRequest" param="this"/>
                </do_if>
                <do_else>
                  <debug_text text="player.age + ' forcing current path to be finished: ' + $SubdefinitionTable" chance="$DebugChance"/>
                  <set_value name="$SubdefinitionTable.$finished" exact="true"/>
                  <reset_cue cue="PerformPath_Evaluate"/>
                  <cancel_cue cue="PerformPath__Approach_Elevator_Listener"/>
                </do_else>
              </actions>
              <patch sinceversion="2">
                <set_value name="$IsActing" exact="PerformPath__Approach_Elevator_Listener_Enter_Elevator.state == cuestate.complete"/>
              </patch>
              <cues>
                <cue name="PerformPath__Approach_Elevator_Listener_Queue">
                  <conditions>
                    <event_cue_signalled cue="PerformPath__Approach_Elevator_Listener"/>
                    <check_value value="event.param == 'queue'"/>
                  </conditions>
                  <!--TODO @Owen stopping walks too quickly makes getting out of the chair look ugly-->
                  <delay exact="if player.age gt PerformPath__Approach_Elevator_Listener.time + 1s then 0s else 1s"/>
                  <actions>
                    <debug_text text="player.age + ' stopping actor walk for NPC ' + $NPC + ' ' + $NPC.knownname" chance="$DebugChance"/>
                    <stop_actor_walk actor="$NPC"/>
                  </actions>
                </cue>
                <cue name="PerformPath__Approach_Elevator_Listener_Abort_Request">
                  <conditions>
                    <event_cue_signalled cue="PerformPath__Approach_Elevator_Listener"/>
                    <check_value value="event.param == 'abort'"/>
                  </conditions>
                  <actions>
                    <debug_text text="player.age + ' aborting movement to elevator slot ' + $ElevatorSlot + ' for NPC ' + $NPC + ' ' + $NPC.knownname + ' - Reevaluating path'" chance="$DebugChance"/>
                    <signal_objects object="$NPC" param="'reevaluate_path'" delay="1ms"/>
                    <cancel_cue cue="PerformPath__Approach_Elevator_Listener"/>
                  </actions>
                </cue>
                <cue name="PerformPath__Approach_Elevator_Listener_Enter_Elevator">
                  <conditions>
                    <event_cue_signalled cue="PerformPath__Approach_Elevator_Listener"/>
                    <check_value value="event.param == 'enter_elevator'"/>
                  </conditions>
                  <actions>
                    <!--Cancel PerformPath__Approach_Elevator_Listener_Queue as it may be on a delay to stop the walk-->
                    <do_if value="PerformPath__Approach_Elevator_Listener_Queue.state == cuestate.active">
                      <cancel_cue cue="PerformPath__Approach_Elevator_Listener_Queue"/>
                    </do_if>
                    <start_actor_walk actor="$NPC" target="$ElevatorSlot"/>
                    <debug_text text="player.age + ' start walk to elevator slot ' + $ElevatorSlot + ' for NPC ' + $NPC + ' ' + $NPC.knownname" chance="$DebugChance"/>
                  </actions>
                  <cues>
                    <!--TODO @Owen query the NPC speed-->
                    <cue name="PerformPath__Approach_Elevator_Listener_Enter_Elevator_Timeout">
                      <delay exact="if $NPC.attention lt attention.nearby then 0s else 5s"/>
                      <actions>
                        <signal_cue cue="PerformPath__Approach_Elevator_Listener_In_Elevator"/>
                      </actions>
                    </cue>
                    <cue name="PerformPath__Approach_Elevator_Listener_In_Elevator">
                      <conditions>
                        <check_any>
                          <event_npc_walk_finished object="$NPC"/>
                          <event_cue_signalled/>
                        </check_any>
                      </conditions>
                      <actions>
                        <cancel_cue cue="PerformPath__Approach_Elevator_Listener_Enter_Elevator_Timeout"/>
                        <add_actor_to_room actor="$NPC" slot="$ElevatorSlot"/>
                        <do_if value="$ActivateElevator">
                          <debug_text text="player.age + ' triggering elevator activation state for ' + $ElevatorSlot + ' for NPC ' + $NPC + ' ' + $NPC.knownname" chance="$DebugChance"/>
                          <trigger_animation object="$ElevatorSlot.component" group="$ElevatorSlot.group" trigger="activate"/>
                        </do_if>
                        <do_else>
                          <debug_text text="player.age + ' triggering elevator deactivation state for ' + $ElevatorSlot + ' for NPC ' + $NPC + ' ' + $NPC.knownname" chance="$DebugChance"/>
                          <trigger_animation object="$ElevatorSlot.component" group="$ElevatorSlot.group" trigger="deactivate"/>
                        </do_else>
                      </actions>
                      <cues>
                        <cue name="PerformPath__Approach_Elevator_Listener_Finish" checkinterval="50ms">
                          <conditions>
                            <check_any>
                              <check_value value="$NPC.attention lt attention.nearby"/>
                              <check_all>
                                <check_value value="$ActivateElevator"/>
                                <check_animation_state object="$ElevatorSlot.component" state="'active'" group="$ElevatorSlot.group" tag="tag.elevator"/>
                              </check_all>
                              <check_all>
                                <check_value value="not $ActivateElevator"/>
                                <check_animation_state object="$ElevatorSlot.component" state="'deactivated'" group="$ElevatorSlot.group" tag="tag.elevator"/>
                              </check_all>
                            </check_any>
                          </conditions>
                          <!--TODO #Hack @Owen delay to allow the recalcuation of the navmesh when the elevator has finished moving to position-->
                          <delay exact="if $NPC.attention lt attention.nearby then 0s else 1s"/>
                          <actions>
                            <debug_text text="player.age + ' forcing current path to be finished: ' + $SubdefinitionTable + ' for NPC ' + $NPC + ' ' + $NPC.knownname" chance="$DebugChance"/>
                            <set_value name="$SubdefinitionTable.$finished" exact="true"/>
                            <reset_cue cue="PerformPath_Evaluate"/>
                            <cancel_cue cue="PerformPath__Approach_Elevator_Listener"/>
                          </actions>
                        </cue>
                      </cues>
                    </cue>

                  </cues>
                </cue>

              </cues>
            </cue>

            <!--The NPC must be moved to the chair in the same frame the sitdown animation starts, which is the next frame. Prevents a frame of jumping into the chair.
            We will probably have to do this with any character animation with a start offset which is not 0,0,0-->
            <!-- This cue only remains for savegame compatibility reasons! -->
            <cue name="PerformPath__Delayed_Chair_Connection">
              <conditions>
                <event_cue_signalled/>
                <check_value value="typeof event.param == datatype.componentslot"/>
              </conditions>
              <delay exact="1ms"/>
              <actions>
                <debug_text text="player.age + ' connecting NPC to the chair'" chance="@$DebugChance"/>
                <add_actor_to_room actor="$NPC" slot="event.param" triggeranimation="false" chairtrigger="invalid"/>
              </actions>
            </cue>
          </cues>
        </library>
      </cues>
    </cue>

    <!--Signal cue: ElevatorManager_AddRequest to add a request-->
    <cue name="ElevatorManager" namespace="this">
      <actions>
        <!--Table where key is the elevator slot, the value is the instance of -->
        <set_value name="$RequestTable" exact="table[]"/>
        <set_value name="$DebugChance" exact="100"/>
      </actions>
      <cues>
        <cue name="ElevatorManager_CullRequests" instantiate="true" checkinterval="10s">
          <actions>
            <do_for_each name="$RequestKey" valuename="$RequestCue" in="$RequestTable" reverse="true">
              <do_if value="not @$RequestKey.component or not $RequestCue.exists">
                <debug_text text="'Removing request instance for ' + @$RequestKey" chance="$DebugChance"/>
                <remove_value name="$RequestTable.{$RequestKey}"/>
              </do_if>
            </do_for_each>
          </actions>
        </cue>

        <!--event.param == instance of PerformPath__Approach_Elevator_Listener-->
        <cue name="ElevatorManager_AddRequest" instantiate="true">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <debug_text text="'Received request for ' + @event.param.$ElevatorSlot + ' from ' + @event.param.$NPC + ' ' + @event.param.$NPC.knownname" chance="$DebugChance"/>
            <do_if value="@event.param.$ElevatorSlot">
              <do_if value="not $RequestTable.{event.param.$ElevatorSlot}?">
                <debug_text text="'Signalling new elevator manager instance'" chance="$DebugChance"/>
                <signal_cue_instantly cue="ElevatorManager_Instance" param="event.param.$ElevatorSlot"/>
              </do_if>
              <do_if value="$RequestTable.{event.param.$ElevatorSlot}?">
                <append_to_list name="$RequestTable.{event.param.$ElevatorSlot}.$Requesters" exact="event.param"/>
                <do_if value="event.param.$DebugChance">
                  <set_value name="$RequestTable.{event.param.$ElevatorSlot}.$DebugChance" exact="event.param.$DebugChance"/>
                </do_if>
              </do_if>
            </do_if>
          </actions>
        </cue>

        <!--Internal: event.param == elevator slot-->
        <cue name="ElevatorManager_Instance" namespace="this" instantiate="true" version="2">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <set_value name="$ElevatorSlot" exact="event.param"/>
            <do_if value="typeof $ElevatorSlot == datatype.componentslot and $ElevatorSlot.component.exists">
              <set_value name="ElevatorManager.$RequestTable.{$ElevatorSlot}" exact="this"/>
              <set_value name="$Requesters" exact="[]"/>
              <set_value name="$MinAssignNextTime" exact="player.age"/>
              <!--TODO @Owen #group filter-->
              <find_npc_waypoint name="$TopWaitSlots" object="$ElevatorSlot.component" tags="tag.elevator_wait_top" multiple="true"/>
              <set_value name="$TopWaitSlot" exact="null"/>
              <do_for_each name="$PotentialTopWaitSlot" in="$TopWaitSlots">
                <do_if value="$ElevatorSlot.group == $PotentialTopWaitSlot.group">
                  <set_value name="$TopWaitSlot" exact="$PotentialTopWaitSlot"/>
                  <break/>
                </do_if>
              </do_for_each>
              <remove_value name="$TopWaitSlots"/>
              <find_npc_waypoint name="$TopElevatorSlots" object="$ElevatorSlot.component" tags="tag.elevator_top" multiple="true"/>
              <set_value name="$TopElevatorSlot" exact="null"/>
              <do_for_each name="$PotentialTopElevatorSlot" in="$TopElevatorSlots">
                <do_if value="$ElevatorSlot.group == $PotentialTopElevatorSlot.group">
                  <set_value name="$TopElevatorSlot" exact="$PotentialTopElevatorSlot"/>
                  <break/>
                </do_if>
              </do_for_each>
              <remove_value name="$TopElevatorSlots"/>
              <set_value name="$DebugChance" exact="0"/>
            </do_if>
            <do_else>
              <cancel_cue cue="this"/>
            </do_else>
          </actions>
          <patch sinceversion="2">
            <do_if value="$ElevatorSlot.component.attention lt attention.nearby">
              <do_for_each name="$Requester" in="$Requesters">
                <do_if value="$Requester.exists">
                  <debug_text text="'Stuck low attention elevator NPC ' + $Requester.$NPC.knownname + ' ' + $Requester.$NPC + ' will be unstuck'" filter="savegame"/>
                </do_if>
              </do_for_each>
            </do_if>
          </patch>
          <cues>
            <cue name="ElevatorManager_Instance_Check" instantiate="true" checkinterval="100ms">
              <actions>
                <!--Cull invalid requester cues-->
                <do_if value="$Requesters.count">
                  <set_value name="$CurrentNPC" exact="$ElevatorSlot.component.slotactor.{$ElevatorSlot}"/>
                  <set_value name="$ElevatorActors" exact="$ElevatorSlot.component.waypointactors.{$ElevatorSlot}"/>
                  <do_for_each name="$Requester" in="$Requesters" counter="$i" reverse="true">
                    <do_if value="not $Requester.exists">
                      <remove_value name="$Requesters.{$i}"/>
                    </do_if>
                    <!--<do_elseif value="player.age gt $Requester.time + 5s and not $Requester.$IsActing">
                      <set_value name="$RequesterTarget" exact="$Requester.$NPC.targetslot"/>
                      <do_if value="$CurrentNPC != $Requester.$NPC and $ElevatorActors.indexof.{$Requester.$NPC} == 0 and
                               (not $RequesterTarget or $RequesterTarget.component != $ElevatorSlot.component or $RequesterTarget.group != $ElevatorSlot.group)">
                        <assert value="false" text="'NPC ' + $Requester.$NPC + ' ' + $Requester.$NPC.knownname + ' is no longer an actor related to the elevator slot. Aborting elevator request [Owen]'"/>
                        <signal_cue_instantly cue="$Requester" param="'abort'"/>
                        <remove_value name="$Requesters.{$i}"/>
                      </do_if>
                      <remove_value name="$RequesterTarget"/>
                    </do_elseif>-->
                  </do_for_each>
                </do_if>
                <do_if value="$Requesters.count">
                  <do_if value="$ElevatorSlot.component.attention lt attention.nearby">
                    <debug_text text="'Signalling low attention NPC ' + $Requesters.{1}.$NPC.knownname + ' ' + $Requesters.{1}.$NPC + ' to instantly enter the elevator'" chance="$DebugChance"/>
                    <signal_cue_instantly cue="$Requesters.{1}" param="'enter_elevator'" check="false"/>
                  </do_if>
                  <do_else>
                    <do_if value="not $CurrentNPC and $ElevatorActors.count">
                      <set_value name="$CurrentNPC" exact="$ElevatorActors.{1}"/>
                    </do_if>
                    <do_if value="$CurrentNPC">
                      <set_value name="$MinAssignNextTime" exact="player.age + 2s"/>
                    </do_if>
                    <check_animation_state result="$IsActivated" object="$ElevatorSlot.component" state="'active'" group="$ElevatorSlot.group" tag="tag.elevator"/>
                    <check_animation_state result="$IsDeactivated" object="$ElevatorSlot.component" state="'deactivated'" group="$ElevatorSlot.group" tag="tag.elevator"/>
                    <set_value name="$IsAnimating" exact="not $IsActivated and not $IsDeactivated"/>
                    <!--Sort all nearby requesters into activating/deactivating request lists-->
                    <set_value name="$QueuingRequester_ActivatedLift" exact="[]"/>
                    <set_value name="$QueuingRequester_DeactivatedLift" exact="[]"/>
                    <do_for_each name="$Requester" in="$Requesters">
                      <do_if value="$CurrentNPC != $Requester.$NPC">
                        <do_if value="$Requester.$NPC.distanceto.{$Requester.$ApproachSlot} lt 3m">
                          <do_if value="$Requester.$ActivateElevator">
                            <append_to_list name="$QueuingRequester_DeactivatedLift" exact="$Requester"/>
                          </do_if>
                          <do_else>
                            <append_to_list name="$QueuingRequester_ActivatedLift" exact="$Requester"/>
                          </do_else>
                        </do_if>
                        <!--Try to catch stuck NPCs but be aware of active conversations and queued transitions which are to act-->
                        <do_elseif value="player.age gt $Requester.time + 5s and not $Requester.$NPC.iswalking and not $Requester.$NPC.isinconversation and not @$Requester.$NPC.$StateMachine.$QueuedTransitionRequests.count">
                          <assert value="false" text="'NPC ' + $Requester.$NPC + ' ' + $Requester.$NPC.knownname + ' is supposed to be moving towards the elevator but is not walking. Aborting elevator request [Owen]'"/>
                          <signal_cue_instantly cue="$Requester" param="'abort'"/>
                        </do_elseif>
                      </do_if>
                    </do_for_each>

                    <!--If elevator is not currently engaged either animate it to a requested position, or signal a NPC to enter it-->
                    <do_if value="($QueuingRequester_ActivatedLift.count or $QueuingRequester_DeactivatedLift.count) and not $CurrentNPC and not $IsAnimating and player.age ge $MinAssignNextTime">
                      <do_if value="$IsActivated">
                        <do_if value="$QueuingRequester_ActivatedLift.count">
                          <signal_cue_instantly cue="$QueuingRequester_ActivatedLift.{1}" param="'enter_elevator'" check="false"/>
                          <remove_value name="$QueuingRequester_ActivatedLift.{1}"/>
                        </do_if>
                        <do_else>
                          <debug_text text="player.age + ' triggering elevator deactivation state for ' + $ElevatorSlot + ' so NPC ' + $QueuingRequester_DeactivatedLift.{1}.$NPC.knownname + ' can enter'" chance="$DebugChance"/>
                          <trigger_animation object="$ElevatorSlot.component" group="$ElevatorSlot.group" trigger="deactivate"/>
                        </do_else>
                      </do_if>
                      <do_elseif value="$IsDeactivated">
                        <do_if value="$QueuingRequester_DeactivatedLift.count">
                          <set_value name="$DoEnter" exact="true"/>
                          <do_if value="$TopWaitSlot and $TopElevatorSlot">
                            <!--Check that the navmesh is generated to allow movement between the top wait slot and top elevator slot-->
                            <!--TODO @Owen keep a maximum wait time-->
                            <check_walk_path result="$DoEnter" actor="$QueuingRequester_DeactivatedLift.{1}.$NPC" start="$TopWaitSlot" end="$TopElevatorSlot" checkstate="false"/>
                          </do_if>
                          <do_if value="$DoEnter">
                            <signal_cue_instantly cue="$QueuingRequester_DeactivatedLift.{1}" param="'enter_elevator'" check="false"/>
                            <remove_value name="$QueuingRequester_DeactivatedLift.{1}"/>
                          </do_if>
                        </do_if>
                        <do_else>
                          <debug_text text="player.age + ' triggering elevator activation state for ' + $ElevatorSlot + ' so NPC ' + $QueuingRequester_ActivatedLift.{1}.$NPC.knownname + ' can enter'" chance="$DebugChance"/>
                          <trigger_animation object="$ElevatorSlot.component" group="$ElevatorSlot.group" trigger="activate"/>
                        </do_else>
                      </do_elseif>
                    </do_if>

                    <!--Tell everyone else to wait-->
                    <do_for_each name="$Requester" in="$QueuingRequester_ActivatedLift">
                      <signal_cue_instantly cue="$Requester" param="'queue'" check="false"/>
                    </do_for_each>
                    <do_for_each name="$Requester" in="$QueuingRequester_DeactivatedLift">
                      <signal_cue_instantly cue="$Requester" param="'queue'" check="false"/>
                    </do_for_each>
                  </do_else>
                </do_if>
                <do_else>
                  <remove_value name="ElevatorManager.$RequestTable.{$ElevatorSlot}"/>
                  <cancel_cue cue="ElevatorManager_Instance"/>
                </do_else>
              </actions>
            </cue>
          </cues>
        </cue>
      </cues>
    </cue>
  </cues>
</mdscript>
